{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the documentation page for libtropic!</p> <p>Libtropic is a C-based Software Development Kit (SDK) developed by Tropic Square. Designed for seamless integration, it offers a user-friendly, high-level API that enables host platforms to easily interface with the TROPIC01 secure element.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Get Started: All the things you need to get started with libtropic.</li> <li>API Reference: Detailed libtropic API documentation generated with Doxygen.</li> <li>For Contributors: If you need more information on libtropic to start developing or contributing.</li> <li>FAQ: Frequently Asked Questions, contains solutions to common problems.</li> <li>Other: Even more information about libtropic.</li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>This list might help you resolve some issues.</p> <ul> <li>I received an error</li> <li>I cannot establish a Secure Session</li> <li>FW update failed</li> <li>What is the part number (P/N) of my TROPIC01?</li> <li>What is the silicon revision of my TROPIC01?</li> <li>What FW versions is my TROPIC01 running?</li> </ul>"},{"location":"faq/#i-received-an-error","title":"I received an error","text":"<p>Description of all return values is in the <code>libtropic_common.h</code> (<code>lt_ret_t</code> enum). However, some errors may have a seemingly unrelated cause; see the following paragraphs.</p>"},{"location":"faq/#lt_l1_chip_busy","title":"<code>LT_L1_CHIP_BUSY</code>","text":"<p>Normally, this means that the chip is busy processing an operation and is unable to respond. However, it can also mean that the SPI lines (mainly <code>MISO</code>) are tied to ground (causing the host to receive all zeroes). Check your connections.</p> <p>The reason is that we detect the status of the TROPIC01 using a single flag; if all data are zero, we cannot distinguish between the TROPIC01 being truly busy and the host receiving only zeroes.</p>"},{"location":"faq/#lt_l1_chip_alarm_mode","title":"<code>LT_L1_CHIP_ALARM_MODE</code>","text":"<p>Normally, this means the TROPIC01 entered Alarm Mode. However, it can also mean \u2014 similarly to <code>LT_L1_CHIP_BUSY</code> \u2014 that all ones are received on <code>MISO</code>. Check your connections.</p>"},{"location":"faq/#lt_l3_data_len_error","title":"<code>LT_L3_DATA_LEN_ERROR</code>","text":"<p>This error normally means that the L3 packet size we sent to the TROPIC01 is incorrect, which can be caused by a bug or an attack. However, it can also mean that the chip select is connected incorrectly. Check your connections and GPIO assignments.</p> <p>Chip Select Handling</p> <p>We use a GPIO to handle chip select, not the SPI peripheral's native chip select output.</p>"},{"location":"faq/#lt_l3_invalid_cmd-or-lt_l2_unknown_req","title":"<code>LT_L3_INVALID_CMD</code> or <code>LT_L2_UNKNOWN_REQ</code>","text":"<p>This error means that the TROPIC01 does not recognize the L3 command or L2 request it received. However, this behavior can be caused by the TROPIC01 being in Maintenance Mode. Maintenance Mode does not implement the entire API \u2014 it does not implement <code>Handshake_Req</code> nor any L3 commands, so handshake attempts will always fail.</p> <p>A TROPIC01 will be in Maintenance Mode after a user-triggered reboot (calling <code>lt_reboot</code> with <code>TR01_MAINTENANCE_REBOOT</code> as <code>startup_id</code>). In that case, reboot the chip back to Application Mode by calling <code>lt_reboot</code> with <code>TR01_REBOOT</code>. During evaluation you can also use the lt_ex_show_chip_id_and_fwver.c example, which reboots to Application Mode at the end.</p> <p>However, a TROPIC01 can also enter Maintenance Mode automatically after an unsuccessful update or if firmware banks are empty or corrupted. In that case, a simple reboot will not help; you must run the firmware update again, either using the lt_ex_fw_update.c example or from your application code.</p>"},{"location":"faq/#i-cannot-establish-a-secure-session","title":"I cannot establish a Secure Session","text":"<p>There are two main causes:</p> <ol> <li> <p>You are using incorrect pairing keys.    All new TROPIC01s use production pairing keys, which are used by default in Libtropic. Some devkits still contain preview chips (engineering samples). For those, you need to use different keys. Refer to the Default Pairing Keys for a Secure Channel Handshake.</p> </li> <li> <p>Your TROPIC01 is in Maintenance Mode.    Reboot to Application Mode by calling <code>lt_reboot</code> with <code>TR01_REBOOT</code>, or during evaluation use the lt_ex_show_chip_id_and_fwver.c example, which reboots to Application Mode at the end.</p> </li> </ol>"},{"location":"faq/#fw-update-failed","title":"FW update failed","text":"<p>If our lt_ex_fw_update example program failed:</p> <ol> <li>Try the suggestions in I received an error.</li> <li>Make sure you have correct values set in the following CMake options:<ul> <li>LT_SILICON_REV,</li> <li>LT_CPU_FW_UPDATE_DATA_VER.</li> </ul> </li> <li>Make sure you are not attempting a firmware downgrade \u2014 TROPIC01 does not allow this.</li> </ol>"},{"location":"faq/#what-is-the-part-number-pn-of-my-tropic01","title":"What is the part number (P/N) of my TROPIC01?","text":"<p>You have two options:</p> <ol> <li>Read it from the packaging you received your TROPIC01 product in.</li> <li>Run our example program lt_ex_show_chip_id_and_fwver, which does not require the Secure Channel Session. For building instructions, refer to our Integration Examples.</li> </ol>"},{"location":"faq/#what-is-the-silicon-revision-of-my-tropic01","title":"What is the silicon revision of my TROPIC01?","text":"<p>You have two options:</p> <ol> <li>Read the product number (P/N) from the packaging you received your TROPIC01 product in. After that, refer to the Available Parts section (in the TROPIC01 GitHub repository) and read the linked Catalog list, which will help you decode the silicon revision based on your P/N.</li> <li>Run our example program lt_ex_show_chip_id_and_fwver, which does not require the Secure Channel Session. For building instructions, refer to our Integration Examples.</li> </ol>"},{"location":"faq/#what-fw-versions-is-my-tropic01-running","title":"What FW versions is my TROPIC01 running?","text":"<p>Run our example program lt_ex_show_chip_id_and_fwver, which does not require the Secure Channel Session. For building instructions, refer to our Integration Examples.</p>"},{"location":"doxygen/mainpage/","title":"Introduction","text":"<p>Welcome to the documentation for the libtropic API!</p> <p>For more information about libtropic, visit the libtropic repository.</p>"},{"location":"doxygen/mainpage/#documentation-structure","title":"Documentation Structure","text":"<p>The documentation is organized into the following sections:</p> <ul> <li>Introduction: This page.</li> <li>Topics: Detailed documentation of macros, functions, and data structures, organized by the individual components of the libtropic SDK.</li> <li>Data Structures: A comprehensive overview and index of all available data structures in the libtropic SDK.</li> <li>Files: A list of all header files included in the SDK, along with their descriptions.</li> </ul> <p>We hope this documentation helps you make the most of the libtropic SDK. If you have any questions or need further assistance, please refer to the repository, or, if you are a customer, contact the support team.</p>"},{"location":"for_contributors/","title":"For Contributors","text":"<ul> <li>Contributing Guide</li> <li>Functional Tests</li> <li>Adding a New Host Platform</li> <li>Adding a New Cryptographic Functionality Provider</li> <li>Building the Documentation</li> </ul>"},{"location":"for_contributors/adding_cfp/","title":"Adding a New Cryptographic Functionality Provider","text":"<p>Because Libtropic is designed to run on the Host MCU, it requires certain cryptographic functionality \u2014 for example, to decrypt incoming L3 packets from TROPIC01. To enable this, Libtropic defines a Crypto Abstraction Layer (CAL) to abstract the functionality required from a chosen Cryptographic Functionality Provider (CFP). CFP can implement the function either purely in software (using a cryptographic library) or in hardware (using a cryptographic hardware accelerator) or by combining both (e.g., implement all operations in MbedTLS except of the AES-GCM, which will be handled by a STM32's peripheral). This interface-based design makes it easy to integrate and support additional CFPs in the future.</p>"},{"location":"for_contributors/adding_cfp/#requirements","title":"Requirements","text":"<p>The new CFP has to support the following schemes:</p> <ul> <li>AES-GCM<ul> <li>encryption</li> <li>decryption</li> </ul> </li> <li>SHA256<ul> <li>hashing</li> </ul> </li> <li>Curve25519<ul> <li>multiplication on both arbitrary and base point</li> </ul> </li> </ul>"},{"location":"for_contributors/adding_cfp/#guide","title":"Guide","text":"<p>To add support for a new CFP (let's say <code>mycrypto</code>):</p> <ol> <li>Create and Implement the CAL C Files,</li> <li>Create and Implement the CAL CMakeLists.txt,</li> <li>Provide Some Information About the CAL.</li> </ol> <p>Get Inspired by Existing CALs</p> <p>For inspiration, see the existing CALs inside <code>cal/</code>.</p> <p>After these steps, the sources and include directories of the new CAL should be available in consumer's <code>CMakeLists.txt</code> by calling: <pre><code>add_subdirectory(\"&lt;path_to_libtropic&gt;/cal/mycrypto\")\n</code></pre></p> <p>By doing this, the CMake variables <code>LT_CAL_SRCS</code> and <code>LT_CAL_INC_DIRS</code> will become available to the consumer.</p>"},{"location":"for_contributors/adding_cfp/#create-and-implement-the-cal-c-files","title":"Create and Implement the CAL C Files","text":"<ol> <li>Inside <code>cal/</code>, create a new directory called <code>mycrypto</code>.</li> <li>Inside <code>cal/mycrypto/</code>, create the following source files:<ul> <li><code>lt_mycrypto_common.c</code></li> <li><code>lt_mycrypto_aesgcm.c</code>,</li> <li><code>lt_mycrypto_sha256.c</code>,</li> <li><code>lt_mycrypto_hmac_sha256.c</code>,</li> <li><code>lt_mycrypto_x25519.c</code>.</li> </ul> </li> <li> <p>In each of the source files, implement all required functions \u2014 they are declared in the respective headers inside the <code>libtropic/src/</code> directory:</p> <ul> <li><code>lt_crypto_common.h</code>: Common CAL functions,</li> <li><code>lt_aesgcm.h</code>: AES-GCM functions,</li> <li><code>lt_sha256.h</code>: SHA256 functions,</li> <li><code>lt_hmac_sha256.h</code>: HMAC SHA256 functions,</li> <li><code>lt_x25519.h</code>: Curve25519 functions.</li> </ul> <p>Look into each header \u2014 the exact purpose of every function is described in its comment. Copy the function declarations from the headers to the source files and implement the functions.</p> <p>Example</p> <p>To implement Curve25519 functions, copy declarations from <code>lt_x25519.h</code> to <code>lt_mycrypto_x25519.c</code> and provide implementations.</p> </li> <li> <p>Inside <code>cal/mycrypto/</code>, create a file <code>libtropic_mycrypto.h</code>. This file should declare the context structure for <code>mycrypto</code>: <pre><code>typedef struct lt_ctx_mycrypto_t {\n    /** @private @brief AES-GCM context for encryption. */\n    // TODO\n    /** @private @brief AES-GCM context for decryption. */\n    // TODO\n    /** @private @brief SHA-256 context. */\n    // TODO\n} lt_ctx_mycrypto_t;\n</code></pre></p> <p>Which Contexts Are Needed?</p> <p>This structure must include all contexts the functions in the CAL might need. The structure will be defined in the user's application and assigned to the <code>crypto_ctx</code> void pointer in the <code>lt_handle_t</code> \u2014 see the Libtropic Bare-Bone Example for more information.</p> </li> <li> <p>Additionally, other source files and headers can be created for the needs of the implementation.</p> </li> </ol>"},{"location":"for_contributors/adding_cfp/#create-and-implement-the-cal-cmakeliststxt","title":"Create and Implement the CAL CMakeLists.txt","text":"<p>Inside <code>cal/mycrypto/</code>, create a <code>CMakeLists.txt</code> with the following contents: <pre><code>set(LT_CAL_SRCS\n    ${CMAKE_CURRENT_SOURCE_DIR}/lt_mycrypto_common.c    \n    ${CMAKE_CURRENT_SOURCE_DIR}/lt_mycrypto_aesgcm.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/lt_mycrypto_sha256.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/lt_mycrypto_hmac_sha256.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/lt_mycrypto_x25519.c\n    # Other source files if needed\n)\n\nset(LT_CAL_INC_DIRS\n    ${CMAKE_CURRENT_SOURCE_DIR}\n    # Other include directories if needed\n)\n\n# export generic names for parent to consume\nset(LT_CAL_SRCS ${LT_CAL_SRCS} PARENT_SCOPE)\nset(LT_CAL_INC_DIRS ${LT_CAL_INC_DIRS} PARENT_SCOPE)\n</code></pre></p>"},{"location":"for_contributors/adding_cfp/#provide-some-information-about-the-cal","title":"Provide Some Information About the CAL","text":"<p>All currently supported CFPs are listed in the Supported Cryptographic Functionality Providers section. Add the new CFP there and provide some information about it and the CAL (see other sections for inspiration).</p>"},{"location":"for_contributors/adding_host_platform/","title":"Adding a New Host Platform","text":"<p>Libtropic is written to be platform-independent, so no changes to the main code base are needed when adding support for a new host platform. However, to define how communication on the L1 Layer will work, a new Hardware Abstraction Layer (HAL) must be implemented. Currently available HALs are located in <code>hal/</code>.</p>"},{"location":"for_contributors/adding_host_platform/#guide","title":"Guide","text":"<p>This guide will walk you through adding support for a new platform. In this guide, we will add a support for a microcontroller called <code>my_mcu</code> on a board <code>my_board</code>. The directory structure will be different if you create a port e.g., for an operating system. In that case, please get inspired by existing ports (POSIX, Linux).</p> <p>To add support for a our new platform (<code>my_board</code> with <code>my_mcu</code>):</p> <ol> <li>Create and Implement the HAL C Files,</li> <li>Create and Implement the HAL CMakeLists.txt,</li> <li>Provide Some Information About the HAL.</li> </ol> <p>Get Inspired by Existing HALs</p> <p>For inspiration, see the existing HALs inside <code>hal/</code>.</p> <p>After these steps, the sources and include directories of the new HAL should be available in consumer's <code>CMakeLists.txt</code> by calling: <pre><code>add_subdirectory(\"&lt;path_to_libtropic&gt;/hal/my_mcu/my_board\")\n</code></pre></p> <p>By doing this, the CMake variables <code>LT_HAL_SRCS</code> and <code>LT_HAL_INC_DIRS</code> will become available to the consumer.</p>"},{"location":"for_contributors/adding_host_platform/#create-and-implement-the-hal-c-files","title":"Create and Implement the HAL C Files","text":"<ol> <li> <p>Inside <code>hal/</code>, create a new directory called <code>my_mcu</code>.</p> <p>Note</p> <p>The <code>my_mcu/</code> directory inside <code>hal/</code> might already exist, so you do not have to create a new one \u2014 just use the existing one (e.g. <code>stm32</code>).</p> </li> <li> <p>Inside <code>hal/my_mcu/</code>, create a directory called <code>my_board</code>. This is where the implementation will go.</p> </li> <li>Inside <code>hal/my_mcu/my_board/</code>, create the following files:<ul> <li><code>libtropic_port_my_mcu_my_board.h</code>,</li> <li><code>libtropic_port_my_mcu_my_board.c</code>.</li> </ul> </li> <li> <p>Inside <code>libtropic_port_my_mcu_my_board.h</code>, declare:</p> <ol> <li> <p>A new device structure with public and private members in the following way: <pre><code>typedef struct lt_dev_my_mcu_my_board_t {\n    // Public part\n    /** @brief @public first public member comment */\n    // ...\n    /** @brief @public n-th public member comment */\n\n    // Private part\n    /** @brief @private first private member comment */\n    // ...\n    /** @brief @private n-th pivate member comment */\n} lt_dev_my_mcu_my_board_t;\n</code></pre></p> <p>Which Members Are Needed?</p> <p>These members are usually physical pin numbers, SPI handles, or other information needed in the HAL functions that handle the platform-specific interface on the L1 Layer.</p> </li> <li> <p>Additional macros or types you will need in <code>libtropic_port_my_mcu_my_board.c</code>.</p> </li> </ol> </li> <li> <p>Inside <code>libtropic_port_my_mcu_my_board.c</code>, implement all functions declared in <code>include/libtropic_port.h</code>. All of the port functions have an instance of <code>lt_l2_state_t</code> as one of the parameters, where your instance of <code>lt_dev_my_mcu_my_board_t</code> will be saved, so you can get it in a following way: <pre><code>// one of the functions from include/libtropic_port.h\nlt_ret_t lt_port_spi_csn_high(lt_l2_state_t *s2)\n{\n    lt_dev_my_mcu_my_board_t *device =\n        (lt_dev_my_mcu_my_board_t *)(s2-&gt;device);\n\n    // Your implementation ...\n\n    return LT_OK;\n}\n</code></pre></p> <p>Implementation of <code>lt_port_random_bytes</code></p> <p>This function should use some cryptographically secure mechanism to generate the random bytes. Its speed should not be a concern, as this function is not called often.</p> </li> <li> <p>Additionally, other source files and headers can be created for the needs of the implementation.</p> </li> </ol>"},{"location":"for_contributors/adding_host_platform/#create-and-implement-the-hal-cmakeliststxt","title":"Create and Implement the HAL CMakeLists.txt","text":"<p>Inside <code>hal/my_mcu/my_board/</code>, create a <code>CMakeLists.txt</code> with the following contents: <pre><code>set(LT_HAL_SRCS\n    ${CMAKE_CURRENT_SOURCE_DIR}/libtropic_port_my_mcu_my_board.c\n    # Other source files if needed\n)\n\nset(LT_HAL_INC_DIRS\n    ${CMAKE_CURRENT_SOURCE_DIR}\n    # Other include directories if needed\n)\n\n# export generic names for parent to consume\nset(LT_HAL_SRCS ${LT_HAL_SRCS} PARENT_SCOPE)\nset(LT_HAL_INC_DIRS ${LT_HAL_INC_DIRS} PARENT_SCOPE)\n</code></pre></p>"},{"location":"for_contributors/adding_host_platform/#provide-some-information-about-the-hal","title":"Provide Some Information About the HAL","text":"<p>All currently supported host platforms are listed in the Supported Host Platforms section. Add the new host platform there and provide some information about it and the HAL (see other sections for inspiration).</p>"},{"location":"for_contributors/building_documentation/","title":"Building the Documentation","text":"<p>Libtropic documentation is built using the two following frameworks, each building a different part of the documentation:</p> <ol> <li>MkDocs, used to generate the pages you are seeing right now,</li> <li>Doxygen, used to generate the API Reference from the libtropic source code.</li> </ol> <p>Normally, you should not need to build the documentation yourself - it is available on our GitHub Pages, where versions for the master branch and all releases are automatically built and released by our GitHub Actions. However, in the case of contributing to the documentation, it is handy to be able to build it locally and preview the new changes. Refer to the following sections for steps on how to do that.</p>"},{"location":"for_contributors/building_documentation/#installation-of-the-dependencies","title":"Installation of the Dependencies","text":"<p>To install MkDocs, do the following:</p> <ol> <li>Install Python 3, at least version 3.8.</li> <li>We recommend creating a Python Virtual Environment, for example with a name <code>.docs-venv</code>: <pre><code>python3 -m venv .docs-venv\nsource .docs-venv/bin/activate\n</code></pre></li> <li>Update <code>pip</code> and install the needed <code>pip</code> packages using <code>docs/requirements.txt</code>: <pre><code>pip install --upgrade pip\npip install -r docs/requirements.txt\n</code></pre></li> </ol> <p>After that, install Doxygen and Graphviz (used for the diagrams) - installation depends on your system, but we will use Ubuntu in this example: <pre><code>sudo apt-get install doxygen graphviz\n</code></pre></p>"},{"location":"for_contributors/building_documentation/#building-with-doxygen","title":"Building with Doxygen","text":"<p>First, the API Reference has to be built using Doxygen:</p> <ol> <li>Switch to <code>docs/doxygen/</code>: <pre><code>cd docs/doxygen/\n</code></pre></li> <li>Build: <pre><code>doxygen Doxyfile.in\n</code></pre></li> </ol> <p>The API Reference should be now built in <code>docs/doxygen/build/html/</code>.</p> <p>Warning</p> <p>These steps have to be done each time the contents of <code>docs/doxygen/</code> change and you want to preview the changes.</p>"},{"location":"for_contributors/building_documentation/#building-with-mkdocs","title":"Building with MkDocs","text":"<p>MkDocs has the ability to run a builtin development server on localhost, where the documentation is automatically deployed. To run it, switch to the root libtropic directory, where <code>mkdocs.yml</code> is located, and run: <pre><code>mkdocs serve\n</code></pre> In the terminal, you should see the address of the server. While holding CTRL, left-click the address to open it in your browser (or just manually copy it).</p> <p>Warning</p> <p>MkDocs does not rebuilt the Doxygen documentation automatically - to rebuild it, repeat the steps from section Building with Doxygen.</p> <p>Tip</p> <p>Each time you edit some files inside <code>docs/</code>, the server does not have to be stopped and run again - the server content will be automatically reloaded on each file save.</p>"},{"location":"for_contributors/building_documentation/#versioned-documentation","title":"Versioned Documentation","text":"<p>When you build the documentation using the steps from the section Building with MkDocs, the version selector in the page header is not visible as it is on our GitHub Pages. That is because for the versioning, we use the mike plugin for MkDocs. This plugin maintains the <code>gh-pages</code> branch, from which the GitHub Pages are deployed.</p>"},{"location":"for_contributors/building_documentation/#previewing-the-versioned-documentation","title":"Previewing the Versioned Documentation","text":"<p>The most common and safe use case is to locally preview the state of the documentation that is deployed to our GitHub Pages. Do the following steps to achieve that:</p> <ol> <li>Make sure you have the latest version of the <code>gh-pages</code> branch from <code>origin</code>: <pre><code>git fetch origin\ngit pull origin gh-pages\n</code></pre> Do not <code>git checkout gh-pages</code>, because you will not be able to build the documentation there. Do <code>git checkout</code> with <code>master</code>, <code>develop</code> or any other branch based from one of these.</li> <li>Run a builtin development server with the contents of <code>gh-pages</code>: <pre><code>mike serve\n</code></pre> In the terminal, you should see the address of the server. While holding CTRL, left-click the address to open it in your browser (or just manually copy it).</li> </ol>"},{"location":"for_contributors/building_documentation/#editing-the-versioned-documentation","title":"Editing the Versioned Documentation","text":"<p>Danger</p> <p>Some of the following commands change the state of the local <code>git</code> repository, specifically the <code>gh-pages</code> branch, and possibly the <code>origin</code> remote!</p> <p>If you need to locally deploy a new version and preview it, you have to modify the <code>gh-pages</code> branch. To do that, run: <pre><code>mike deploy &lt;version_name&gt;\n</code></pre> After running this, <code>gh-pages</code> branch will be created (if it does not already exist) and the generated documentation will be pushed to it.</p> <p>Danger</p> <p>If you add the <code>--push</code> flag, the <code>gh-pages</code> branch will be pushed to <code>origin</code> - we do not recommend doing that! This applies to most of the <code>mike</code> commands.</p> <p>To see all existing versions, run: <pre><code>mike list\n</code></pre></p> <p>Info</p> <p>This command is safe - it does not change <code>gh-pages</code> branch.</p> <p>To remove a specific version, run: <pre><code>mike delete \n</code></pre> There are more commands available - refer to the mike repository for more information.</p>"},{"location":"for_contributors/contributing_guide/","title":"Contributing Guide","text":"<p>We love contributions! To make contributing simple for both sides, please:</p> <ul> <li>Open an issue and describe how you would like to contribute and discuss details with us.</li> <li>Create a branch from the develop branch and do the changes:<ul> <li>Make sure to follow specifics in our Coding Style.</li> <li>Make sure to use Code Formatter, otherwise the PR check will fail and cannot be merged.</li> <li>Make sure the branch passes Tests against model -- otherwise, the PR check will fail.</li> <li>Make sure to run Static Analysis.</li> <li>Make sure your Commit Messages follow our guidelines.</li> </ul> </li> <li>Create pull request.</li> </ul>"},{"location":"for_contributors/contributing_guide/#coding-style","title":"Coding Style","text":""},{"location":"for_contributors/contributing_guide/#structures-and-enums","title":"Structures and Enums","text":"<p>In the public API (<code>include/</code>), we define structured types and enumerations using <code>typedef</code>. We do NOT omit structure (enum) name, to keep possibility to declare using <code>struct</code>/<code>enum</code> keywords. Example:</p> <pre><code>typedef struct my_struct {\n    ...\n} my_struct;\n\ntypedef enum my_enum {\n    ...\n} my_enum;\n</code></pre> <p>Anywhere else, we do not use typedefs.</p>"},{"location":"for_contributors/contributing_guide/#code-formatter","title":"Code Formatter","text":"<p>We use the <code>clang-format</code> tool for code formatting. Its installation varies dependening on the linux distribution. </p> <p>Important</p> <p>We recommend using version 16 or higher.</p> <p>To check if <code>clang-format</code> is available on your machine, run: <pre><code>clang-format --version\n</code></pre></p> <p>We use <code>clang-format</code> to check code format on pushes and PRs into the master and develop branches - this is implemented in the action <code>.github/clang_format_check.yml</code>. It only checks the format and does not fix it - that is the contributor's responsibility.</p>"},{"location":"for_contributors/contributing_guide/#how-to-use-it","title":"How to Use It","text":"<p>There are multiple ways to format the code using <code>clang-format</code>:</p> <ol> <li>For each file with wrong formatting, run: <pre><code>clang-format -i &lt;path_to_the_file_to_format&gt;\n</code></pre></li> <li>If you are using VSCode and the <code>cpptools</code> extension, you can create <code>.vscode/settings.json</code> with the following contents (if it does not already exist): <pre><code>{ // Add this bracket only if your settings.json file is empty\n    \"[c]\": {\n        \"editor.defaultFormatter\": \"ms-vscode.cpptools\",\n        \"editor.formatOnSave\": true\n    },\n    \"[cpp]\": {\n        \"editor.defaultFormatter\": \"ms-vscode.cpptools\",\n        \"editor.formatOnSave\": true\n    },\n    \"C_Cpp.formatting\": \"clangFormat\"\n} // Add this bracket only if your settings.json file is empty\n</code></pre> This will format the file on each save.</li> <li>There is also the <code>git-clang-format</code> tool, which integrates <code>clang-format</code> with <code>git</code>, but we have not used that yet.</li> <li>Possibly other ways...</li> </ol>"},{"location":"for_contributors/contributing_guide/#static-analysis","title":"Static Analysis","text":"<p>To run static analysis, follow these steps:</p> <ol> <li>Choose a static analysis tool (e.g., cppcheck, clang-tidy).</li> <li>Configure the tool to analyze the library code.</li> <li>Run the analysis and review the reported issues.</li> </ol>"},{"location":"for_contributors/contributing_guide/#commit-messages","title":"Commit Messages","text":"<p>Our commit message format is inspired by Conventional Commits guidelines.</p> <p>The commit messages should fulfill the following: <pre><code>&lt; type &gt;[ optional scope ]: &lt; description &gt;\n[ optional JIRA REF ]\n[ optional body ]\n[ optional footer ( s ) ]\n</code></pre></p> <p>Where the meaning of individual \ufb01elds is:</p> <pre><code>&lt;type&gt; - Type of commit. Can be one of following:\n    - feat     - A new feature.\n    - build    - A change to build or compile scripts.\n    - ci       - A change to continuous integration setup and scripting.\n    - doc      - A change to documentation.\n    - refactor - A refactoring of code. Shall not change functionality.\n    - test     - A change in tests or test-bench environment.\n    - \ufb01x       - Fix of incorrect functionality.\n    - perf     - Performance enhancement.\n    - deps     - A change to dependency settings\n\n&lt;description&gt;  - Part of the repository or \ufb02ow where the change is made. The \ufb01rst line of the commit message shall be at most 72 characters long.\n\nscope          - Optional part of the repository or \ufb02ow where the change is made.\n\nJIRA REF       - Optional reference to a JIRA issue\n\nbody           - Optional arbitrary number of paragraphs describing what the commit does.\n\nfooter         - Optional footer (see https://www.conventionalcommits.org/en/v1.0.0/#specification)\n</code></pre>"},{"location":"for_contributors/functional_tests/","title":"Functional Tests","text":"<p>Functional tests are used to verify the libtropic core API and are implemented in <code>tests/functional/</code>. In the <code>libtropic</code> repository, these tests are run against the TROPIC01 Model only. Testing against the TROPIC01 model is also used in a CI job, triggered for the <code>master</code> and <code>develop</code> branches (pushes and pull requests). The tests can also be run in the libtropic platform repositories.</p> <p>The functional tests are organized into two categories, as some of them may cause irreversible changes to the chip:</p> <ul> <li>Reversible (<code>lt_test_rev_*.c</code>): only reversible operations are executed on the TROPIC01 chip.</li> <li>Irreversible (<code>lt_test_ire_*.c</code>): irreversible operations are executed - the state or contents of the TROPIC01 chip cannot be reverted.</li> </ul> <p>Compiling Functional Tests</p> <p>Functional tests are not compiled by default. They can be compiled using the LT_BUILD_TESTS CMake option. See How to Configure section for ways to enable this option.</p> <p>Cannot Establish a Secure Channel Session</p> <p>Refer to the dedicated section in the FAQ.</p> Advanced Tip: Running a Test With Your Own Pairing Key <p>If you have already written your own public key to one of the available slots and want to execute a test that uses a Secure Session, define the arrays for your private and public key as globals and, after <code>#include \"libtropic_functional_tests.h\"</code>, do the following: <pre><code>#undef LT_TEST_SH0_PRIV\n#define LT_TEST_SH0_PRIV &lt;var_name_with_your_private_pairing_key&gt;\n\n#undef LT_TEST_SH0_PUB\n#define LT_TEST_SH0_PUB &lt;var_name_with_your_public_pairing_key&gt;\n</code></pre></p>"},{"location":"for_contributors/functional_tests/#adding-a-new-test","title":"Adding a New Test","text":"<p>To add a new test, you need to:</p> <ol> <li>Decide whether the test is reversible or irreversible (see Test Types and Cleanup if you are not sure).</li> <li>Write the new test (see Test Template).</li> <li>Add the declaration together with a Doxygen comment to <code>include/libtropic_functional_tests.h</code>.</li> <li>Add the test to the root <code>CMakeLists.txt</code>:         - In the section \"LIBTROPIC FUNCTIONAL TESTS\", add the test name to the <code>LIBTROPIC_TEST_LIST</code> (it must match the name of the function that implements the test)         - Below the <code>LIBTROPIC_TEST_LIST</code>, there is a section where <code>SDK_SRCS</code> is extended             with test source files. Add your test source file there.</li> <li>Make sure your test works - you can run it against the TROPIC01 Model. If the test    fails, you either:<ul> <li>Did a mistake in the test. Fix it.</li> <li>Or you found a bug - if you are certain it is a bug and not a problem in your test,   open an issue. Thanks!</li> </ul> </li> </ol>"},{"location":"for_contributors/functional_tests/#test-types-and-cleanup","title":"Test Types and Cleanup","text":"<p>As the tests are also ran against the real chips, we recognize two types of tests:</p> <ol> <li>Reversible. This type of test shall not make any irreversible changes to the chip. It may    happen that the test is interrupted by a failed assert. For these cases, there is a possibility    to define a cleanup function, which is called on every failed assert before the test termination.    If the test does some changes to the chip, which should be reverted after the end of the test,    the cleanup function for the test must be implemented, to make the test truly reversible.</li> <li>Irreversible. This type of test causes changes that are not reversible by nature (e.g., I-Config     modifications). These tests do not have to implement a cleanup function, since the chip state or     contents cannot be reverted after the test ends.</li> </ol>"},{"location":"for_contributors/functional_tests/#cleanup-function","title":"Cleanup Function","text":"<p>If an assert fails, the assert function checks whether the <code>lt_test_cleanup_function</code> function pointer is not <code>NULL</code>. If so, the cleanup function is called automatically before terminating the test. By default, the pointer is initialized to <code>NULL</code>.</p> <p>If you need a cleanup function, create the function and assign it to <code>lt_test_cleanup_function</code> at the appropriate point in the test (for example, after you back up data that you will restore later).</p> <p>to duplicate the cleanup code if it would be the same. If you wrap the function call in the <code>LT_TEST_ASSERT</code>, do not forget to set <code>lt_test_cleanup_function</code> back to <code>NULL</code> beforehands, otherwise the cleanup will be called twice. You can reuse your cleanup function at the end of the test so you don't have to duplicate the cleanup code. If you wrap the function call in <code>LT_TEST_ASSERT</code>, remember to set <code>lt_test_cleanup_function</code> back to <code>NULL</code> beforehand, otherwise the cleanup will be called twice.</p>"},{"location":"for_contributors/functional_tests/#test-template","title":"Test Template","text":"<p>Change the lines marked with <code>TODO</code>.</p> <pre><code>/**\n * @file TODO: FILL ME\n * @brief TODO: FILL ME\n * @copyright Copyright (c) 2020-2025 Tropic Square s.r.o.\n *\n * @license For the license see the LICENSE.txt file in the root directory of this source tree.\n */\n\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_functional_tests.h\"\n#include \"libtropic_logging.h\"\n\n// Shared with cleanup function.\n// TODO: CAN BE REMOVED IF CLEANUP IS NOT USED.\nlt_handle_t *g_h;\n\n// TODO: REMOVE OR EDIT\nstatic lt_ret_t lt_new_test_cleanup(void)\n{\n    LT_LOG_INFO(\"Starting secure session with slot %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_verify_chip_and_start_secure_session(g_h, LT_TEST_SH0_PRIV, LT_TEST_SH0_PUB, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to establish secure session, ret=%s\", lt_ret_verbose(ret));\n        return ret;\n    }\n\n    // TODO: REST OF THE CLEANUP DUTIES\n\n    return LT_OK;\n}\n\nvoid lt_new_test(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"----------------------------------------------\");\n    LT_LOG_INFO(\"lt_new_test()\");\n    LT_LOG_INFO(\"----------------------------------------------\");\n\n    // TODO/NOTE: If you use cleanup, do not forget to assign handle to a globally available pointer,\n    // so you can use the handle in the cleanup function.\n    g_h = h;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    LT_TEST_ASSERT(LT_OK, lt_init(h));\n\n    LT_LOG_INFO(\"Starting secure session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    LT_TEST_ASSERT(LT_OK, lt_verify_chip_and_start_secure_session(h, LT_TEST_SH0_PRIV, LT_TEST_SH0_PUB, TR01_PAIRING_KEY_SLOT_INDEX_0));\n    LT_LOG_LINE();\n\n    // TODO: DO THE TESTING HERE\n    // Add this line if you need cleanup. Add it where appropriate -- e.g. after backing up data\n    // you need to restore in the cleanup.\n    lt_test_cleanup_function = &amp;lt_new_test_cleanup;\n\n    // Call cleanup function, but don't call it from LT_TEST_ASSERT anymore.\n    lt_test_cleanup_function = NULL;\n    LT_LOG_INFO(\"Starting post-test cleanup\");\n    LT_TEST_ASSERT(LT_OK, lt_new_test_cleanup());\n    LT_LOG_INFO(\"Post-test cleanup was successful\");\n}\n</code></pre>"},{"location":"get_started/","title":"Get Started","text":"<p>This section provides information to help you get started with libtropic.</p> <ul> <li>Libtropic Architecture</li> <li>Integrating Libtropic</li> <li>Examples</li> <li>TROPIC01 Firmware</li> <li>Default Pairing Keys for a Secure Channel Handshake</li> <li>Logging</li> <li>Debugging</li> </ul>"},{"location":"get_started/debugging/","title":"Debugging","text":"<p>When debugging, some additional compiler flags are needed to produce debugging information. These flags can be enabled using CMake's <code>CMAKE_BUILD_TYPE</code> option. This option can be set similarly as the Libtropic's CMake options \u2014 see How to Configure section.</p> <p>After this, you can use debugging tools of your choice, e.g. gdb or Valgrind. Refer to each tool's documentation for installation instructions.</p> <p>If you want to use AddressSanitizer, you have the following options:</p> <ol> <li>You are using the TROPIC01 Model \u2014 refer to its section for more information.</li> <li>You are using one of our platform repositories \u2014 pass <code>-DLT_ASAN=1</code> when building with <code>cmake</code> on the command line.</li> <li>In other cases, you will have to link it to Libtropic yourself.</li> </ol>"},{"location":"get_started/default_pairing_keys/","title":"Default Pairing Keys for a Secure Channel Handshake","text":"<p>To establish a Secure Channel Session with TROPIC01, one of the Pairing Key slots has to be written with an X25519 public key (refered to as \\(S_{HiPUB}\\), where \\(i\\) is the i-th slot). The entity, which is about to establish the Secure Channel Session with TROPIC01, has to own the corresponding X25519 private key (refered to as \\(S_{HiPRIV}\\)).</p> <p>At the time of manufacturing, Tropic Square configures the Pairing Key slot 0 of every TROPIC01 with \\(S_{H0PUB}\\), generated from \\(S_{H0PRIV}\\), which is provided to customers. The customer can then establish a Secure Channel Session with Pairing Key slot 0, configure TROPIC01, write their own X25519 public key to slot 1, 2 or 3 and invalidate the slot 0 (which is recommended for security reasons).</p> <p>More Information About Pairing Keys</p> <p>For more information, refer to the TROPIC01 datasheet.</p>"},{"location":"get_started/default_pairing_keys/#default-pairing-keys-in-libtropic","title":"Default Pairing Keys in Libtropic","text":"<p>Libtropic provides both of these default \\(S_{H0PUB}\\) and \\(S_{H0PRIV}\\) keys by including <code>libtropic_common.h</code>:</p> <ol> <li>arrays <code>sh0pub_prod0</code> and <code>sh0priv_prod0</code> - production keys found in the majority of distributed TROPIC01 chips (see Available Parts table in the TROPIC01 GitHub repository for P/N values),</li> <li>arrays <code>sh0pub_eng_sample</code> and <code>sh0priv_eng_sample</code> - keys found in engineering (pre-production) samples of TROPIC01 with P/N <code>TROPIC01-ES</code>.</li> </ol>"},{"location":"get_started/default_pairing_keys/#establishing-your-first-secure-channel-session","title":"Establishing Your First Secure Channel Session","text":"<p>To establish a Secure Channel Session with your new TROPIC01, do the following:</p> <ol> <li>Get P/N of your TROPIC01 \u2014 refer to FAQ.</li> <li> <p>Establish the Secure Channel Session:</p> <p>There are two options, depending on what you want to do \u2014 choose one:</p> <ol> <li>You want to run our examples or tests that establish a Secure Channel Session:<ol> <li>Your P/N is <code>TROPIC01-ES</code> -&gt; Set LT_SH0_KEYS CMake option to <code>\"eng_sample\"</code> (refer to How to Configure section for ways to set it).</li> <li>Your P/N is not <code>TROPIC01-ES</code> -&gt; nothing has to be done, the production keys are used by default.</li> </ol> </li> <li> <p>You are writing your own application -&gt; select the correct key pair arrays according to Default Pairing Keys in Libtropic and simply pass them to either:</p> <ol> <li><code>lt_verify_chip_and_start_secure_session</code> helper function, or</li> <li><code>lt_session_start</code> core API function.</li> </ol> <p>Refer to the API Reference for more information about these functions.</p> </li> </ol> </li> </ol>"},{"location":"get_started/libtropic_architecture/","title":"Libtropic Architecture","text":"<p>Before you learn about Libtropic's architecture, it is important to understand the communication between the host MCU and TROPIC01. Both parties communicate via a multi-layer serial protocol consisting of the following three layers:</p> <ol> <li>Physical Layer (L1). A transfer is a unit of communication and a 4-wire SPI interface is used.</li> <li>Data Link Layer (L2). A frame is a unit of communication that is organized into multiple fields. During L2 communication, the host MCU sends an L2 Request frame and TROPIC01 returns an L2 Response frame. Communication on the L2 Layer is not encrypted and is used for non-secure information about TROPIC01 and for setting up L3 communication.</li> <li>Secure Session Layer (L3). A packet is a unit of communication. L3 communication requires an established Secure Channel Session. Once established, the host MCU can communicate by sending L3 Command packets and TROPIC01 responds with L3 Result packets. The communication is executed on an encrypted channel (Secure Channel) with strong forward secrecy based on the Noise Protocol Framework.</li> </ol> <p>For more information about TROPIC01, please refer to TROPIC01 repository.</p> <p>Libtropic's architecture is visualized in the following figure:</p>      Libtropic Architecture    <p>Libtropic consists of:</p> <ol> <li>Libtropic Public API. Macros and data structures are available in <code>include/libtropic_common.h</code> and function declarations are in <code>include/libtropic.h</code> (implemented in <code>src/libtropic.c</code>). The interface of these functions is tightly related to TROPIC01's commands, defined in the User API (see the TROPIC01 repository). These public functions are used for unencrypted communication via the Layer 2 API, and encrypted communication via the Layer 3 API.</li> <li>Helpers. Functions also declared in <code>include/libtropic.h</code> that either wrap one or more libtropic API functions to simplify operations (e.g. <code>lt_verify_chip_and_start_secure_session()</code> for easier Secure Session establishment), or provide additional functionality (e.g. <code>lt_print_chip_id()</code> for interpreting and printing TROPIC01's <code>CHIP_ID</code>).</li> <li>Examples. Demonstrate usage of Libtropic, using both the Libtropic API and Helpers.</li> <li>Functional Tests. Used to verify the libtropic core API using both the Libtropic API and Helpers.</li> <li>L3 Layer API. Functions called by the Libtropic Public API during encrypted communication. Because the L3 Layer requires cryptographic functionality (for example, to decrypt incoming L3 Result packets from TROPIC01), it uses a Crypto Abstraction Layer (CAL) to obtain functionality provided by a Cryptographic Functionality Provider (CFP). A CFP can be a cryptographic library (e.g. MbedTLS) or a cryptographic hardware accelerator. The CAL is declared in headers inside <code>src/</code> and specific CAL implementations for each CFP exist in <code>cal/</code>. It is assumed that only one CAL implementation is used for a given libtropic build.</li> <li>L2 Layer API. Functions called by the Libtropic Public API during Unencrypted Communication.</li> <li>L1 Layer API. Functions called by the L2 Layer API that wrap port-specific L1 Layer functions implemented by the Hardware Abstraction Layers (HAL) in <code>hal/</code>. These HALs are initialized using the Libtropic Public API. The library can be compiled with support for only one HAL at a time, but a single HAL may support communication with multiple chips.</li> </ol> <p>More Information About Libtropic Functions</p> <p>For more information about Libtropic functions, refer to the API Reference.</p>"},{"location":"get_started/logging/","title":"Logging","text":"<p>Libtropic contains a logging functionality, which is disabled by default (unless you compile tests or examples).</p> <p>You may find it useful to enable logging during libtropic evaluation or integration. There are five logging levels:</p> <ul> <li>None (default unless compiling tests or examples),</li> <li>Error,</li> <li>Warning,</li> <li>Info,</li> <li>Debug.</li> </ul> <p>One of these logging levels can be switched on using the LT_LOG_LVL CMake option (refer to How to Configure section for ways to set it).</p>"},{"location":"get_started/logging/#how-to-log","title":"How to Log","text":"<p>Logging can be done using logging macros, which are defined in <code>include/libtropic_logging.h</code>. Following logging macros are available:</p> <ul> <li><code>LT_LOG_INFO</code>,</li> <li><code>LT_LOG_WARN</code>,</li> <li><code>LT_LOG_ERROR</code>,</li> <li><code>LT_LOG_DEBUG</code>.</li> </ul> <p>Each macro corresponds to a verbosity level, which is activated with the aforementioned CMake switch. Macros have the same interface as the <code>printf</code> function, as they are essentially a wrapper over <code>printf</code>.</p> <p>Function Calls as LT_LOG_* Arguments</p> <p>Avoid passing function calls as macro arguments (except for simple formatting helpers like <code>lt_ret_verbose</code> or <code>strerror</code>). Logging macros may be completely removed at lower verbosity levels, meaning any function calls inside them will not execute.</p> <p>This is safe (using <code>lt_ret_verbose()</code> helper function only):</p> <pre><code>LT_LOG_INFO(\"Error code: %d, error string: %s\", ret, lt_ret_verbose(ret));\n</code></pre> <p>This is unsafe \u2014 <code>lt_init()</code> will never run if logging is disabled:</p> <pre><code>LT_LOG_INFO(\"Initializing handle: %d\", lt_init(&amp;h));\n</code></pre> <p>Correct approach \u2014 call the function first, then log its result:</p> <pre><code>int ret = lt_init(&amp;h);\nLT_LOG_INFO(\"Initializing handle: %d\", ret);\n</code></pre> <p>Other Macros</p> <p>There are also macros used for assertion. These are used in Functional Tests.</p>"},{"location":"get_started/tropic01_fw/","title":"TROPIC01 Firmware","text":"<p>TROPIC01 contains the following FW execution engines:</p> <ul> <li>RISC-V CPU,</li> <li>ECC engine or SPECT (these two terms are used interchangeably).</li> </ul> <p>There are multiple kinds of FW running in TROPIC01:</p> <ol> <li>Immutable FW (bootloader). Located in ROM, runs on RISC-V CPU from ROM after power-up, updates or boots the mutable FWs.</li> <li>RISC-V Mutable FW (CPU FW). Updatable, located in R-memory, runs on RISC-V CPU from RAM, processes L2/L3 communication.</li> <li>ECC engine mutable FW (ECC engine FW or SPECT FW). Updatable, located in R-memory, runs on ECC engine from RAM, helps the RISC-V CPU FW with processing ECC commands (ECC_Key_*, ECDSA/EDDSA_Sign).</li> </ol> <p>More Information About TROPIC01 Firmware</p> <p>For more detailed information about each FW, refer to the FW Update Application Note.</p>"},{"location":"get_started/tropic01_fw/#tropic01-firmware-in-libtropic","title":"TROPIC01 Firmware in Libtropic","text":"<p>Libtropic provides not only implementation of the FW update L2 commands, but also the necessary files for updating both the RISC-V and SPECT FW. Refer to:</p> <ol> <li>Firmware Update Files section for more information about the <code>TROPIC01_fw_update_files/</code> directory.</li> <li>lt_ex_fw_update.c section (in the Irreversible Examples documentation page) for a practical example, showing how to update TROPIC01's FW using Libtropic.</li> </ol>"},{"location":"get_started/tropic01_fw/#firmware-update-files","title":"Firmware Update Files","text":"<p>The <code>TROPIC01_fw_update_files/</code> directory provides TROPIC01 FW update files in two formats:</p> <ol> <li>C header files (<code>*.h</code>). These are designed to be included and compiled directly into the Host MCU's firmware/application. See Compiling into Libtropic section for more information.</li> <li>Binary files (<code>*.bin</code>). These can be stored in the Host MCU's filesystem or external storage, loaded at runtime and used to update TROPIC01's FW.</li> </ol> <p>The general structure of the <code>TROPIC01_fw_update_files/</code> directory is the following: <pre><code>TROPIC01_fw_update_files/\n\u251c\u2500\u2500 boot_v_&lt;X_Y_Z&gt;/\n\u2502   \u2514\u2500\u2500 fw_v_&lt;A_B_C&gt;/\n\u2502       \u251c\u2500\u2500 fw_CPU.h\n\u2502       \u251c\u2500\u2500 fw_SPECT.h\n\u2502       \u251c\u2500\u2500 fw_v&lt;A_B_C&gt;.hex32_signed_chunks.bin\n\u2502       \u2514\u2500\u2500 spect_app-v&lt;D_E_F&gt;_signed_chunks.bin\n\u2514\u2500\u2500 convert.py\n</code></pre></p> <ul> <li><code>boot_v_&lt;X_Y_Z&gt;/</code>: directories of available FW update files for a given bootloader version <code>&lt;X_Y_Z&gt;</code>.</li> <li><code>fw_v_&lt;A_B_C&gt;/</code>: directory with RISC-V CPU and SPECT FW update files (in both formats) for a given FW version <code>&lt;A_B_C&gt;</code>. Note that the RISC-V CPU FW and SPECT FW versions can be different.</li> <li><code>convert.py</code>: Python script for converting firmware binary files into C header files.</li> </ul>"},{"location":"get_started/tropic01_fw/#compiling-into-libtropic","title":"Compiling into Libtropic","text":"<p>To select which FW version will be compiled together with Libtropic, the user has to set the following CMake variables (both have a default value):</p> <ul> <li>LT_SILICON_REV,</li> <li>LT_CPU_FW_UPDATE_DATA_VER.</li> </ul>"},{"location":"get_started/tropic01_fw/#firmware-hashes","title":"Firmware Hashes","text":"<p>TROPIC01 is able to report hashes of the firmware it is loaded with. Using Libtropic, you can get the value using <code>lt_get_info_fw_bank</code> function.</p> <p>However, for certain old firmware versions, the reported hashes will not match with the hashes found in the public firmware repositories. The reason is that before publication, we cleaned up the git histories. Although the code was not changed, git hashes were affected. Affected version are:</p> <ul> <li>RISC-V CPU FW: versions older than and including v1.0.1.</li> <li>SPECT FW: versions older than and including v1.0.0.</li> </ul> <p>If you want to verify that production binaries match the source code, you can compile the source code and then compare the resulting binary to production binaries provided in the Libtropic repository.</p>"},{"location":"get_started/examples/","title":"Examples","text":"<p>The <code>examples/</code> directory contains multiple examples demonstrating how to use libtropic. Make sure to read this page before diving into the examples.</p>"},{"location":"get_started/examples/#example-categories","title":"Example Categories","text":"<p>Some examples may cause irreversible changes to the chip, so they are organized into two categories:</p> <ul> <li>Reversible Examples</li> <li>Irreversible Examples</li> </ul> <p>What are Irreversible Changes?</p> <p>Irreversible changes include writing to I-config, writing or invalidating pairing keys, or performing a firmware update.</p>"},{"location":"get_started/examples/#building","title":"Building","text":"<p>Examples can be compiled using the LT_BUILD_EXAMPLES CMake option. See How to Configure section for ways to enable this option.</p> <p>We recommend trying the examples in one of our platform repositories using a real TROPIC01 chip on one of our supported platforms, or on a TROPIC01 model directly on your computer. Both the platform repositories and the model contain detailed guides on compiling examples.</p> <p>Cannot Establish a Secure Channel Session</p> <p>Refer to the dedicated section in the FAQ.</p> Advanced Tip: Running an Example With Your Own Pairing Key <p>If you have already written your own public key to one of the available slots and want to execute an example that uses a Secure Session, define the arrays for your private and public key as globals and, after <code>#include \"libtropic_examples.h\"</code>, do the following: <pre><code>#undef LT_EX_SH0_PRIV\n#define LT_EX_SH0_PRIV &lt;var_name_with_your_private_pairing_key&gt;\n\n#undef LT_EX_SH0_PUB\n#define LT_EX_SH0_PUB &lt;var_name_with_your_public_pairing_key&gt;\n</code></pre></p>"},{"location":"get_started/examples/#should-i-use-the-model-or-a-real-chip","title":"Should I Use the Model or a Real Chip?","text":"<p>All of the examples are compatible with the TROPIC01 chip, and the majority of them are also compatible with the TROPIC01 model. It is highly recommended to try the model first, especially for irreversible examples, as they make irreversible changes to the real chip.</p> <p>Some examples are not compatible with the model (such as the firmware update example). Any such incompatibility is always noted in the example description in this documentation.</p>"},{"location":"get_started/examples/#where-do-i-start","title":"Where Do I Start?","text":"<p>We recommend starting with Reversible Examples, specifically <code>lt_ex_hello_world.c</code>. This example demonstrates the usage of basic libtropic API functions. After understanding this example, you can dive into more complex ones.</p>"},{"location":"get_started/examples/irreversible_examples/","title":"Irreversible Examples","text":"<p>To provide better orientation, we highlight specific properties of each example, namely:</p> <ul> <li>Reversibility,</li> <li>Model compatibility,</li> <li>Level of complexity (\ud83d\udc23 -&gt; \ud83d\udc24 -&gt; \ud83d\udc13).</li> </ul> <p>The source code for the examples can be found in the <code>examples/</code> directory and also within this document inside \"Source Code\" boxes.</p> <p>Tip</p> <p>You can copy the example code using the  icon located in the top-right corner of each source code listing.</p>"},{"location":"get_started/examples/irreversible_examples/#lt_ex_hw_walletc","title":"lt_ex_hw_wallet.c","text":"<ul> <li>\u26a0\ufe0f Irreversible</li> <li>\u2705 Compatible with the model</li> <li>\ud83d\udc13 Level: Advanced</li> </ul> <p>This example demonstrates how to use configuration objects and different pairing keys to manage access to TROPIC01 features. A hardware wallet device scenario is used as a model for this example.</p> <p>In this example, you will:</p> <ul> <li>Understand how the R-config is structured and how permissions are managed using the R-config.</li> <li> <p>Learn how the R-config can be modified using the libtropic API:</p> <ul> <li><code>lt_r_config_erase()</code>: L3 command to erase the R-config.</li> <li><code>lt_write_whole_R_config()</code>: helper function to write the whole R-config with an instance of <code>struct lt_config_t</code>.</li> <li> <p><code>lt_read_whole_R_config()</code>: helper function to read the whole R-config into an instance of <code>struct lt_config_t</code>.</p> <p>Tip: Modifying Only One R-Config Register</p> <p>If you need to modify only one register in the R-config, you can use <code>lt_r_config_write()</code> or <code>lt_r_config_read()</code>.</p> </li> </ul> </li> <li> <p>Learn how to manage pairing keys:</p> <ul> <li><code>lt_pairing_key_write()</code>: L3 command to write a pairing key.</li> <li><code>lt_pairing_key_invalidate()</code>: L3 command to invalidate a pairing key.</li> </ul> </li> <li>Learn how to work with keys based on elliptic curves (ECC) on TROPIC01:<ul> <li><code>lt_ecc_key_store()</code>: L3 command to store an ECC key.</li> <li><code>lt_ecc_key_read()</code>: L3 command to read an ECC key.</li> <li><code>lt_ecc_key_generate()</code>: L3 command to generate an ECC key.</li> </ul> </li> <li>Learn how to use EDDSA to sign messages and verify signatures.</li> <li>Learn how to use a monotonic counter.</li> </ul> Source code <pre><code>/**\n * @file lt_ex_hw_wallet.c\n * @brief Example usage of TROPIC01 chip in a generic *hardware wallet* project.\n * @copyright Copyright (c) 2020-2025 Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include &lt;inttypes.h&gt;\n\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_examples.h\"\n#include \"libtropic_logging.h\"\n#include \"string.h\"\n\n/** @brief Message to send with Ping L3 command. */\n#define PING_MSG \"Ping message for TROPIC01\"\n/** @brief Size of the Ping message, including '\\0'. */\n#define PING_MSG_SIZE 26\n\n/** @brief Attestation key for ECC slot 0. */\nuint8_t attestation_key[TR01_CURVE_PRIVKEY_LEN]\n    = {0x22, 0x57, 0xa8, 0x2f, 0x85, 0x8f, 0x13, 0x32, 0xfa, 0x0f, 0xf6, 0x0c, 0x76, 0x29, 0x42, 0x70,\n       0xa9, 0x58, 0x9d, 0xfd, 0x47, 0xa5, 0x23, 0x78, 0x18, 0x4d, 0x2d, 0x38, 0xf0, 0xa7, 0xc4, 0x01};\n\n/** @brief X25519 private key to execute a Secure Channel Handshake on Pairing Key slot 1. */\nconst uint8_t sh1priv[]\n    = {0x58, 0xc4, 0x81, 0x88, 0xf8, 0xb1, 0xcb, 0xd4, 0x19, 0x00, 0x2e, 0x9c, 0x8d, 0xf8, 0xce, 0xea,\n       0xf3, 0xa9, 0x11, 0xde, 0xb6, 0x6b, 0xc8, 0x87, 0xae, 0xe7, 0x88, 0x10, 0xfb, 0x48, 0xb6, 0x74};\n\n/** @brief X25519 public key to execute a Secure Channel Handshake on Pairing Key slot 1. */\nconst uint8_t sh1pub[]\n    = {0xe1, 0xdc, 0xf9, 0xc3, 0x46, 0xbc, 0xf2, 0xe7, 0x8b, 0xa8, 0xf0, 0x27, 0xd8, 0x0a, 0x8a, 0x33,\n       0xcc, 0xf3, 0xe9, 0xdf, 0x6b, 0xdf, 0x65, 0xa2, 0xc1, 0xae, 0xc4, 0xd9, 0x21, 0xe1, 0x8d, 0x51};\n\n/** @brief X25519 private key to execute a Secure Channel Handshake on Pairing Key slot 2. */\nconst uint8_t sh2priv[]\n    = {0x00, 0x40, 0x5e, 0x19, 0x46, 0x75, 0xab, 0xe1, 0x5f, 0x0b, 0x57, 0xf2, 0x5b, 0x12, 0x86, 0x62,\n       0xab, 0xb0, 0xe9, 0xc6, 0xa7, 0xc3, 0xca, 0xdf, 0x1c, 0xb1, 0xd2, 0xb7, 0xf8, 0xcf, 0x35, 0x47};\n\n/** @brief X25519 public key to execute a Secure Channel Handshake on Pairing Key slot 2. */\nconst uint8_t sh2pub[]\n    = {0x66, 0xb9, 0x92, 0x5a, 0x85, 0x66, 0xe8, 0x09, 0x5c, 0x56, 0x80, 0xfb, 0x22, 0xd4, 0xb8, 0x4b,\n       0xf8, 0xe3, 0x12, 0xb2, 0x7c, 0x4b, 0xac, 0xce, 0x26, 0x3c, 0x78, 0x39, 0x6d, 0x4c, 0x16, 0x6c};\n\n/** @brief X25519 private key to execute a Secure Channel Handshake on Pairing Key slot 3. */\nconst uint8_t sh3priv[]\n    = {0xb0, 0x90, 0x9f, 0xe1, 0xf3, 0x1f, 0xa1, 0x21, 0x75, 0xef, 0x45, 0xb1, 0x42, 0xde, 0x0e, 0xdd,\n       0xa1, 0xf4, 0x51, 0x01, 0x40, 0xc2, 0xe5, 0x2c, 0xf4, 0x68, 0xac, 0x96, 0xa1, 0x0e, 0xcb, 0x46};\n\n/** @brief X25519 public key to execute a Secure Channel Handshake on Pairing Key slot 3. */\nconst uint8_t sh3pub[]\n    = {0x22, 0x57, 0xa8, 0x2f, 0x85, 0x8f, 0x13, 0x32, 0xfa, 0x0f, 0xf6, 0x0c, 0x76, 0x29, 0x42, 0x70,\n       0xa9, 0x58, 0x9d, 0xfd, 0x47, 0xa5, 0x23, 0x78, 0x18, 0x4d, 0x2d, 0x38, 0xf0, 0xa7, 0xc4, 0x01};\n\n/**\n * @brief Creates an HW wallet example config from the virgin R config.\n *\n * @param r_config R config to modify\n */\nstatic void create_example_r_config(struct lt_config_t *r_config)\n{\n    //-------CFG_START_UP------------------------------------\n    // Enable MBIST and RNGTEST (DIS in their names stands for disable, so writing 0 enables them)\n    r_config-&gt;obj[TR01_CFG_START_UP_IDX]\n        &amp;= ~(BOOTLOADER_CO_CFG_START_UP_MBIST_DIS_MASK | BOOTLOADER_CO_CFG_START_UP_RNGTEST_DIS_MASK);\n\n    //-------CFG_SENSORS-------------------------------------\n    // Enable all sensors (DIS in their names stands for disable, so writing 0 enables them)\n    r_config-&gt;obj[TR01_CFG_SENSORS_IDX] &amp;= ~(\n        BOOTLOADER_CO_CFG_SENSORS_PTRNG0_TEST_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_PTRNG1_TEST_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_OSCILLATOR_MON_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_SHIELD_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_VOLTAGE_MON_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_GLITCH_DET_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_TEMP_SENS_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_LASER_DET_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_EM_PULSE_DET_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_CPU_ALERT_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_PIN_VERIF_BIT_FLIP_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_SCB_BIT_FLIP_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_CPB_BIT_FLIP_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_ECC_BIT_FLIP_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_R_MEM_BIT_FLIP_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_EKDB_BIT_FLIP_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_I_MEM_BIT_FLIP_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_PLATFORM_BIT_FLIP_DIS_MASK);\n\n    //-------CFG_DEBUG---------------------------------------\n    // Disable FW logging\n    r_config-&gt;obj[TR01_CFG_DEBUG_IDX] &amp;= ~BOOTLOADER_CO_CFG_DEBUG_FW_LOG_EN_MASK;\n\n    //-------TR01_CFG_GPO-----------------------------------------\n    // Keep at reset value\n\n    //-------TR01_CFG_SLEEP_MODE----------------------------------\n    // Enable sleep mode\n    r_config-&gt;obj[TR01_CFG_SLEEP_MODE_IDX] |= APPLICATION_CO_CFG_SLEEP_MODE_SLEEP_MODE_EN_MASK;\n\n    //------- TR01_CFG_UAP_PAIRING_KEY_WRITE ---------------------\n    // Disable writing pairing keys for all slots\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_WRITE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH0(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_WRITE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH1(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_WRITE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH2(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_WRITE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH3(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_PAIRING_KEY_READ ----------------------\n    // All sessions can read pairing keys\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_READ_IDX] |= LT_TO_PAIRING_KEY_SH0(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_READ_IDX] |= LT_TO_PAIRING_KEY_SH1(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_READ_IDX] |= LT_TO_PAIRING_KEY_SH2(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_READ_IDX] |= LT_TO_PAIRING_KEY_SH3(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_PAIRING_KEY_INVALIDATE ----------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH0(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH1(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH2(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH3(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Pairing key SH0PUB can be invalidated only from session with SH0PUB\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] |= LT_TO_PAIRING_KEY_SH0(LT_SESSION_SH0_HAS_ACCESS);\n    // 3. Pairing keys SH1PUB, SH2PUB and SH3PUB can be invalidated only from session with SH3PUB\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] |= LT_TO_PAIRING_KEY_SH1(LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] |= LT_TO_PAIRING_KEY_SH2(LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] |= LT_TO_PAIRING_KEY_SH3(LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_R_CONFIG_WRITE_ERASE ------------------\n    // Keep at reset value, not used currently\n\n    //------- TR01_CFG_UAP_R_CONFIG_READ -------------------------\n    // Keep at reset value, not used currently\n\n    //------- TR01_CFG_UAP_I_CONFIG_WRITE ------------------------\n    // Keep at reset value, not used currently\n\n    //------- TR01_CFG_UAP_I_CONFIG_READ -------------------------\n    // Keep at reset value, not used currently\n\n    //------- TR01_CFG_UAP_PING ----------------------------------\n    // Enable for all pairing keys\n    r_config-&gt;obj[TR01_CFG_UAP_PING_IDX] |= (LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS\n                                             | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_R_MEM_DATA_WRITE ----------------------\n    // Reset value, not used currently\n\n    //------- TR01_CFG_UAP_R_MEM_DATA_READ -----------------------\n    // Reset value, not used currently\n\n    //------- TR01_CFG_UAP_R_MEM_DATA_ERASE ----------------------\n    // Reset value, not used currently\n\n    //------- TR01_CFG_UAP_RANDOM_VALUE_GET ----------------------\n    // Enable for all pairing keys\n    r_config-&gt;obj[TR01_CFG_UAP_RANDOM_VALUE_GET_IDX] |= (LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS\n                                                         | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_ECC_KEY_GENERATE ----------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_GENERATE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_0_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_GENERATE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_8_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_GENERATE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_16_23(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_GENERATE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_24_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Only session with SH3PUB can generate keys in slots 8-31\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_GENERATE_IDX]\n        |= (LT_TO_ECC_KEY_SLOT_8_15(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_ECC_KEY_SLOT_16_23(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_ECC_KEY_SLOT_24_31(LT_SESSION_SH3_HAS_ACCESS));\n\n    //------- TR01_CFG_UAP_ECC_KEY_STORE -------------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_STORE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_0_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_STORE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_8_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_STORE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_16_23(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_STORE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_24_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH1PUB can store key into ECC key slot 0-7\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_STORE_IDX] |= LT_TO_ECC_KEY_SLOT_0_7(LT_SESSION_SH1_HAS_ACCESS);\n    // 3. Session with SH3PUB can store key into ECC key slot 8-31\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_STORE_IDX] |= LT_TO_ECC_KEY_SLOT_8_15(LT_SESSION_SH3_HAS_ACCESS)\n                                                     | LT_TO_ECC_KEY_SLOT_16_23(LT_SESSION_SH3_HAS_ACCESS)\n                                                     | LT_TO_ECC_KEY_SLOT_24_31(LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_ECC_KEY_READ --------------------------\n    // Enable for all pairing keys\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_READ_IDX] |= LT_TO_ECC_KEY_SLOT_0_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_READ_IDX] |= LT_TO_ECC_KEY_SLOT_8_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_READ_IDX] |= LT_TO_ECC_KEY_SLOT_16_23(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_READ_IDX] |= LT_TO_ECC_KEY_SLOT_24_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_ECC_KEY_ERASE -------------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_ERASE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_0_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_ERASE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_8_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_ERASE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_16_23(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_ERASE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_24_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH1PUB can erase ECC key slots 0-7\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_ERASE_IDX] |= LT_TO_ECC_KEY_SLOT_0_7(LT_SESSION_SH1_HAS_ACCESS);\n    // 3. Session with SH3PUB can erase ECC key slots 8-31\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_ERASE_IDX] |= LT_TO_ECC_KEY_SLOT_8_15(LT_SESSION_SH3_HAS_ACCESS)\n                                                     | LT_TO_ECC_KEY_SLOT_16_23(LT_SESSION_SH3_HAS_ACCESS)\n                                                     | LT_TO_ECC_KEY_SLOT_24_31(LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_ECDSA_SIGN ----------------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_ECDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_0_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_8_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_16_23(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_24_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH3PUB can sign with all ECC key slots\n    r_config-&gt;obj[TR01_CFG_UAP_ECDSA_SIGN_IDX]\n        |= (LT_TO_ECC_KEY_SLOT_0_7(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_ECC_KEY_SLOT_8_15(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_ECC_KEY_SLOT_16_23(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_ECC_KEY_SLOT_24_31(LT_SESSION_SH3_HAS_ACCESS));\n\n    //------- TR01_CFG_UAP_EDDSA_SIGN ----------------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_EDDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_0_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_EDDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_8_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_EDDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_16_23(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_EDDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_24_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH3PUB can sign with all ECC key slots\n    r_config-&gt;obj[TR01_CFG_UAP_EDDSA_SIGN_IDX]\n        |= (LT_TO_ECC_KEY_SLOT_0_7(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_ECC_KEY_SLOT_8_15(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_ECC_KEY_SLOT_16_23(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_ECC_KEY_SLOT_24_31(LT_SESSION_SH3_HAS_ACCESS));\n\n    //------- TR01_CFG_UAP_MCOUNTER_INIT -------------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_INIT_IDX] &amp;= ~LT_TO_MCOUNTER_0_3(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_INIT_IDX] &amp;= ~LT_TO_MCOUNTER_4_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_INIT_IDX] &amp;= ~LT_TO_MCOUNTER_8_11(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_INIT_IDX] &amp;= ~LT_TO_MCOUNTER_12_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH3PUB can init all mcounters\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_INIT_IDX]\n        |= (LT_TO_MCOUNTER_0_3(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_MCOUNTER_4_7(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_MCOUNTER_8_11(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_MCOUNTER_12_15(LT_SESSION_SH3_HAS_ACCESS));\n\n    //------- TR01_CFG_UAP_MCOUNTER_GET --------------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_GET_IDX] &amp;= ~LT_TO_MCOUNTER_0_3(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_GET_IDX] &amp;= ~LT_TO_MCOUNTER_4_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_GET_IDX] &amp;= ~LT_TO_MCOUNTER_8_11(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_GET_IDX] &amp;= ~LT_TO_MCOUNTER_12_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH3PUB can get all mcounters\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_GET_IDX]\n        |= (LT_TO_MCOUNTER_0_3(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_MCOUNTER_4_7(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_MCOUNTER_8_11(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_MCOUNTER_12_15(LT_SESSION_SH3_HAS_ACCESS));\n\n    //------- TR01_CFG_UAP_MCOUNTER_UPDATE -----------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_UPDATE_IDX] &amp;= ~LT_TO_MCOUNTER_0_3(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_UPDATE_IDX] &amp;= ~LT_TO_MCOUNTER_4_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_UPDATE_IDX] &amp;= ~LT_TO_MCOUNTER_8_11(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_UPDATE_IDX] &amp;= ~LT_TO_MCOUNTER_12_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH3PUB can update all mcounters\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_UPDATE_IDX]\n        |= (LT_TO_MCOUNTER_0_3(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_MCOUNTER_4_7(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_MCOUNTER_8_11(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_MCOUNTER_12_15(LT_SESSION_SH3_HAS_ACCESS));\n\n    //------- TR01_CFG_UAP_MAC_AND_DESTROY_ADDR -----------------------\n    // Enable for all pairing key slots\n    r_config-&gt;obj[TR01_CFG_UAP_MAC_AND_DESTROY_IDX] |= LT_TO_MACANDD_SLOT_0_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MAC_AND_DESTROY_IDX] |= LT_TO_MACANDD_SLOT_32_63(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MAC_AND_DESTROY_IDX] |= LT_TO_MACANDD_SLOT_64_95(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MAC_AND_DESTROY_IDX] |= LT_TO_MACANDD_SLOT_96_127(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n}\n\n/**\n * @brief Initial session, when chip is powered for the first time during manufacturing.\n *        This function writes chip's configuration into R config.\n *\n * @param h  Handle for communication with TROPIC01\n * @return   0 if success, -1 otherwise\n */\nstatic int session_initial(lt_handle_t *h)\n{\n    lt_ret_t ret;\n    struct lt_config_t r_config;\n    const uint8_t *pub_keys[] = {LT_EX_SH0_PUB, sh1pub, sh2pub, sh3pub};\n\n    LT_LOG_INFO(\"Initializing handle\");\n    // Note: It is assumed that the `h.l2.device` and `h.l3.crypto_ctx` members were already\n    // initialized. Because these members are pointers, the assigned structures must exist throughout the whole\n    // life-cycle of the handle. Refer to the 'Get Started'-&gt;'Integrating Libtropic'-&gt;'How to Use' Section in the\n    // Libtropic documentation for more information.\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_verify_chip_and_start_secure_session(h, LT_EX_SH0_PRIV, LT_EX_SH0_PUB, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to start Secure Session with key %d, ret=%s\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0,\n                     lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Reading the whole R config:\");\n    ret = lt_read_whole_R_config(h, &amp;r_config);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to read R config, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    for (int i = 0; i &lt; LT_CONFIG_OBJ_CNT; i++) {\n        LT_LOG_INFO(\"%s: 0x%08\" PRIx32, cfg_desc_table[i].desc, r_config.obj[i]);\n    }\n\n    LT_LOG_INFO(\"Creating an example config from the read R config...\");\n    create_example_r_config(&amp;r_config);\n\n    LT_LOG_INFO(\"Erasing R config in case it is already written...\");\n    ret = lt_r_config_erase(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to erase R config, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Writing the whole R config with the example config...\");\n    ret = lt_write_whole_R_config(h, &amp;r_config);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to write R config, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Reading the whole R config again:\");\n    ret = lt_read_whole_R_config(h, &amp;r_config);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to read R config, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    for (int i = 0; i &lt; LT_CONFIG_OBJ_CNT; i++) {\n        LT_LOG_INFO(\"%s: 0x%08\" PRIx32, cfg_desc_table[i].desc, r_config.obj[i]);\n    }\n\n    // Write pairing keys into slots 1,2,3\n    for (uint8_t i = TR01_PAIRING_KEY_SLOT_INDEX_1; i &lt;= TR01_PAIRING_KEY_SLOT_INDEX_3; i++) {\n        LT_LOG_INFO(\"Writing to pairing key slot %\" PRIu8 \"...\", i);\n        ret = lt_pairing_key_write(h, pub_keys[i], i);\n        if (LT_OK != ret) {\n            LT_LOG_ERROR(\"Failed to write pairing key, ret=%s\", lt_ret_verbose(ret));\n            return -1;\n        }\n        LT_LOG_INFO(\"\\tOK\");\n    }\n\n    LT_LOG_INFO(\"Invalidating pairing key slot %d...\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_pairing_key_invalidate(h, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to invalidate pairing key slot, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Rebooting TROPIC01 to apply changes...\");\n    ret = lt_reboot(h, TR01_REBOOT);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to reboot, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * @brief Session with pairing key slot 0\n *\n * @param h  Handle for communication with TROPIC01\n * @return   0 if success, -1 otherwise\n */\nstatic int session0(lt_handle_t *h)\n{\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    // Note: It is assumed that the `h.l2.device` and `h.l3.crypto_ctx` members were already\n    // initialized. Because these members are pointers, the assigned structures must exist throughout the whole\n    // life-cycle of the handle. Refer to the 'Get Started'-&gt;'Integrating Libtropic'-&gt;'How to Use' Section in the\n    // Libtropic documentation for more information.\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d (should fail)\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_verify_chip_and_start_secure_session(h, LT_EX_SH0_PRIV, LT_EX_SH0_PUB, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_L2_HSK_ERR != ret) {\n        LT_LOG_ERROR(\"Return value is not LT_L2_HSK_ERR, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * @brief Session with pairing key slot 1\n *\n * @param h  Handle for communication with TROPIC01\n * @return   0 if success, -1 otherwise\n */\nstatic int session1(lt_handle_t *h)\n{\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    // Note: It is assumed that the `h.l2.device` and `h.l3.crypto_ctx` members were already\n    // initialized. Because these members are pointers, the assigned structures must exist throughout the whole\n    // life-cycle of the handle. Refer to the 'Get Started'-&gt;'Integrating Libtropic'-&gt;'How to Use' Section in the\n    // Libtropic documentation for more information.\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_1);\n    ret = lt_verify_chip_and_start_secure_session(h, sh1priv, sh1pub, TR01_PAIRING_KEY_SLOT_INDEX_1);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to start Secure Session with key %d, ret=%s\", (int)TR01_PAIRING_KEY_SLOT_INDEX_1,\n                     lt_ret_verbose(ret));\n        return -1;\n    }\n\n    uint8_t recv_buf[PING_MSG_SIZE];\n    LT_LOG_INFO(\"Sending Ping command with message:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", PING_MSG);\n    ret = lt_ping(h, (const uint8_t *)PING_MSG, recv_buf, PING_MSG_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Ping command failed, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Message received from TROPIC01:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", recv_buf);\n\n    LT_LOG_INFO(\"Storing attestation key into ECC slot %d...\", (int)TR01_ECC_SLOT_0);\n    ret = lt_ecc_key_store(h, TR01_ECC_SLOT_0, TR01_CURVE_ED25519, attestation_key);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to store ECC key to slot %d, ret=%s\", (int)TR01_ECC_SLOT_0, lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    uint8_t dummy_key[TR01_SHIPUB_LEN] = {0};\n    LT_LOG_INFO(\"Writing all pairing key slots (should fail):\");\n    for (uint8_t i = TR01_PAIRING_KEY_SLOT_INDEX_0; i &lt;= TR01_PAIRING_KEY_SLOT_INDEX_3; i++) {\n        LT_LOG_INFO(\"\\tWriting pairing key slot %\" PRIu8 \"...\", i);\n        ret = lt_pairing_key_write(h, dummy_key, i);\n        if (LT_L3_UNAUTHORIZED != ret) {\n            LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n            return -1;\n        }\n        LT_LOG_INFO(\"\\t\\tOK\");\n    }\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * @brief Session with pairing key slot 2\n *\n * @param h  Handle for communication with TROPIC01\n * @return   0 if success, -1 otherwise\n */\nstatic int session2(lt_handle_t *h)\n{\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    // Note: It is assumed that the `h.l2.device` and `h.l3.crypto_ctx` members were already\n    // initialized. Because these members are pointers, the assigned structures must exist throughout the whole\n    // life-cycle of the handle. Refer to the 'Get Started'-&gt;'Integrating Libtropic'-&gt;'How to Use' Section in the\n    // Libtropic documentation for more information.\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_2);\n    ret = lt_verify_chip_and_start_secure_session(h, sh2priv, sh2pub, TR01_PAIRING_KEY_SLOT_INDEX_2);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to start Secure Session with key %d, ret=%s\", (int)TR01_PAIRING_KEY_SLOT_INDEX_2,\n                     lt_ret_verbose(ret));\n        return -1;\n    }\n\n    uint8_t recv_buf[PING_MSG_SIZE];\n    LT_LOG_INFO(\"Sending Ping command with message:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", PING_MSG);\n    ret = lt_ping(h, (const uint8_t *)PING_MSG, recv_buf, PING_MSG_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Ping command failed, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Message received from TROPIC01:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", recv_buf);\n\n    uint8_t dummy_key[TR01_CURVE_PRIVKEY_LEN] = {0};\n    LT_LOG_INFO(\"Trying to store key into ECC slot %d (should fail)\", (int)TR01_ECC_SLOT_0);\n    ret = lt_ecc_key_store(h, TR01_ECC_SLOT_0, TR01_CURVE_ED25519, dummy_key);\n    if (LT_L3_UNAUTHORIZED != ret) {\n        LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Writing all pairing key slots (should fail):\");\n    for (uint8_t i = TR01_PAIRING_KEY_SLOT_INDEX_0; i &lt;= TR01_PAIRING_KEY_SLOT_INDEX_3; i++) {\n        LT_LOG_INFO(\"\\tWriting pairing key slot %\" PRIu8 \"...\", i);\n        ret = lt_pairing_key_write(h, dummy_key, i);\n        if (LT_L3_UNAUTHORIZED != ret) {\n            LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n            return -1;\n        }\n        LT_LOG_INFO(\"\\t\\tOK\");\n    }\n\n    uint32_t mcounter_value = 0x000000ff;\n    LT_LOG_INFO(\"Initializing mcounter 0 (should fail)...\");\n    ret = lt_mcounter_init(h, TR01_MCOUNTER_INDEX_0, mcounter_value);\n    if (LT_L3_UNAUTHORIZED != ret) {\n        LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Updating mcounter 0 (should fail)...\");\n    ret = lt_mcounter_update(h, TR01_MCOUNTER_INDEX_0);\n    if (LT_L3_UNAUTHORIZED != ret) {\n        LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Getting mcounter 0 (should fail)...\");\n    ret = lt_mcounter_get(h, TR01_MCOUNTER_INDEX_0, &amp;mcounter_value);\n    if (LT_L3_UNAUTHORIZED != ret) {\n        LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * @brief Session with pairing key slot 3\n *\n * @param h  Handle for communication with TROPIC01\n * @return   0 if success, -1 otherwise\n */\nstatic int session3(lt_handle_t *h)\n{\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    // Note: It is assumed that the `h.l2.device` and `h.l3.crypto_ctx` members were already\n    // initialized. Because these members are pointers, the assigned structures must exist throughout the whole\n    // life-cycle of the handle. Refer to the 'Get Started'-&gt;'Integrating Libtropic'-&gt;'How to Use' Section in the\n    // Libtropic documentation for more information.\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_3);\n    ret = lt_verify_chip_and_start_secure_session(h, sh3priv, sh3pub, TR01_PAIRING_KEY_SLOT_INDEX_3);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to start Secure Session with key %d, ret=%s\", (int)TR01_PAIRING_KEY_SLOT_INDEX_3,\n                     lt_ret_verbose(ret));\n        return -1;\n    }\n\n    uint8_t recv_buf[PING_MSG_SIZE];\n    LT_LOG_INFO(\"Sending Ping command with message:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", PING_MSG);\n    ret = lt_ping(h, (const uint8_t *)PING_MSG, recv_buf, PING_MSG_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Ping command failed, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Message received from TROPIC01:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", recv_buf);\n\n    LT_LOG_INFO(\"Signing with attestation key which was updated through pairing key slot 1\");\n    uint8_t msg[] = {'a', 'h', 'o', 'j'};\n    uint8_t rs[TR01_ECDSA_EDDSA_SIGNATURE_LENGTH];\n    ret = lt_ecc_eddsa_sign(h, TR01_ECC_SLOT_0, msg, sizeof(msg), rs);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to sign, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Reading ECC key slot %d...\", (int)TR01_ECC_SLOT_0);\n    uint8_t ed25519_pubkey[TR01_CURVE_ED25519_PUBKEY_LEN];\n    lt_ecc_curve_type_t curve;\n    lt_ecc_key_origin_t origin;\n    ret = lt_ecc_key_read(h, TR01_ECC_SLOT_0, ed25519_pubkey, sizeof(ed25519_pubkey), &amp;curve, &amp;origin);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to read ECC slot, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // Here you should verify the signature, for example using functions\n    // from your crypto library.\n    LT_LOG_INFO(\"Suggestion: Verify the signature here!\");\n\n    LT_LOG_INFO(\"Generating ECC key in slot %d...\", (int)TR01_ECC_SLOT_8);\n    ret = lt_ecc_key_generate(h, TR01_ECC_SLOT_8, TR01_CURVE_ED25519);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to generate ECC key, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Generating ECC key in slot %d...\", (int)TR01_ECC_SLOT_16);\n    ret = lt_ecc_key_generate(h, TR01_ECC_SLOT_16, TR01_CURVE_ED25519);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to generate ECC key, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Generating ECC key in slot %d...\", (int)TR01_ECC_SLOT_24);\n    ret = lt_ecc_key_generate(h, TR01_ECC_SLOT_24, TR01_CURVE_ED25519);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to generate ECC key, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Getting %d random bytes...\", (int)TR01_RANDOM_VALUE_GET_LEN_MAX);\n    uint8_t buff[TR01_RANDOM_VALUE_GET_LEN_MAX];\n    ret = lt_random_value_get(h, buff, TR01_RANDOM_VALUE_GET_LEN_MAX);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to get random bytes, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    uint32_t mcounter_value = 0x000000ff;\n    LT_LOG_INFO(\"Initializing mcounter 0...\");\n    ret = lt_mcounter_init(h, TR01_MCOUNTER_INDEX_0, mcounter_value);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize mcounter, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Updating mcounter 0...\");\n    ret = lt_mcounter_update(h, TR01_MCOUNTER_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to update mcounter, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Getting mcounter 0...\");\n    ret = lt_mcounter_get(h, TR01_MCOUNTER_INDEX_0, &amp;mcounter_value);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to get mcounter, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    uint8_t dummy_key[TR01_CURVE_PRIVKEY_LEN] = {0};\n    LT_LOG_INFO(\"Trying to store key into ECC slot %d (should fail)\", (int)TR01_ECC_SLOT_0);\n    ret = lt_ecc_key_store(h, TR01_ECC_SLOT_0, TR01_CURVE_ED25519, dummy_key);\n    if (LT_L3_UNAUTHORIZED != ret) {\n        LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Writing all pairing key slots (should fail):\");\n    for (uint8_t i = TR01_PAIRING_KEY_SLOT_INDEX_0; i &lt;= TR01_PAIRING_KEY_SLOT_INDEX_3; i++) {\n        LT_LOG_INFO(\"\\tWriting pairing key slot %\" PRIu8 \"...\", i);\n        ret = lt_pairing_key_write(h, dummy_key, i);\n        if (LT_L3_UNAUTHORIZED != ret) {\n            LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n            return -1;\n        }\n        LT_LOG_INFO(\"\\t\\tOK\");\n    }\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n\nint lt_ex_hardware_wallet(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"==========================================\");\n    LT_LOG_INFO(\"==== TROPIC01 Hardware Wallet Example ====\");\n    LT_LOG_INFO(\"==========================================\");\n\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"Initial session with pairing key slot 0\");\n    if (session_initial(h) == -1) {\n        if (h-&gt;l3.session_status == LT_SECURE_SESSION_ON) lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Session with pairing key slot 0\");\n    if (session0(h) == -1) {\n        if (h-&gt;l3.session_status == LT_SECURE_SESSION_ON) lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Session with pairing key slot 1\");\n    if (session1(h) == -1) {\n        if (h-&gt;l3.session_status == LT_SECURE_SESSION_ON) lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Session with pairing key slot 2\");\n    if (session2(h) == -1) {\n        if (h-&gt;l3.session_status == LT_SECURE_SESSION_ON) lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Session with pairing key slot 3\");\n    if (session3(h) == -1) {\n        if (h-&gt;l3.session_status == LT_SECURE_SESSION_ON) lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"get_started/examples/irreversible_examples/#lt_ex_fw_updatec","title":"lt_ex_fw_update.c","text":"<ul> <li>\u26a0\ufe0f Irreversible</li> <li>\u274c Incompatible with the model</li> <li>\ud83d\udc24 Level: Moderate</li> </ul> <p>This example explains the firmware update process for both ABAB and ACAB silicon revisions. Use this example as a reference for integrating TROPIC01 firmware updates into your application. You will learn:</p> <ul> <li>How to read the current firmware versions.</li> <li>How to update the firmware using <code>lt_do_mutable_fw_update()</code>.</li> </ul> <p>TROPIC01 Firmware</p> <p>For more information about the firmware itself, refer to the TROPIC01 Firmware section.</p> <p>Firmware Update Precautions</p> <p>Use a stable power source and avoid disconnecting the TROPIC01 (devkit) or rebooting your host device (computer or microcontroller) during the update. Interrupting the firmware update can brick the device.</p> Source code <pre><code>/**\n * @file lt_ex_fw_update.c\n * @name Firmware update\n * @brief This code performs firmware update of TROPIC01 chip, works on both ABAB and ACAB silicon revisions.\n * @copyright Copyright (c) 2020-2025 Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include &lt;inttypes.h&gt;\n\n#include \"fw_CPU.h\"\n#include \"fw_SPECT.h\"\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_examples.h\"\n#include \"libtropic_logging.h\"\n#include \"string.h\"\n\nint lt_ex_fw_update(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"====================================\");\n    LT_LOG_INFO(\"==== TROPIC01 FW update Example ====\");\n    LT_LOG_INFO(\"====================================\");\n\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    // Note: It is assumed that the `h.l2.device` and `h.l3.crypto_ctx` members were already\n    // initialized. Because these members are pointers, the assigned structures must exist throughout the whole\n    // life-cycle of the handle. Refer to the 'Get Started'-&gt;'Integrating Libtropic'-&gt;'How to Use' Section in the\n    // Libtropic documentation for more information.\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    // The chip must be in Start-up Mode to be able to perform a firmware update.\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"1. Sending maintenance reboot request\");\n    ret = lt_reboot(h, TR01_MAINTENANCE_REBOOT);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"lt_reboot() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK\");\n\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"2. Updating TR01_FW_BANK_FW1 and TR01_FW_BANK_SPECT1\");\n    LT_LOG_INFO(\"2.1. Updating RISC-V FW\");\n    ret = lt_do_mutable_fw_update(h, fw_CPU, sizeof(fw_CPU), TR01_FW_BANK_FW1);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"RISC-V FW update failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK\");\n\n    LT_LOG_INFO();\n    LT_LOG_INFO(\"2.2. Updating SPECT FW\");\n    ret = lt_do_mutable_fw_update(h, fw_SPECT, sizeof(fw_SPECT), TR01_FW_BANK_SPECT1);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"SPECT FW update failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK\");\n\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"3. Updating TR01_FW_BANK_FW2 and TR01_FW_BANK_SPECT2\");\n    LT_LOG_INFO(\"3.1. Updating RISC-V FW\");\n    ret = lt_do_mutable_fw_update(h, fw_CPU, sizeof(fw_CPU), TR01_FW_BANK_FW2);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"RISC-V FW update failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK\");\n\n    LT_LOG_INFO();\n    LT_LOG_INFO(\"3.2. Updating SPECT FW\");\n    ret = lt_do_mutable_fw_update(h, fw_SPECT, sizeof(fw_SPECT), TR01_FW_BANK_SPECT2);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"SPECT FW update failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK\");\n\n    LT_LOG_LINE();\n    LT_LOG(\"Successfully updated all 4 FW banks:\");\n\n    ret = lt_print_fw_header(h, TR01_FW_BANK_FW1, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_FW1 header, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    ret = lt_print_fw_header(h, TR01_FW_BANK_FW2, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_FW2 header, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    ret = lt_print_fw_header(h, TR01_FW_BANK_SPECT1, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_SPECT1 header, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    ret = lt_print_fw_header(h, TR01_FW_BANK_SPECT2, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_SPECT2 header, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Sending reboot request\");\n    ret = lt_reboot(h, TR01_REBOOT);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"lt_reboot() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK, TROPIC01 is executing Application FW now\");\n\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"Reading RISC-V FW version\");\n    // This variable is reused on more places in this block to store different FW versions\n    uint8_t fw_ver[TR01_L2_GET_INFO_RISCV_FW_SIZE] = {0};\n    ret = lt_get_info_riscv_fw_ver(h, fw_ver);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to get RISC-V FW version, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK\");\n\n    LT_LOG_INFO(\"RISC-V FW version: %02\" PRIX8 \".%02\" PRIX8 \".%02\" PRIX8 \" (+ .%02\" PRIX8 \")\", fw_ver[3], fw_ver[2],\n                fw_ver[1], fw_ver[0]);\n\n    LT_LOG_INFO();\n    LT_LOG_INFO(\"Reading SPECT FW version\");\n    ret = lt_get_info_spect_fw_ver(h, fw_ver);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to get SPECT FW version, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK\");\n\n    LT_LOG_INFO(\"SPECT FW version: %02\" PRIX8 \".%02\" PRIX8 \".%02\" PRIX8 \" (+ .%02\" PRIX8 \")\", fw_ver[3], fw_ver[2],\n                fw_ver[1], fw_ver[0]);\n\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"get_started/examples/reversible_examples/","title":"Reversible Examples","text":"<p>To provide better orientation, we highlight specific properties of each example, namely:</p> <ul> <li>Reversibility,</li> <li>Model compatibility,</li> <li>Level of complexity (\ud83d\udc23 -&gt; \ud83d\udc24 -&gt; \ud83d\udc13).</li> </ul> <p>The source code for the examples can be found in the <code>examples/</code> directory and also within this document inside \"Source code\" boxes.</p> <p>Tip</p> <p>You can copy the example code using the  icon located in the top-right corner of each source code listing.</p>"},{"location":"get_started/examples/reversible_examples/#lt_ex_hello_worldc","title":"lt_ex_hello_world.c","text":"<ul> <li>\u2705 Reversible</li> <li>\u2705 Compatible with the model</li> <li>\ud83d\udc23 Level: Basic</li> </ul> <p>This example demonstrates the basic libtropic API and can be used to verify that the chip works correctly. In this example, you will learn about the following functions:</p> <ul> <li><code>lt_init()</code>: function used to initialize context for communication with the TROPIC01,</li> <li><code>lt_verify_chip_and_start_secure_session()</code>: helper function to start Secure Session and allow L3 communication,</li> <li><code>lt_ping()</code>: L3 command to verify communication with the TROPIC01,</li> <li><code>lt_session_abort()</code>: L3 command to abort Secure Session,</li> <li><code>lt_deinit()</code>: function used to deinitialize context.</li> </ul> Source code <pre><code>/**\n * @file lt_ex_hello_world.c\n * @brief Establishes Secure Session and executes Ping L3 command.\n * @copyright Copyright (c) 2020-2025 Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_examples.h\"\n#include \"libtropic_logging.h\"\n\n/** @brief Message to send with Ping L3 command. */\n#define PING_MSG \"This is Hello World message from TROPIC01!!\"\n/** @brief Size of the Ping message, including '\\0'. */\n#define PING_MSG_SIZE 44\n\nint lt_ex_hello_world(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"======================================\");\n    LT_LOG_INFO(\"==== TROPIC01 Hello World Example ====\");\n    LT_LOG_INFO(\"======================================\");\n\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    // Note: It is assumed that the `h.l2.device` and `h.l3.crypto_ctx` members were already\n    // initialized. Because these members are pointers, the assigned structures must exist throughout the whole\n    // life-cycle of the handle. Refer to the 'Get Started'-&gt;'Integrating Libtropic'-&gt;'How to Use' Section in the\n    // Libtropic documentation for more information.\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_verify_chip_and_start_secure_session(h, LT_EX_SH0_PRIV, LT_EX_SH0_PUB, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to start Secure Session with key %d, ret=%s\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0,\n                     lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    uint8_t recv_buf[PING_MSG_SIZE];\n    LT_LOG_INFO(\"Sending Ping command with message:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", PING_MSG);\n    ret = lt_ping(h, (const uint8_t *)PING_MSG, recv_buf, PING_MSG_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Ping command failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Message received from TROPIC01:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", recv_buf);\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"get_started/examples/reversible_examples/#lt_ex_show_chip_id_and_fwverc","title":"lt_ex_show_chip_id_and_fwver.c","text":"<ul> <li>\u2705 Reversible</li> <li>\u2705 Compatible with the model</li> <li>\ud83d\udc23 Level: Basic</li> </ul> <p>Demonstrates how to read and display the chip\u2019s unique ID and firmware version information (bootloader, application and SPECT firmware versions). You will learn about following functions:</p> <ul> <li><code>lt_reboot()</code>: L2 request to reboot to either application or maintenance mode,</li> <li><code>lt_get_info_riscv_fw_ver()</code>, <code>lt_get_info_spect_fw_ver()</code>: L2 requests to read CPU and SPECT firmware versions,</li> <li><code>lt_get_info_chip_id()</code>: L2 request to read chip identification (e.g., serial number),</li> </ul> Source code <pre><code>/**\n * @file lt_ex_show_chip_id_and_fwver.c\n * @name Show chip ID and firmware versions\n * @brief This example shows how to read TROPIC01's chip ID and firmware versions\n * @note We recommend reading TROPIC01's datasheet before diving into this example!\n * @copyright Copyright (c) 2020-2025 Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include &lt;inttypes.h&gt;\n\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_examples.h\"\n#include \"libtropic_logging.h\"\n#include \"string.h\"\n\nint lt_ex_show_chip_id_and_fwver(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"=============================================================\");\n    LT_LOG_INFO(\"==== TROPIC01 show chip ID and firmware versions example ====\");\n    LT_LOG_INFO(\"=============================================================\");\n\n    // This variable is reused on more places in this example to store different firmware versions\n    uint8_t fw_ver[TR01_L2_GET_INFO_RISCV_FW_SIZE] = {0};\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    // Note: It is assumed that the `h.l2.device` and `h.l3.crypto_ctx` members were already\n    // initialized. Because these members are pointers, the assigned structures must exist throughout the whole\n    // life-cycle of the handle. Refer to the 'Get Started'-&gt;'Integrating Libtropic'-&gt;'How to Use' Section in the\n    // Libtropic documentation for more information.\n    ret = lt_init(h);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    // First, we check versions of both updateable firmwares. To do that, we need TROPIC01 to **not** be in the Start-up\n    // Mode. If there are valid firmwares, TROPIC01 will begin to execute them automatically on boot.\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"Sending reboot request\");\n    ret = lt_reboot(h, TR01_REBOOT);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"lt_reboot() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK\");\n\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"Reading RISC-V FW version\");\n    ret = lt_get_info_riscv_fw_ver(h, fw_ver);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to get RISC-V FW version, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK\");\n\n    LT_LOG_INFO(\"RISC-V FW version: %02\" PRIX8 \".%02\" PRIX8 \".%02\" PRIX8 \" (+ .%02\" PRIX8 \")\", fw_ver[3], fw_ver[2],\n                fw_ver[1], fw_ver[0]);\n\n    LT_LOG_INFO();\n    LT_LOG_INFO(\"Reading SPECT FW version\");\n    ret = lt_get_info_spect_fw_ver(h, fw_ver);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to get SPECT FW version, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK\");\n\n    LT_LOG_INFO(\"SPECT FW version: %02\" PRIX8 \".%02\" PRIX8 \".%02\" PRIX8 \" (+ .%02\" PRIX8 \")\", fw_ver[3], fw_ver[2],\n                fw_ver[1], fw_ver[0]);\n\n    LT_LOG_LINE();\n    LT_LOG_INFO(\n        \"Sending maintenance reboot request to check bootloader version and FW bank headers in the Startup Mode\");\n    ret = lt_reboot(h, TR01_MAINTENANCE_REBOOT);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"lt_reboot() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK\");\n\n    // When TROPIC01 is in Start-up Mode, we can get RISC-V bootloader version the same way as we got RISC-V FW version.\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"Reading RISC-V bootloader version\");\n    ret = lt_get_info_riscv_fw_ver(h, fw_ver);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to get RISC-V bootloader version, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK\");\n\n    LT_LOG_INFO(\"RISC-V bootloader version: %02\" PRIX8 \".%02\" PRIX8 \".%02\" PRIX8 \" (+ .%02\" PRIX8 \")\", fw_ver[3] &amp; 0x7f,\n                fw_ver[2], fw_ver[1], fw_ver[0]);\n\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"Reading and printing headers of all 4 FW banks:\");\n    ret = lt_print_fw_header(h, TR01_FW_BANK_FW1, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_FW1 header, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    ret = lt_print_fw_header(h, TR01_FW_BANK_FW2, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_FW2 header, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    ret = lt_print_fw_header(h, TR01_FW_BANK_SPECT1, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_SPECT1 header, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    ret = lt_print_fw_header(h, TR01_FW_BANK_SPECT2, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_SPECT2 header, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    struct lt_chip_id_t chip_id = {0};\n\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"Reading Chip ID:\");\n    ret = lt_get_info_chip_id(h, &amp;chip_id);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to get chip ID, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    ret = lt_print_chip_id(&amp;chip_id, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print chip ID, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"Sending reboot request\");\n    ret = lt_reboot(h, TR01_REBOOT);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"lt_reboot() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"OK, TROPIC01 is executing Application FW now\");\n\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"get_started/examples/reversible_examples/#lt_ex_hello_world_separate_apic","title":"lt_ex_hello_world_separate_API.c","text":"<ul> <li>\u2705 Reversible</li> <li>\u2705 Compatible with the model</li> <li>\ud83d\udc24 Level: Moderate</li> </ul> <p>Functionally similar to <code>lt_ex_hello_world.c</code>, but it uses distinct API calls for incoming and outgoing data. This approach is useful for secure, tunneled communication, such as during chip provisioning in a factory.</p> <p>You will learn about low-level API functions used to process outgoing and incoming data. For example:</p> <ul> <li><code>lt_out__session_start()</code>: prepare Handshake_Req L2 request (for Secure Session establishment),</li> <li><code>lt_l2_send()</code>: send L2 request,</li> <li><code>lt_l2_receive()</code>: receive L2 response.</li> <li><code>lt_in__session_start()</code>: process L2 response to the Handshake_Req,</li> </ul> Source code <pre><code>/**\n * @file lt_ex_hello_world_separate_API.c\n * @brief Establishes Secure Session and executes Ping L3 command using separated API.\n * @copyright Copyright (c) 2020-2025 Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include \"libtropic.h\"\n#include \"libtropic_examples.h\"\n#include \"libtropic_l2.h\"\n#include \"libtropic_l3.h\"\n#include \"libtropic_logging.h\"\n\n/** @brief Message to send with Ping L3 command. */\n#define PING_MSG \"This is Hello World message from TROPIC01!!\"\n/** @brief Size of the Ping message, including '\\0'. */\n#define PING_MSG_SIZE 44\n\nint lt_ex_hello_world_separate_API(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"=========================================================\");\n    LT_LOG_INFO(\"====  TROPIC01 Hello World with Separate API Example ====\");\n    LT_LOG_INFO(\"=========================================================\");\n\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    // Note: It is assumed that the `h.l2.device` and `h.l3.crypto_ctx` members were already\n    // initialized. Because these members are pointers, the assigned structures must exist throughout the whole\n    // life-cycle of the handle. Refer to the 'Get Started'-&gt;'Integrating Libtropic'-&gt;'How to Use' Section in the\n    // Libtropic documentation for more information.\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Getting Certificate Store from TROPIC01\");\n    uint8_t cert1[TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE], cert2[TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE],\n        cert3[TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE], cert4[TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE];\n    struct lt_cert_store_t store\n        = {.certs = {cert1, cert2, cert3, cert4},\n           .buf_len = {TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE, TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE,\n                       TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE, TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE}};\n    ret = lt_get_info_cert_store(h, &amp;store);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to get Certificate Store, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    // Get only stpub, we don't verify certificate chain here\n    LT_LOG_INFO(\"Getting stpub key from Certificate Store\");\n    uint8_t stpub[TR01_STPUB_LEN];\n    ret = lt_get_st_pub(&amp;store, stpub);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to get stpub key, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    //---------------------------------------------------------------------------------------//\n    // Separated API calls for starting a secure session:\n    lt_host_eph_keys_t host_eph_keys = {0};\n\n    // Initialize session from a server side by creating host_eph_keys-&gt;ehpriv and host_eph_keys-&gt;ehpub,\n    // l2 request is prepared into handle's buffer (h-&gt;l2_buff)\n    LT_LOG_INFO(\"Executing lt_out__session_start()...\");\n    ret = lt_out__session_start(h, TR01_PAIRING_KEY_SLOT_INDEX_0, &amp;host_eph_keys);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_out__session_start() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    // handle's buffer (h-&gt;l2_buff) now contains data which must be transferred over tunnel to TROPIC01\n\n    // Following l2 functions are called on remote host\n    LT_LOG_INFO(\"Executing lt_l2_send()...\");\n    ret = lt_l2_send(&amp;h-&gt;l2);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_l2_send() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"Executing lt_l2_receive()...\");\n    ret = lt_l2_receive(&amp;h-&gt;l2);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_l2_receive() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    // Handle's buffer (h-&gt;l2_buff) now contains data which must be transferred over tunnel back to the server\n\n    // Once data are back on server's side, bytes are copied into h-&gt;l2_buff\n    // Then following l2 function is called on server side\n    // This function establishes gcm contexts for a session\n    LT_LOG_INFO(\"Executing lt_in__session_start()...\");\n    ret = lt_in__session_start(h, stpub, TR01_PAIRING_KEY_SLOT_INDEX_0, LT_EX_SH0_PRIV, LT_EX_SH0_PUB, &amp;host_eph_keys);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_in__session_start failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    // Now we can use lt_ping() to send a message to TROPIC01 and receive a response, this is done with separate API\n    // calls\n    uint8_t recv_buf[PING_MSG_SIZE];\n    LT_LOG_INFO(\"Executing lt_out__ping() with message:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", PING_MSG);\n    ret = lt_out__ping(h, (const uint8_t *)PING_MSG, PING_MSG_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_out__ping failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Executing lt_l2_send_encrypted_cmd()...\");\n    ret = lt_l2_send_encrypted_cmd(&amp;h-&gt;l2, h-&gt;l3.buff, h-&gt;l3.buff_len);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_l2_send_encrypted_cmd failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"Executing lt_l2_recv_encrypted_res()...\");\n    ret = lt_l2_recv_encrypted_res(&amp;h-&gt;l2, h-&gt;l3.buff, h-&gt;l3.buff_len);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_l2_recv_encrypted_res failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Executing lt_in__ping()...\");\n    ret = lt_in__ping(h, recv_buf, PING_MSG_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_in__ping failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Message received from TROPIC01:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", recv_buf);\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"get_started/examples/reversible_examples/#lt_ex_macanddc","title":"lt_ex_macandd.c","text":"<ul> <li>\u2705 Reversible</li> <li>\u2705 Compatible with the model</li> <li>\ud83d\udc13 Level: Advanced</li> </ul> <p>This example illustrates the MAC-and-destroy feature. You will learn about the following functions:</p> <ul> <li><code>lt_hmac_sha256()</code>: function to compute HMAC based on SHA256,</li> <li><code>lt_mac_and_destroy()</code>: L3 command to process MAC-and-Destroy operation,</li> <li><code>lt_r_mem_data_erase()</code>: L3 command to erase R-memory data slot,</li> <li><code>lt_r_mem_data_write()</code>: L3 command to write R-memory data slot,</li> <li><code>lt_r_mem_data_read()</code>: L3 command to read R-memory data slot,</li> <li><code>lt_random_bytes()</code>: function to generate random number using platform's RNG (not TROPIC01's),</li> </ul> <p>In this example, we also define two functions to implement PIN verification functionality: <code>lt_PIN_set()</code> and <code>lt_PIN_check()</code>. You can use these functions as inspiration for your project.</p> <p>You can find more information in the application note and code comments.</p> Source code <pre><code>/**\n * @file lt_ex_macandd.c\n * @brief Example usage of TROPIC01 flagship feature - 'Mac And Destroy' PIN verification engine.\n * For more info please refer to ODN_TR01_app_002_pin_verif.pdf\n * @copyright Copyright (c) 2020-2025 Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include &lt;inttypes.h&gt;\n\n#include \"libtropic.h\"\n#include \"libtropic_examples.h\"\n#include \"libtropic_logging.h\"\n#include \"string.h\"\n\n// Needed to access to lt_random_bytes()\n#include \"lt_random.h\"\n// Needed to access HMAC_SHA256\n#include \"lt_hmac_sha256.h\"\n\n/** @brief Last slot in User memory used for storing of M&amp;D related data (only in this example). */\n#define R_MEM_DATA_SLOT_MACANDD (511)\n/** @brief The size of random data passed during MAC-and-Destroy PIN set */\n#define TR01_MAC_AND_DESTROY_MASTER_SECRET_SIZE 32u\n\n/** @brief Size of the print buffer. */\n#define PRINT_BUFF_SIZE 196\n\n#ifndef MACANDD_ROUNDS\n#define MACANDD_ROUNDS 12\n#endif\n\n#if (MACANDD_ROUNDS &gt; 12)\n#error \\\n    \"MACANDD_ROUNDS must be less than 12 here, or generally than TR01_MACANDD_ROUNDS_MAX. Read explanation at the beginning of this file\"\n#endif\n\n/** @brief Minimal size of MAC-and-Destroy additional data */\n#define MAC_AND_DESTROY_ADD_SIZE_MIN 0\n/** @brief Maximal size of MAC-and-Destroy additional data */\n#define MAC_AND_DESTROY_ADD_SIZE_MAX 128u\n/** @brief Minimal size of MAC-and-Destroy PIN input */\n#define MAC_AND_DESTROY_PIN_SIZE_MIN 4u\n/** @brief Maximal size of MAC-and-Destroy PIN input */\n#define MAC_AND_DESTROY_PIN_SIZE_MAX 8u\n\n/**\n * @brief This structure holds data used by host during MAC and Destroy sequence\n * Content of this struct must be stored in non-volatile memory, because it is used\n * between power cycles\n */\nstruct lt_macandd_nvm_t {\n    uint8_t i;\n    uint8_t ci[MACANDD_ROUNDS * TR01_MAC_AND_DESTROY_DATA_SIZE];\n    uint8_t t[LT_HMAC_SHA256_HASH_LEN];\n} __attribute__((__packed__));\n\n/**\n * @brief Simple XOR \"encryption\" function. Replace with another encryption algorithm if needed.\n *\n * @param data         32B of data to be encrypted\n * @param key          32B key used for encryption\n * @param destination  Buffer into which 32B of encrypted data will be placed\n */\nstatic void encrypt(const uint8_t *data, const uint8_t *key, uint8_t *destination)\n{\n    for (uint8_t i = 0; i &lt; 32; i++) {\n        destination[i] = data[i] ^ key[i];\n    }\n}\n\n/**\n * @brief Simple XOR \"decryption\" function. Replace with another decryption algorithm if needed.\n *\n * @param data         32B of data to be decrypted\n * @param key          32B key used for decryption\n * @param destination  Buffer into which 32B of decrypted data will be placed\n */\nstatic void decrypt(const uint8_t *data, const uint8_t *key, uint8_t *destination)\n{\n    for (uint8_t i = 0; i &lt; 32; i++) {\n        destination[i] = data[i] ^ key[i];  //*(data + i) ^= *(key + i);\n    }\n}\n\n/**\n * @brief Example function for setting PIN with Mac And Destroy.\n *\n * @details The New PIN Setup procedure takes the user PIN, add data and high entropy master_secret as an input,\n * initializes the scheme slots and returns a 32-byte key final_key as derivative of the master_secret.\n *\n * The MAC-and-Destroy PIN veri\ufb01cation scheme uses slots located in the TROPIC01\u2019s \ufb02ash memory \u2013 one slot per\n * PIN entry attempt. These slots are \ufb01rst initialized when a new PIN is being set up.\n * The slots are then invalidated (destroyed) one by one with each PIN entry attempt. When the correct PIN is\n * entered, the slots are initialized again, therefore the PIN entry limit is reset.\n * PIN entry attempt fails if:\n *  * PIN is invalid\n *  * The current slot is not initialized for a given PIN\n *  * The current slot is destroyed by previous invalid PIN entry attempt.\n *\n * There are more ways how to implement Mac And Destroy 'PIN set' functionality, differences could be in way of\n * handling nvm data, number of tries, algorithm used for encryption, etc. This function is just one of the possible\n * implementations of \"PIN set\".\n *\n * Take it as an inspiration, copy it into your project and adapt it to your specific hw resources.\n *\n * @param h           Handle for communication with TROPIC01\n * @param master_secret  32 bytes of random data (determines final_key)\n * @param PIN         Array of bytes (size between MAC_AND_DESTROY_PIN_SIZE_MIN and MAC_AND_DESTROY_PIN_SIZE_MAX)\n * representing PIN\n * @param PIN_size    Length of the PIN field\n * @param add         Additional data to be used in M&amp;D sequence (size between MAC_AND_DESTROY_ADD_SIZE_MIN and\n * MAC_AND_DESTROY_ADD_SIZE_MAX). Pass NULL if no additional data should be used.\n * @param add_size    Length of additional data\n * @param final_key      Buffer into which final key will be placed when all went successfully\n * @return lt_ret_t   LT_OK if correct, otherwise LT_FAIL\n */\nstatic lt_ret_t lt_new_PIN_setup(lt_handle_t *h, const uint8_t *master_secret, const uint8_t *PIN,\n                                 const uint8_t PIN_size, const uint8_t *add, const uint8_t add_size, uint8_t *final_key)\n{\n    if (!h || !master_secret || !PIN || (PIN_size &lt; MAC_AND_DESTROY_PIN_SIZE_MIN)\n        || (PIN_size &gt; MAC_AND_DESTROY_PIN_SIZE_MAX) || (add_size &gt; MAC_AND_DESTROY_ADD_SIZE_MAX) || !final_key) {\n        // add parameter is not checked for NULL, because it can be NULL (handled in the lines below)\n        return LT_PARAM_ERR;\n    }\n    if (h-&gt;l3.session_status != LT_SECURE_SESSION_ON) {\n        return LT_HOST_NO_SESSION;\n    }\n\n    uint8_t add_size_checked = add_size;\n    if (!add) {\n        add_size_checked = 0;\n    }\n\n    // Clear variable for released final_key so there is known data (zeroes) in case this function ended sooner then\n    // final_key was prepared\n    memset(final_key, 0, TR01_MAC_AND_DESTROY_DATA_SIZE);\n\n    // Variable used during a process of getting a encryption key k_i\n    uint8_t v[LT_HMAC_SHA256_HASH_LEN] = {0};\n    // Variable used during a process of getting a encryption key k_i\n    uint8_t w_i[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n    // Encryption key\n    uint8_t k_i[LT_HMAC_SHA256_HASH_LEN] = {0};\n    // Variable used to initialize slot(s)\n    uint8_t u[LT_HMAC_SHA256_HASH_LEN] = {0};\n    // Helper array of zeroes (used as a key in KDF)\n    const uint8_t zeros[32] = {0};\n\n    // This organizes data which will be stored into nvm\n    struct lt_macandd_nvm_t nvm = {0};\n\n    // User is expected to pass not only PIN, but might also pass another data (e.g. HW ID, ...)\n    // Both arrays are concatenated and used together as an input for KDF\n    uint8_t kdf_input_buff[MAC_AND_DESTROY_PIN_SIZE_MAX + MAC_AND_DESTROY_ADD_SIZE_MAX];\n    memcpy(kdf_input_buff, PIN, PIN_size);\n    if (!add || add_size_checked == 0) {\n        LT_LOG_INFO(\"No additional data will be used in the following M&amp;D sequence\");\n    }\n    else {\n        memcpy(kdf_input_buff + PIN_size, add, add_size_checked);\n    }\n\n    // Erase a slot in R memory, which will be used as a storage for NVM data\n    LT_LOG_INFO(\"Erasing R_Mem User slot %d...\", R_MEM_DATA_SLOT_MACANDD);\n    lt_ret_t ret = lt_r_mem_data_erase(h, R_MEM_DATA_SLOT_MACANDD);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to erase User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // Store number of attempts\n    nvm.i = MACANDD_ROUNDS;\n    // Compute tag t = KDF(s, 0x00), save into nvm struct\n    // Tag will be later used during lt_PIN_entry_check() to verify validity of final_key\n    ret = lt_hmac_sha256(master_secret, TR01_MAC_AND_DESTROY_MASTER_SECRET_SIZE, (uint8_t[]){0x00}, 1, nvm.t);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"t = KDF(s, 0x00) failed, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n\n    // Compute u = KDF(s, 0x01)\n    // This value will be sent through M&amp;D sequence to initialize a slot\n    ret = lt_hmac_sha256(master_secret, TR01_MAC_AND_DESTROY_MASTER_SECRET_SIZE, (uint8_t[]){0x01}, 1, u);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"u = KDF(s, 0x01) failed, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n\n    // Compute v = KDF(0, PIN||A) where 0 is all zeroes key\n    ret = lt_hmac_sha256(zeros, sizeof(zeros), kdf_input_buff, PIN_size + add_size_checked, v);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"v = KDF(0, PIN||A) failed, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n\n    for (int i = 0; i &lt; nvm.i; i++) {\n        uint8_t ignore[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n\n        // This call of a M&amp;D sequence results in initialization of one slot\n        LT_LOG_INFO(\"Doing M&amp;D sequence to initialize a slot...\");\n        ret = lt_mac_and_destroy(h, i, u, ignore);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed while doing M&amp;D sequence, ret=%s\", lt_ret_verbose(ret));\n            goto exit;\n        }\n        LT_LOG_INFO(\"\\tOK\");\n\n        // This call of a M&amp;D sequence overwrites a previous slot, but key w is returned.\n        // This key is later used to derive k_i (used to encrypt precious final_key)\n        LT_LOG_INFO(\"Doing M&amp;D sequence to overwrite previous slot...\");\n        ret = lt_mac_and_destroy(h, i, v, w_i);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed while doing M&amp;D sequence, ret=%s\", lt_ret_verbose(ret));\n            goto exit;\n        }\n        LT_LOG_INFO(\"\\tOK\");\n\n        // Now the slot is initialized again by calling M&amp;D sequence again with 'u'\n        LT_LOG_INFO(\"Doing M&amp;D sequence again to initialize a slot...\");\n        ret = lt_mac_and_destroy(h, i, u, ignore);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed while doing M&amp;D sequence, ret=%s\", lt_ret_verbose(ret));\n            goto exit;\n        }\n        LT_LOG_INFO(\"\\tOK\");\n\n        // Derive k_i = KDF(w_i, PIN||A); k_i will be used to encrypt master_secret\n        ret = lt_hmac_sha256(w_i, sizeof(w_i), kdf_input_buff, PIN_size + add_size_checked, k_i);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"k_i = KDF(w_i, PIN||A) failed, ret=%s\", lt_ret_verbose(ret));\n            goto exit;\n        }\n\n        // Encrypt master_secret using k_i as a key and store ciphertext into non volatile storage\n        encrypt(master_secret, k_i, nvm.ci + (i * TR01_MAC_AND_DESTROY_DATA_SIZE));\n    }\n\n    // Persistently save nvm data into TROPIC01's R memory slot\n    LT_LOG_INFO(\"Writing NVM data into R_Mem User slot %d...\", R_MEM_DATA_SLOT_MACANDD);\n    ret = lt_r_mem_data_write(h, R_MEM_DATA_SLOT_MACANDD, (uint8_t *)&amp;nvm, sizeof(nvm));\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to write User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n\n    // final_key is released to the caller\n    ret = lt_hmac_sha256(master_secret, TR01_MAC_AND_DESTROY_MASTER_SECRET_SIZE, (uint8_t *)\"2\", 1, final_key);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Fail during last computation of final_key, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n\n// Cleanup all sensitive data from memory.\n// We recommend using a safe function for this. Refer to the link below for some information.\n// https://www.gnu.org/software/libc/manual/html_node/Erasing-Sensitive-Data.html\nexit:\n    memset(kdf_input_buff, 0, PIN_size + add_size_checked);\n    memset(u, 0, sizeof(u));\n    memset(v, 0, sizeof(v));\n    memset(w_i, 0, sizeof(w_i));\n    memset(k_i, 0, sizeof(k_i));\n\n    return ret;\n}\n\n/**\n * @brief Example function for checking PIN with Mac And Destroy.\n *\n * @details The Pin Entry Check procedure takes the PIN and additional add data entered by the user as an input, and\n * checks the PIN. If successful, the correct key k is returned.\n *\n * There are more ways how to implement Mac And Destroy 'PIN check' functionality, differences could be in way\n * of handling nvm data, number of tries, algorithm used for decryption, etc. This function is just one of the possible\n * implementations of \"PIN check\".\n *\n * Take it as an inspiration, copy it into your project and adapt it to your specific hw resources.\n *\n * @param h           Handle for communication with TROPIC01\n * @param PIN         Array of bytes (size between MAC_AND_DESTROY_PIN_SIZE_MIN and MAC_AND_DESTROY_PIN_SIZE_MAX)\n * representing PIN\n * @param PIN_size    Length of the PIN field\n * @param add         Additional data to be used in M&amp;D sequence (size between MAC_AND_DESTROY_ADD_SIZE_MIN and\n * MAC_AND_DESTROY_ADD_SIZE_MAX). Pass NULL if no additional data should be used.\n * @param add_size    Length of additional data\n * @param final_key   Buffer into which final_key will be saved\n * @return lt_ret_t   LT_OK if correct, otherwise LT_FAIL\n */\nstatic lt_ret_t lt_PIN_entry_check(lt_handle_t *h, const uint8_t *PIN, const uint8_t PIN_size, const uint8_t *add,\n                                   const uint8_t add_size, uint8_t *final_key)\n{\n    if (!h || !PIN || (PIN_size &lt; MAC_AND_DESTROY_PIN_SIZE_MIN) || (PIN_size &gt; MAC_AND_DESTROY_PIN_SIZE_MAX)\n        || (add_size &gt; MAC_AND_DESTROY_ADD_SIZE_MAX) || !final_key) {\n        // add parameter is not checked for NULL, because it can be NULL (handled in the lines below)\n        return LT_PARAM_ERR;\n    }\n    if (h-&gt;l3.session_status != LT_SECURE_SESSION_ON) {\n        return LT_HOST_NO_SESSION;\n    }\n\n    uint8_t add_size_checked = add_size;\n    if (!add) {\n        add_size_checked = 0;\n    }\n\n    // Clear variable for released final_key so there is known data (zeroes) in case this function ended sooner then\n    // final_key was prepared\n    memset(final_key, 0, TR01_MAC_AND_DESTROY_DATA_SIZE);\n\n    // Variable used during a process of getting a decryption key k_i\n    uint8_t v_[LT_HMAC_SHA256_HASH_LEN] = {0};\n    // Variable used during a process of getting a decryption key k_i\n    uint8_t w_i[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n    // Decryption key\n    uint8_t k_i[LT_HMAC_SHA256_HASH_LEN] = {0};\n    // Secret\n    uint8_t s_[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n    // Tag\n    uint8_t t_[LT_HMAC_SHA256_HASH_LEN] = {0};\n    // Value used to initialize Mac And Destroy's slot after a correct PIN try\n    uint8_t u[LT_HMAC_SHA256_HASH_LEN] = {0};\n    // Helper array of zeroes (used as a key in KDF)\n    const uint8_t zeros[32] = {0};\n\n    // This organizes data which will be read from nvm\n    struct lt_macandd_nvm_t nvm = {0};\n\n    // User might pass not only PIN, but also another data(e.g. HW ID, ...) if needed\n    // Both arrays are concatenated and used together as an input for KDF\n    uint8_t kdf_input_buff[MAC_AND_DESTROY_PIN_SIZE_MAX + MAC_AND_DESTROY_ADD_SIZE_MAX];\n    memcpy(kdf_input_buff, PIN, PIN_size);\n    if (!add || add_size_checked == 0) {\n        LT_LOG_INFO(\"No additional data will be used in the following M&amp;D sequence\");\n    }\n    else {\n        memcpy(kdf_input_buff + PIN_size, add, add_size_checked);\n    }\n\n    // Load M&amp;D data from TROPIC01's R memory\n    LT_LOG_INFO(\"Reading M&amp;D data from R_Mem User slot %d...\", R_MEM_DATA_SLOT_MACANDD);\n    uint16_t read_size;\n    lt_ret_t ret = lt_r_mem_data_read(h, R_MEM_DATA_SLOT_MACANDD, (uint8_t *)&amp;nvm, sizeof(nvm), &amp;read_size);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to read User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // if i == 0: FAIL (no attempts remaining)\n    LT_LOG_INFO(\"Checking if nvm.i != 0...\");\n    if (nvm.i == 0) {\n        LT_LOG_ERROR(\"nvm.i == 0\");\n        goto exit;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // Decrement variable which holds number of tries\n    // Let i = i - 1\n    nvm.i--;\n\n    // and store M&amp;D data back to TROPIC01's R memory\n    LT_LOG_INFO(\"Writing back M&amp;D data into R_Mem User slot %d (erase, then write)...\", R_MEM_DATA_SLOT_MACANDD);\n    ret = lt_r_mem_data_erase(h, R_MEM_DATA_SLOT_MACANDD);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to erase User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    ret = lt_r_mem_data_write(h, R_MEM_DATA_SLOT_MACANDD, (uint8_t *)&amp;nvm, sizeof(nvm));\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to write User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // Compute v\u2019 = KDF(0, PIN\u2019||A).\n    ret = lt_hmac_sha256(zeros, sizeof(zeros), kdf_input_buff, PIN_size + add_size_checked, v_);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"v' = KDF(0, PIN'||A) failed, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n\n    // Execute w\u2019 = MACANDD(i, v\u2019)\n    LT_LOG_INFO(\"Doing M&amp;D sequence...\");\n    ret = lt_mac_and_destroy(h, nvm.i, v_, w_i);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed while doing M&amp;D sequence, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // Compute k\u2019_i = KDF(w\u2019, PIN\u2019||A)\n    ret = lt_hmac_sha256(w_i, sizeof(w_i), kdf_input_buff, PIN_size + add_size_checked, k_i);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"k'_i = KDF(w', PIN'||A) failed, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n\n    // Read the ciphertext c_i and tag t from NVM,\n    // decrypt c_i with k\u2019_i as the key and obtain s_\n    decrypt(nvm.ci + (nvm.i * TR01_MAC_AND_DESTROY_DATA_SIZE), k_i, s_);\n\n    // Compute tag t = KDF(s_, \"0x00\")\n    ret = lt_hmac_sha256(s_, sizeof(s_), (uint8_t[]){0x00}, 1, t_);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"t = KDF(s_, \\\"0x00\\\") failed, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n\n    // If t\u2019 != t: FAIL\n    if (memcmp(nvm.t, t_, sizeof(t_)) != 0) {\n        ret = LT_FAIL;\n        goto exit;\n    }\n\n    // Pin is correct, now initialize macandd slots again:\n    // Compute u = KDF(s\u2019, \"0x01\")\n    ret = lt_hmac_sha256(s_, sizeof(s_), (uint8_t[]){0x01}, 1, u);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"u = KDF(s', \\\"0x01\\\") failed, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n\n    for (int x = nvm.i; x &lt; MACANDD_ROUNDS - 1; x++) {\n        uint8_t ignore[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n\n        LT_LOG_INFO(\"Doing M&amp;D sequence...\");\n        ret = lt_mac_and_destroy(h, x, u, ignore);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed while doing M&amp;D sequence, ret=%s\", lt_ret_verbose(ret));\n            goto exit;\n        }\n        LT_LOG_INFO(\"\\tOK\");\n    }\n\n    // Set variable which holds number of tries back to initial state MACANDD_ROUNDS\n    nvm.i = MACANDD_ROUNDS;\n\n    // Store NVM data for future use\n    LT_LOG_INFO(\"Writing M&amp;D data into R_Mem User slot %d for future use (erase, then write)...\",\n                R_MEM_DATA_SLOT_MACANDD);\n    ret = lt_r_mem_data_erase(h, R_MEM_DATA_SLOT_MACANDD);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to erase User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    ret = lt_r_mem_data_write(h, R_MEM_DATA_SLOT_MACANDD, (uint8_t *)&amp;nvm, sizeof(nvm));\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to write User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // Calculate final_key and store it into passed array\n    ret = lt_hmac_sha256(s_, sizeof(s_), (uint8_t *)\"2\", 1, final_key);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Fail during last computation of final_key, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n\n// Cleanup all sensitive data from memory.\n// We recommend using a safe function for this. Refer to the link below for some information.\n// https://www.gnu.org/software/libc/manual/html_node/Erasing-Sensitive-Data.html\nexit:\n    memset(kdf_input_buff, 0, PIN_size + add_size_checked);\n    memset(w_i, 0, sizeof(w_i));\n    memset(k_i, 0, sizeof(k_i));\n    memset(v_, 0, sizeof(v_));\n\n    return ret;\n}\n\nint lt_ex_macandd(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"==========================================\");\n    LT_LOG_INFO(\"==== TROPIC01 Mac and Destroy Example ====\");\n    LT_LOG_INFO(\"==========================================\");\n\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    // Note: It is assumed that the `h.l2.device` and `h.l3.crypto_ctx` members were already\n    // initialized. Because these members are pointers, the assigned structures must exist throughout the whole\n    // life-cycle of the handle. Refer to the 'Get Started'-&gt;'Integrating Libtropic'-&gt;'How to Use' Section in the\n    // Libtropic documentation for more information.\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_verify_chip_and_start_secure_session(h, LT_EX_SH0_PRIV, LT_EX_SH0_PUB, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to start Secure Session with key %d, ret=%s\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0,\n                     lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    // This variable stores final_key which is released to the user after successful PIN check or PIN set\n    uint8_t final_key_initialized[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n\n    // Additional data passed by user besides PIN - this is optional, but recommended\n    uint8_t additional_data[]\n        = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,\n           0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88};\n\n    // User's PIN\n    uint8_t pin[] = {1, 2, 3, 4};\n    uint8_t pin_wrong[] = {2, 2, 3, 4};\n\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Initializing Mac And Destroy\");\n    LT_LOG_INFO(\"Generating random master_secret...\");\n    uint8_t master_secret[TR01_MAC_AND_DESTROY_MASTER_SECRET_SIZE] = {0};\n    ret = lt_random_bytes(h, master_secret, TR01_MAC_AND_DESTROY_MASTER_SECRET_SIZE);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to get random bytes, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n    char print_buff[PRINT_BUFF_SIZE];\n    ret = lt_print_bytes(master_secret, sizeof(master_secret), print_buff, PRINT_BUFF_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_print_bytes failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"Generated master_secret: %s\", print_buff);\n\n    // Set the PIN and log out the final_key\n    LT_LOG(\"Setting the user PIN...\");\n    ret = lt_new_PIN_setup(h, master_secret, pin, sizeof(pin), NULL, sizeof(additional_data), final_key_initialized);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to set the user PIN, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    ret = lt_print_bytes(final_key_initialized, sizeof(final_key_initialized), print_buff, PRINT_BUFF_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_print_bytes failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"Initialized final_key: %s\", print_buff);\n    LT_LOG_LINE();\n\n    uint8_t final_key_exported[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n    LT_LOG_INFO(\"Doing %d PIN check attempts with wrong PIN...\", MACANDD_ROUNDS);\n    for (int i = 1; i &lt; MACANDD_ROUNDS; i++) {\n        LT_LOG_INFO(\"\\tInputting wrong PIN -&gt; slot #%d destroyed\", i);\n        ret = lt_PIN_entry_check(h, pin_wrong, sizeof(pin_wrong), NULL, sizeof(additional_data), final_key_exported);\n        if (LT_FAIL != ret) {\n            LT_LOG_ERROR(\"Return value is not LT_FAIL, ret=%s\", lt_ret_verbose(ret));\n            lt_session_abort(h);\n            lt_deinit(h);\n            return -1;\n        }\n        ret = lt_print_bytes(final_key_exported, sizeof(final_key_exported), print_buff, PRINT_BUFF_SIZE);\n        if (LT_OK != ret) {\n            LT_LOG_ERROR(\"lt_print_bytes failed, ret=%s\", lt_ret_verbose(ret));\n            lt_session_abort(h);\n            lt_deinit(h);\n            return -1;\n        }\n        LT_LOG_INFO(\"\\tSecret: %s\", print_buff);\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Doing Final PIN attempt with correct PIN, slots are reinitialized again...\");\n    ret = lt_PIN_entry_check(h, pin, sizeof(pin), NULL, sizeof(additional_data), final_key_exported);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Attempt with correct PIN failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    ret = lt_print_bytes(final_key_exported, sizeof(final_key_exported), print_buff, PRINT_BUFF_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_print_bytes failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tExported final_key: %s\", print_buff);\n    LT_LOG_INFO(\"\\tOK\");\n    LT_LOG_LINE();\n\n    if (memcmp(final_key_initialized, final_key_exported, sizeof(final_key_initialized))) {\n        LT_LOG_ERROR(\"final_key and final_key_exported DO NOT MATCH\");\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    else {\n        LT_LOG_INFO(\"final_key and final_key_exported MATCH\");\n    }\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"get_started/integrating_libtropic/","title":"Integrating Libtropic","text":"<p>This section provides guidance on integrating Libtropic into your application.</p> <ul> <li>How to Build</li> <li>How to Configure</li> <li>How to Use</li> <li>Integration Examples</li> </ul>"},{"location":"get_started/integrating_libtropic/integration_examples/","title":"Integration Examples","text":"<p>We offer so-called platform repositories, where libtropic is utilized as a submodule, possibly showing an example of integrating libtropic into your application:</p> <ul> <li>libtropic-stm32,</li> <li>libtropic-linux,</li> <li>libtropic-arduino.</li> </ul> <p>Tip</p> <p>These repositories include quick start guides to help you get started quickly with one of the supported platforms.</p> <p>Beside these repositories, we offer the libtropic-util repository, which implements a CLI based utility for executing TROPIC01's commands.</p>"},{"location":"get_started/integrating_libtropic/how_to_build/","title":"How to Build","text":"<p>Libtropic uses CMake and does not support other build systems by default. However, we provide steps on how to add it to a Makefile project or compile it as a static library.</p> <ul> <li>Add to an Existing Project</li> <li>Compile as a Static Library</li> </ul>"},{"location":"get_started/integrating_libtropic/how_to_build/adding_to_project/","title":"Add to an Existing Project","text":"<p>We recommend adding Libtropic to an existing project as a git submodule. Libtropic uses the CMake build system, so it can be added to the compilation of existing CMake projects as follows:</p> <ol> <li>Set path to the Libtropic submodule, for example as: <pre><code>set(PATH_LIBTROPIC ${CMAKE_CURRENT_SOURCE_DIR}/../vendor/libtropic/)\n</code></pre></li> <li>Add the Libtropic subdirectory: <pre><code>add_subdirectory(${PATH_LIBTROPIC} \"libtropic\")\n</code></pre></li> <li>By default, Libtropic does not link a CFP (Cryptographic Functionality Provider) or its CAL (Crypto Abstraction Layer), so it can be built as a static library. This is the consumer's responsibility:<ol> <li>For the chosen CFP (e.g. MbedTLS v4.0.0), add the correct subdirectory inside <code>libtropic/cal/</code>, which provides the corresponding CAL sources and include directories: <pre><code>add_subdirectory(\"${PATH_LIBTROPIC}cal/mbedtls_v4\")\n</code></pre></li> <li>Add the obtained sources and include directories to the <code>tropic</code> target: <pre><code>target_sources(tropic PRIVATE ${LT_CAL_SRCS})\ntarget_include_directories(tropic PUBLIC ${LT_CAL_INC_DIRS})\n</code></pre></li> <li>Link the CFP (provided by the consumer) to the <code>tropic</code> target: <pre><code>target_link_libraries(tropic PUBLIC mbedtls)\n</code></pre></li> </ol> </li> <li>By default, libtropic does not link platform-specific code or its HAL, so it can be built as a static library. This is the consumer's responsibility:<ol> <li>For the chosen platform (e.g. Linux with HW SPI), add a corresponding HAL using <code>add_subdirectory</code>: <pre><code>add_subdirectory(\"${PATH_TO_LIBTROPIC}hal/linux/spi\")\n</code></pre></li> <li>Add HAL sources and include directories to the <code>tropic</code> target. In the previous step, <code>LT_HAL_SRCS</code> and <code>LT_HAL_INC_DIRS</code> variables were populated based on the selected HAL, so you can use those: <pre><code>target_sources(tropic PRIVATE ${LT_HAL_SRCS})\ntarget_include_directories(tropic PUBLIC ${LT_HAL_INC_DIRS})\n</code></pre></li> </ol> </li> <li>And finally, link Libtropic with your binary: <pre><code>target_link_libraries(my_binary_name PRIVATE tropic)\n</code></pre></li> </ol> <p>Inspiration for CMakeLists.txt</p> <p>The exact CMake calls depend on a configuration of the project into which libtropic is being added. For more inspiration, refer to the Integration Examples section and the CMake Documentation.</p> <p>Supported Host Platforms and CFPs</p> <p>Refer to sections Supported Host Platforms and Supported Cryptographic Functionality Providers to see what is supported.</p>"},{"location":"get_started/integrating_libtropic/how_to_build/adding_to_project/#do-you-use-a-makefile-instead-of-cmake","title":"Do You Use a Makefile Instead of CMake?","text":"<p>If you use a Makefile instead of CMake, you need to:</p> <ol> <li>Manually list all <code>*.c</code> and <code>*.h</code> Libtropic files in your Makefile (you can use the root <code>CMakeLists.txt</code> for inspiration).</li> <li>For each required CMake option <code>&lt;CMAKE_OPTION&gt;</code>, add the <code>-D&lt;CMAKE_OPTION&gt;</code> flag when building with Make.</li> </ol> <p>Available CMake Options</p> <p>See How to Configure for available CMake Options. However, some of these options are not directly used in the Libtropic code - based on them, additional internal macros are defined. To see those, either:</p> <ol> <li>Analyze Libtropic's root <code>CMakeLists.txt</code>.</li> <li>Configure Libtropic using CMake and then execute <code>grep LT_ CMakeCache.txt</code> in your <code>build/</code> directory to see all used options/defines.</li> </ol> <p>Tip: Build Libtropic as a Static Library</p> <p>You can compile libtropic as a static library (see Compile as a Static Library) using CMake separately and include only the resulting library file in your Makefile. This approach eliminates the need to compile the entire libtropic library and its dependencies in your Makefile. However, you will still need to manually add the HAL files for your platform (<code>libtropic/hal/</code>) and the CAL files for your CFP (<code>libtropic/cal/</code>).</p>"},{"location":"get_started/integrating_libtropic/how_to_build/compile_as_static_library/","title":"Compile as a Static Library","text":"<p>Apart from building Libtropic during your project's build process, you can build Libtropic separately as a static library (also known as a static archive on Linux) and link it later.</p> <p>HAL and CAL Files Handling</p> <p>The Libtropic static library does not contain HALs (<code>libtropic/hal/</code>) or CALs (<code>libtropic/cal/</code>). The consumer must provide these:</p> <ol> <li>If CMake is used, inspiration can be taken from the steps in the Add to an Existing Project section.</li> <li>In other cases, the HAL and CAL files will have to be added manually.</li> </ol>"},{"location":"get_started/integrating_libtropic/how_to_build/compile_as_static_library/#compilation","title":"Compilation","text":"<p>To compile Libtropic as a static library on a Unix-like system, run:</p> <pre><code>$ mkdir build\n$ cd build\n$ cmake ..\n$ make\n</code></pre> <p>To cross-compile Libtropic as a static library on a Unix-like system, you need a toolchain configuration file and a linker script. Both should be provided by the vendor of your platform. See an example of the toolchain configuration and linker script in the libtropic-stm32 repository.</p> <p>After acquiring both the toolchain configuration and the linker script, do:</p> <pre><code>$ mkdir build\n$ cd build\n$ cmake -DCMAKE_TOOLCHAIN_FILE=&lt;ABSOLUTE PATH&gt;/toolchain.cmake -DLINKER_SCRIPT=&lt;ABSOLUTE PATH&gt;/linker_script.ld ..\n$ make\n</code></pre>"},{"location":"get_started/integrating_libtropic/how_to_build/compile_as_static_library/#linking-in-a-cmake-project","title":"Linking in a CMake Project","text":"<p>To link the compiled static library to your application, use <code>target_link_libraries</code>. For example:</p> <pre><code>add_executable(my_app source1.c source2.c etc.c)\ntarget_link_libraries(my_app &lt;absolute path to library file&gt;)\n</code></pre> <p>Other Linking Options</p> <p>There are other options for linking the library (e.g., imported targets). Refer to the CMake documentation for more information.</p>"},{"location":"get_started/integrating_libtropic/how_to_build/compile_as_static_library/#linking-in-a-make-project","title":"Linking in a Make Project","text":"<p>If you are using <code>make</code> with a Makefile, you can include the static library by adding the following lines to your Makefile:</p> <pre><code>LDFLAGS += -L&lt;directory where the static library file is located&gt;\nLDLIBS  += -ltropic\n</code></pre> <p>Linking External Libraries</p> <p>Refer to the GNU Make documentation for more information about linking external libraries.</p>"},{"location":"get_started/integrating_libtropic/how_to_configure/","title":"How to Configure","text":"<p>Libtropic can be configured using the Available CMake Options (let's say <code>LT_CFG_OPT</code>) in the following ways:</p> <ol> <li>Via a command line when building the project: <pre><code>cmake -DLT_CFG_OPT=value ..\n</code></pre></li> <li>Using the CMake GUI. This makes the configuring process more user-friendly compared to the previous way. For more information, refer to the cmake-gui documentation.</li> <li>In your project's <code>CMakeLists.txt</code>: <pre><code>set(LT_CFG_OPT value)\n</code></pre></li> </ol>"},{"location":"get_started/integrating_libtropic/how_to_configure/#available-cmake-options","title":"Available CMake Options","text":""},{"location":"get_started/integrating_libtropic/how_to_configure/#lt_build_examples","title":"<code>LT_BUILD_EXAMPLES</code>","text":"<ul> <li>boolean</li> <li>default value: <code>OFF</code></li> </ul> <p>Examples will be built as part of the Libtropic library.</p>"},{"location":"get_started/integrating_libtropic/how_to_configure/#lt_build_tests","title":"<code>LT_BUILD_TESTS</code>","text":"<ul> <li>boolean</li> <li>default value: <code>OFF</code></li> </ul> <p>Functional tests will be built as part of the Libtropic library.</p>"},{"location":"get_started/integrating_libtropic/how_to_configure/#lt_sh0_keys","title":"<code>LT_SH0_KEYS</code>","text":"<ul> <li>string</li> <li>default value: <code>\"prod0\"</code></li> </ul> <p>Programs, compiled when <code>LT_BUILD_EXAMPLES</code> or <code>LT_BUILD_TESTS</code> are set, depend on the Default Pairing Keys for a Secure Channel Handshake. Keys that will be used in these programs can be changed by setting <code>LT_SH0_KEYS</code> to one of the available values.</p> <p>See Available Values When Using CMake CLI</p> <p>Pass <code>-DLT_SH0_KEYS=</code> to <code>cmake</code>, which will invoke an error, but will print the available values.</p>"},{"location":"get_started/integrating_libtropic/how_to_configure/#lt_helpers","title":"<code>LT_HELPERS</code>","text":"<ul> <li>boolean</li> <li>default value: <code>ON</code></li> </ul> <p>Compile the helper functions.</p>"},{"location":"get_started/integrating_libtropic/how_to_configure/#lt_log_lvl","title":"<code>LT_LOG_LVL</code>","text":"<ul> <li>string</li> <li>default value: <code>\"None\"</code></li> <li>default value if <code>LT_BUILD_EXAMPLES</code> or <code>LT_BUILD_TESTS</code> are set: <code>\"Info\"</code></li> </ul> <p>Specifies the log level. See Logging for more information.</p>"},{"location":"get_started/integrating_libtropic/how_to_configure/#lt_use_int_pin","title":"<code>LT_USE_INT_PIN</code>","text":"<ul> <li>boolean</li> <li>default value: <code>OFF</code></li> </ul> <p>Use TROPIC01's interrupt pin while waiting for TROPIC01's response.</p>"},{"location":"get_started/integrating_libtropic/how_to_configure/#lt_separate_l3_buff","title":"<code>LT_SEPARATE_L3_BUFF</code>","text":"<ul> <li>boolean</li> <li>default value: <code>OFF</code></li> </ul> <p>Buffer used for sending and receiving L3 Layer data will be defined by the user. The user then has to pass a pointer to their buffer into the instance of <code>lt_handle_t</code>: <pre><code>#include \"libtropic_common.h\"\n\nlt_handle_t handle;\nuint8_t user_l3_buffer[LT_SIZE_OF_L3_BUFF] __attribute__((aligned(16)));\n\nhandle.l3.buff = user_l3_buffer;\nhandle.l3.buff_len = sizeof(user_l3_buffer);\n</code></pre></p>"},{"location":"get_started/integrating_libtropic/how_to_configure/#lt_print_spi_data","title":"<code>LT_PRINT_SPI_DATA</code>","text":"<ul> <li>boolean</li> <li>default value: <code>OFF</code></li> </ul> <p>Log SPI communication using <code>printf</code>. Handy to debug low level communication.</p>"},{"location":"get_started/integrating_libtropic/how_to_configure/#lt_silicon_rev","title":"<code>LT_SILICON_REV</code>","text":"<ul> <li>string</li> <li>default value: latest silicon revision available in the current Libtropic release</li> </ul> <p>Silicon version (e.g. <code>\"ACAB\"</code>) of the currently used TROPIC01 has to be set in this option. It is needed for TROPIC01's firmware update and functional tests, as some behavior differs between the TROPIC01 revisions.</p> <p>What Is the Silicon Revision of My TROPIC01?</p> <p>Refer to the dedicated section in the FAQ.</p> <p>Warning</p> <p>Because the implementation of Libtropic's FW update functions is chosen at compile-time based on <code>LT_SILICON_REV</code>, in one compiled instance of Libtropic, FW update can be done only with TROPIC01 of this silicon revision.</p> <p>Example</p> <p>I passed <code>-DLT_SILICON_REV=ACAB</code> to <code>cmake</code> during the build. I will be able to do FW updates with TROPIC01 chips that have silicon revision ACAB only. Updating a TROPIC01 chip with e.g. ABAB silicon revision will not work.</p> <p>See Available Values When Using CMake CLI</p> <p>Pass <code>-DLT_SILICON_REV=</code> to <code>cmake</code>, which will invoke an error, but will print the available values.</p>"},{"location":"get_started/integrating_libtropic/how_to_configure/#lt_cpu_fw_update_data_ver","title":"<code>LT_CPU_FW_UPDATE_DATA_VER</code>","text":"<ul> <li>string</li> <li>default value: latest FW version available in the current Libtropic release</li> </ul> <p>Defines the TROPIC01's RISC-V CPU FW version (e.g. <code>\"1_0_1\"</code>) to update to. It is used for compiling the correct FW update files for both the RISC-V CPU and SPECT. Available versions can be seen in the compatibility table in the repository's main <code>README.md</code>.</p> <p>See Available Values When Using CMake CLI</p> <p>Pass <code>-DLT_CPU_FW_VERSION=</code> to <code>cmake</code>, which will invoke an error, but will print the available values.</p> <p>See Current Configuration</p> <p>Use <code>cmake -LAH | grep -B 1 LT_</code> to check current value of all Libtropic options.</p>"},{"location":"get_started/integrating_libtropic/how_to_use/","title":"How to Use","text":"<p>First, the Host platform and Cryptographic Functionality Provider (CFP) have to be chosen. Refer to sections Supported Host Platforms and Supported Cryptographic Functionality Providers to see which ones are supported.</p>"},{"location":"get_started/integrating_libtropic/how_to_use/#which-headers-to-include","title":"Which Headers To Include?","text":"<p>To start using Libtropic in your application, include the following headers:</p> <ol> <li><code>libtropic_common.h</code>: Declarations of commonly used macros, structures, enums, and other definitions.</li> <li><code>libtropic.h</code>: Main API function declarations.</li> <li><code>libtropic_port_&lt;port_name&gt;.h</code>: Declares the <code>lt_dev_&lt;port_name&gt;_t</code> device structure specific to the Host platform (see the <code>libtropic/hal/</code> directory for existing platform HALs). An <code>lt_dev_&lt;port_name&gt;_t</code> variable must be declared and passed to an instance of <code>lt_handle_t</code> (see the example below).</li> <li><code>libtropic_&lt;cfp_name&gt;.h</code>: Declares the <code>lt_ctx_&lt;cfp_name&gt;_t</code> context structure specific to the used CFP (Cryptographic Functionality Provider). See the <code>libtropic/cal/</code> directory for the existing CALs (Crypto Abstraction Layers). An <code>lt_ctx_&lt;cfp_name&gt;_t</code> variable must be declared and passed to an instance of <code>lt_handle_t</code> (see the example below).</li> <li>Based on the needed functionality, include additional headers from <code>libtropic/include/</code>. Refer to the API Reference for more details.</li> </ol> <p>Note</p> <p>The headers <code>libtropic_port_&lt;port_name&gt;.h</code> and <code>libtropic_&lt;cfp_name&gt;.h</code> are typically only needed when initializing the <code>lt_handle_t</code> instance \u2014 see the example below.</p>"},{"location":"get_started/integrating_libtropic/how_to_use/#libtropic-bare-bone-example","title":"Libtropic Bare-Bone Example","text":"<p>Tip</p> <p>For ideas about what to do in step 8 of the example below, refer to the Examples section.</p> <p>We recommend checking the Integration Examples section for complete examples showing how to use Libtropic on some supported platforms.</p> <p>The following bare-bone example shows how to initialize Libtropic, so it can be used to communicate with TROPIC01: <pre><code>#include \"libtropic_common.h\"\n#include \"libtropic.h\"\n#include \"libtropic_port_&lt;port_name&gt;.h\"\n#include \"libtropic_&lt;cfp_name&gt;.h\"\n\nint main(void) {\n    // 1. Declare a handle variable.\n    //\n    // The handle is a context for the whole communication between libtropic\n    // and TROPIC01. Multiple handle instances can exist if it is needed to\n    // communicate with multiple TROPIC01 chips.\n    lt_handle_t h;\n\n    // 2. Declare a device structure.\n    //\n    // The device structure provides libtropic with the device-specific\n    // information.\n    //\n    // IMPORTANT: This structure must exist throughout the whole life-cycle\n    // of the handle declared above, because the handle points to it,\n    // does not copy it!\n    lt_dev_&lt;port_name&gt;_t my_device;\n\n    // 3. Initialize the device structure.\n    //\n    // The members of the device structure are specific to the device - each\n    // device requires different members to be initialized.\n    my_device.first_member = \"some value for the first member\";\n    my_device.nth_member = \"some value for the n-th member\";\n\n    // 4. Save a pointer to the device structure inside the handle.\n    //\n    // Libtropic will then pass this structure to the HAL functions.\n    //\n    // IMPORTANT #1: The assignment below has to be done before calling\n    // lt_init() with the specific handle instance!\n    // IMPORTANT #2: One device structure cannot be shared among multiple\n    // handle instances!\n    h.l2.device = &amp;my_device;\n\n    // 5. Declare a context structure for the CFP (Cryptographic Functionality\n    // Provider).\n    //\n    // The context structure provides libtropic with the memory location where\n    // it can save contexts of cryptographic functions. None of its members have\n    // to be initialized.\n    //\n    // IMPORTANT: This structure must exist throughout the whole life-cycle\n    // of the handle declared above, because the handle points to it,\n    // does not copy it!\n    lt_ctx_&lt;cfp_name&gt;_t my_crypto_ctx;\n\n    // 6. Save a pointer to the context structure inside the handle.\n    //\n    // Libtropic will then pass this structure to the CAL functions.\n    //\n    // IMPORTANT #1: The assignment below has to be done before calling\n    // lt_init() with the specific handle instance!\n    // IMPORTANT #2: One context structure cannot be shared among multiple\n    // handle instances!\n    h.l3.crypto_ctx = &amp;my_crypto_ctx;\n\n    // 7. Initialize the handle.\n    //\n    // This should be done only once for a specific handle.\n    // If you need to initialize the specific handle again, call lt_deinit()\n    // first.\n    lt_ret_t ret = lt_init(h);\n    if (LT_OK != ret) {\n        lt_deinit(h);\n        return -1;\n    }\n\n    // 8. Do your stuff.\n\n    // 9. Deinitialize the handle.\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre></p>"},{"location":"other/","title":"Other","text":"<p>This section provides additional information about libtropic that did not fit into the other sections.</p> <ul> <li>TROPIC01 Model</li> <li>Supported Host Platforms</li> <li>Supported Cryptographic Functionality Providers</li> </ul>"},{"location":"other/supported_cfps/","title":"Supported Cryptographic Functionality Providers","text":"<p>These are the currently supported CFPs (Cryptographic Functionality Providers):</p> <ul> <li>Crypto libraries:<ul> <li>Trezor Crypto</li> <li>MbedTLS</li> </ul> </li> </ul> <p>All CAL (Crypto Abstraction Layer) files can be found in the <code>libtropic/cal/</code> directory.</p> <p>Tip</p> <p>Cannot see your CFP in the list above? Refer to Adding a New Cryptographic Functionality Provider section with instructions on how to add support for it.</p>"},{"location":"other/supported_cfps/mbedtls/","title":"MbedTLS","text":"<p>Currently, we support the MbedTLS v4.0.0 and use the PSA Crypto API, which differs from the legacy MbedTLS API in several ways:</p> <ol> <li>Key Management: Keys are imported into PSA key store and referenced by key ID.</li> <li>Context Types: PSA uses opaque context structures (<code>psa_hash_operation_t</code>, etc.).</li> <li>Error Handling: Uses <code>psa_status_t</code> return codes.</li> <li>API Design: Higher-level, more abstract operations (e.g., <code>psa_aead_encrypt</code> vs manual GCM operations).</li> </ol> <p>CAL files of this port are available in the <code>libtropic/cal/mbedtls_v4/</code> directory.</p>"},{"location":"other/supported_cfps/mbedtls/#initialization-and-deinitialization","title":"Initialization and Deinitialization","text":"<p>Libtropic does not handle initialization and deinitialization of MbedTLS, this is the user's responsibility. Specifically, it is assumed that:</p> <ol> <li>psa_crypto_init() is called before the instance of the CAL is handed to Libtropic's <code>lt_init()</code>. See the Libtropic Bare-Bone Example for more information about the CAL instance.</li> <li>mbedtls_psa_crypto_free() is called in the user's application cleanup logic. Although freeing the MbedTLS's resources is not required by Libtropic, it cannot be called sooner than the last call of Libtropic's <code>lt_deinit()</code>, otherwise all Secure Channel Session related commands will return with errors.</li> </ol>"},{"location":"other/supported_cfps/mbedtls/#configuration","title":"Configuration","text":"<p>PSA Crypto must be configured with the following features:</p> <ul> <li><code>PSA_WANT_ALG_GCM</code> - AES-GCM authenticated encryption.</li> <li><code>PSA_WANT_ALG_SHA_256</code> - SHA-256 hashing.</li> <li><code>PSA_WANT_ALG_HMAC</code> - HMAC operations.</li> <li><code>PSA_WANT_ALG_ECDH</code> - X25519 key agreement.</li> <li><code>PSA_WANT_ECC_MONTGOMERY_255</code> - Curve25519 support.</li> <li><code>PSA_WANT_KEY_TYPE_AES</code> - AES key support.</li> <li><code>PSA_WANT_KEY_TYPE_HMAC</code> - HMAC key support.</li> <li><code>PSA_WANT_KEY_TYPE_ECC_KEY_PAIR</code> - ECC key pair support.</li> <li><code>PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY</code> - ECC public key support.</li> </ul>"},{"location":"other/supported_cfps/mbedtls/#implementation-notes","title":"Implementation Notes","text":""},{"location":"other/supported_cfps/mbedtls/#including-psa-crypto-headers","title":"Including PSA Crypto Headers","text":"<p>The MbedTLS headers contain some redundant declarations, see this issue on GitHub. As the errors are present in headers, not in the implementation files (.c), our strict compilation flags catch those problems, even though we restrict compilation with strict flags only to our own code. To keep ability to use this flag without triggering compilation errors due problems with PSA Crypto, we have to wrap <code>#include</code> like following: <pre><code>#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wredundant-decls\"\n#include \"psa/crypto.h\"\n#pragma GCC diagnostic pop\n</code></pre></p> <p>The pragmas will disable this flag only for the PSA Crypto code.</p>"},{"location":"other/supported_cfps/mbedtls/#macros","title":"Macros","text":"<p>MbedTLS does not define macros for all sizes we need, sometimes they define macros only inside their implementation files ad-hoc. As such, we opted to use some of our macros.</p>"},{"location":"other/supported_cfps/trezor_crypto/","title":"Trezor Crypto","text":"<p>Trezor Crypto is a cryptography library developed by Trezor and available as a part of the Trezor Firmware repository.</p> <p>CAL files of this port are available in the <code>libtropic/cal/trezor_crypto/</code> directory.</p> <p>Due to historical reasons and testing purposes, we have our own copy of the Trezor Crypto in the <code>vendor/</code> directory, as the Trezor Crypto is a part of a Trezor Firmware repository and does not use CMake.</p> <p>Trezor Crypto Version</p> <p>We strongly advise users that want to use Trezor Crypto in production applications to not use our out-of-date copy of Trezor Crypto inside <code>vendor/</code>, but use the version found in the Trezor Firmware repository instead and handle the dependency themselves.</p> <p>TROPIC01 PKI Chain Validation</p> <p>TROPIC01 PKI chain validation cannot be done using the Trezor Crypto only, additional crypto libraries have to be used. If you need to validate the chain, use other supported libraries that provide the required functionality.</p>"},{"location":"other/supported_host_platforms/","title":"Supported Host Platforms","text":"<p>These are the currently supported host platforms:</p> <ul> <li>STM32</li> <li>Linux</li> <li>POSIX</li> <li>Arduino</li> </ul> <p>All HAL files can be found in the <code>libtropic/hal/</code> directory.</p> <p>Tip</p> <p>Cannot see your platform in the list above? Refer to Adding a New Host Platform section with instructions on how to add a support for it.</p>"},{"location":"other/supported_host_platforms/arduino/","title":"Arduino","text":"<p>We provide a HAL which utilizes only the Arduino API, making it compatible with all Arduino platforms. The HAL is implemented in the <code>libtropic/hal/arduino/</code> directory.</p> <p>We also provide the libtropic-arduino repository, which follows the directory structure of Arduino libraries and implements support for PlatformIO. Refer to the repository for more information.</p> <p>Disclaimer</p> <p>The Arduino HAL is not suitable for production use. We strongly recommend using it for demo projects only.</p>"},{"location":"other/supported_host_platforms/linux/","title":"Linux","text":"<p>Libtropic support on Linux is implemented with:</p> <ul> <li>SPI and GPIO Linux Userspace API</li> </ul> <p>HALs for these ports are available in the <code>libtropic/hal/linux/</code> directory.</p> <p>Libtropic example usage with these ports is currently available in our libtropic-linux repository.</p>"},{"location":"other/supported_host_platforms/linux/#spi-and-gpio-linux-userspace-api","title":"SPI and GPIO Linux Userspace API","text":"<p>This port uses the SPI and GPIO Linux Userspace API. It was tested on:</p> <ul> <li>Raspberry Pi 4,</li> <li>Raspberry Pi 5.</li> </ul>"},{"location":"other/supported_host_platforms/posix/","title":"POSIX","text":"<p>We provide the following ports, which should be compatible with most POSIX compliant operating systems:</p> <ul> <li>TCP</li> <li>Tropic Square TS1302 USB Devkit</li> </ul> <p>HALs for these ports are available in the <code>libtropic/hal/posix/</code> directory.</p> <p>Libtropic example usage with some of these ports is currently available in our libtropic-linux repository. Other operating systems were not tested.</p>"},{"location":"other/supported_host_platforms/posix/#tcp","title":"TCP","text":"<p>We use this port with the TROPIC01 Python Model, which acts as a server, to which libtropic connects via the specified TCP port.</p> <p>Disclaimer</p> <p>The TCP HAL is implemented with consideration of the following:</p> <ol> <li>It is primarily targeted for use with the TROPIC01 Python Model.</li> <li>To ensure reproducibility of randomized functional tests, the rand function is used in the <code>lt_port_random_bytes</code> function with a known random seed instead of more cryptographically secure solutions.</li> </ol> <p>Interrupt Pin Support</p> <p>The TCP HAL does not support TROPIC01's interrupt pin.</p>"},{"location":"other/supported_host_platforms/posix/#tropic-square-ts1302-usb-devkit","title":"Tropic Square TS1302 USB Devkit","text":"<p>Libtropic communicates with this devkit using the USB protocol. Refer to the TS1302 USB Devkit GitHub page for more information about it.</p> <p>Raspberry Pi 4 Issues</p> <p>When testing with Raspberry Pi 4, we have encountered issues with its USB, which seems to lose some of the USB packets sent to it.</p> <p>Raspberry Pi 5</p> <p>Fortunately, Raspberry Pi 5 fixes these issues and the TS1302 USB Devkit works without any issues.</p> <p>Interrupt Pin Support</p> <p>The TS1302 USB Devkit port does not support TROPIC01's interrupt pin.</p>"},{"location":"other/supported_host_platforms/stm32/","title":"STM32","text":"<p>Currently supported STM32 platforms are:</p> <ul> <li>NUCLEO-F439ZI</li> <li>NUCLEO-L432KC</li> </ul> <p>HALs for these ports are available in the <code>libtropic/hal/stm32/</code> directory.</p> <p>Libtropic example usage of these platforms is currently available in our libtropic-stm32 repository.</p>"},{"location":"other/supported_host_platforms/stm32/#nucleo-f439zi","title":"NUCLEO-F439ZI","text":"<p>Fully working.</p> <p>Interrupt Pin Support</p> <p>Support for the TROPIC01's interrupt pin is implemented but not tested.</p>"},{"location":"other/supported_host_platforms/stm32/#nucleo-l432kc","title":"NUCLEO-L432KC","text":"<p>Limited Support</p> <p>Consider this platform as not supported. The HAL is implemented, but very outdated. Support for this platform is planned to be removed.</p>"},{"location":"other/tropic01_model/","title":"TROPIC01 Model","text":"<p>The CMake project in the <code>tropic01_model/</code> directory builds libtropic so it can communicate with the TROPIC01 Python model. The CMake project offers the following:</p> <ol> <li>Running libtropic's Functional Tests. The testing is managed by CTest \u2014 it executes both the test and the model automatically, along with the creation of model configuration.</li> <li>Running libtropic's Examples.</li> <li>Supports most of the Libtropic's Available CMake Options \u2014 they will be propagated to Libtropic's CMake by the model's CMake.</li> <li>Additional CMake configuration options:<ul> <li><code>LT_STRICT_COMPILATION</code> (boolean, default value: <code>ON</code>): Enables strict compilation flags.</li> <li><code>LT_ASAN</code> (boolean, default value: <code>OFF</code>): Enables static AddressSanitizer.</li> <li><code>LT_VALGRIND</code> (boolean, default value: <code>OFF</code>): CTest runs the binaries with Valgrind.</li> <li><code>LT_CAL</code> (string): Flexible switching between the implemented CALs (Crypto Abstraction Layers).</li> <li><code>LAB_BATCH_PKG_DIR</code> (string, default value: latest available lab batch package): Path to the latest lab batch package to use for configuring the model (refer to Provisioning Data for more information).</li> <li><code>LT_MODEL_RISCV_FW_VER</code> (string, default value: latest available TROPIC01's RISC-V FW version): RISC-V FW version to be configured in the model (does not affect behavior of the model).</li> </ul> </li> </ol> <p>Incompatibility With Some Examples</p> <p>Some examples are not compatible with the model because the model does not implement all of the chip's functionality. Those examples will always fail against the model and are therefore excluded in <code>tropic01_model/CMakeLists.txt</code>. Namely:</p> <ul> <li><code>lt_ex_fw_update</code>,</li> <li><code>lt_ex_show_chip_id_and_fwver</code> (the model does not implement Bootloader mode, so you can use <code>tests/functional/lt_test_rev_get_info_req_app.c</code> to get this info from Application mode instead).</li> </ul> <p>Symlink to Libtropic</p> <p>There is a symlink to a parent directory in the <code>tropic01_model</code> directory. This is required for coverage collection to work, as CMake does not include any files above the source directory in the coverage by default.</p>"},{"location":"other/tropic01_model/#how-it-works","title":"How it Works?","text":"<p>The <code>tropic01_model/CMakeLists.txt</code> uses the TCP HAL implemented in <code>hal/posix/tcp/libtropic_port_posix_tcp.c</code>, so both processes (the compiled binary and the model) communicate through a TCP socket at 127.0.0.1:28992. The SPI layer between libtropic and the model is emulated through this TCP connection. The model responses match those of the physical TROPIC01 chip.</p>"},{"location":"other/tropic01_model/#model-setup","title":"Model Setup","text":"<p>First, install the model by following the README in the ts-tvl repository.</p> <p>Next, you can initialize the model with data so it behaves like a real provisioned chip. To do that, pass a YAML configuration file to the model \u2014 see the Model Server and Model Configuration sections in the ts-tvl repository. To create such a YAML configuration, use the <code>tropic01_model/create_model_cfg.py</code> script in the libtropic repository (example usage follows).</p> <p>When to Handle Model Configuration?</p> <p>When running tests using CTest, no manual steps for creating the model configuration or initializing the model are necessary \u2014 CTest handles this. When running examples (or tests without CTest), start the model manually and apply a configuration so at least pairing key slot 0 is written to enable establishing a Secure Channel Session.</p> <p>Data, from which the <code>tropic01_model/create_model_cfg.py</code> script creates the YAML configuration file for the model, can be found in <code>tropic01_model/provisioning_data/</code> directory - see Provisioning Data section for more information about the directory structure.</p> <p>To create a model configuration that will initialize the model to the state which is almost identical to the provisioned chip, the <code>tropic01_model/create_model_cfg.py</code> script is run as: <pre><code>cd tropic01_model/\npython3 create_model_cfg.py --pkg-dir &lt;path_to_the_lab_batch_package_directory&gt;\n</code></pre> where <code>&lt;path_to_the_lab_batch_package_directory&gt;</code> is the path to one of the lab batch packages inside <code>tropic01_model/provisioning_data/</code>. Running the script creates a file named <code>model_cfg.yml</code>, which can be passed directly to the model using the <code>-c</code> flag.</p>"},{"location":"other/tropic01_model/#running-the-examples","title":"Running the Examples","text":"<ol> <li>Switch to the <code>tropic01_model/</code> directory: <pre><code>cd tropic01_model/\n</code></pre></li> <li> <p>Compile the examples with the selected CAL (e.g. for MbedTLS v4.0.0): <pre><code>mkdir build\ncd build\ncmake -DLT_BUILD_EXAMPLES=1 -DLT_CAL=\"mbedtls_v4\" ..\nmake\n</code></pre> As a result, executables for each example are built in the <code>tropic01_model/build/</code> directory.</p> Tip: CMake Options for Debugging <p>To enable debugging symbols (e.g. to use GDB), add switch <code>-DCMAKE_BUILD_TYPE=Debug</code> when executing <code>cmake</code>.</p> <p>To use AddressSanitizer (ASan), add switches <code>-DCMAKE_BUILD_TYPE=Debug</code> and <code>-DLT_ASAN=1</code> when executing <code>cmake</code>.</p> </li> <li> <p>Create a YAML configuration for the model from one of the lab batch packages: <pre><code>python3 ../create_model_cfg.py --pkg-dir ../provisioning_data/2025-06-27T07-51-29Z__prod_C2S_T200__provisioning__lab_batch_package/\n</code></pre> As a result, <code>model_cfg.yml</code> is created.</p> </li> <li> <p>In a separate terminal, start the model server (which was previously installed in a Python virtual environment) and configure it: <pre><code>model_server tcp -c model_cfg.yml\n</code></pre> As a result, the model now listens on TCP port 127.0.0.1:28992.</p> </li> <li> <p>In the original terminal, execute one of the built examples: <pre><code>./lt_ex_hello_world\n</code></pre> As a result, you should see an output from the example in the original terminal and a log from the model in the separate terminal.</p> </li> </ol>"},{"location":"other/tropic01_model/#running-the-tests","title":"Running the Tests","text":"<p>Info</p> <p>It is recommended to run the tests using CTest, but if it's needed to run the tests under GDB, they can be run exactly the same way as the examples.</p> <ol> <li>Switch to the <code>tropic01_model/</code> directory: <pre><code>cd tropic01_model/\n</code></pre></li> <li> <p>Compile the tests with the selected CAL (e.g. for MbedTLS v4.0.0): <pre><code>mkdir build\ncd build\ncmake -DLT_BUILD_TESTS=1 -DLT_CAL=\"mbedtls_v4\" ..\nmake\n</code></pre> As a result, executables for each test are built in the <code>tropic01_model/build/</code> directory.</p> Tip: CMake Options for Debugging <p>To enable debugging symbols (e.g. to use GDB), add switch <code>-DCMAKE_BUILD_TYPE=Debug</code> when executing <code>cmake</code>.</p> <p>To use AddressSanitizer (ASan), add switches <code>-DCMAKE_BUILD_TYPE=Debug</code> and <code>-DLT_ASAN=1</code> when executing <code>cmake</code>.</p> <p>To execute the tests with Valgrind, add switches <code>-DCMAKE_BUILD_TYPE=Debug</code> and <code>-DLT_VALGRIND=1</code> when executing <code>cmake</code>. Note that Valgrind will be executed automatically only when using CTest!</p> </li> <li> <p>Now, the tests can be run using CTest. To see available tests, run: <pre><code>ctest -N\n</code></pre> To select specific test(s) using regular expression, run: <pre><code>ctest -R &lt;test_regex&gt;\n</code></pre> where <code>&lt;test_regex&gt;</code> is a regular expression for the test names from the list.</p> </li> </ol> <p>To run all tests, simply run: <pre><code>ctest\n</code></pre></p> <p>Tip: Verbose Output From CTest</p> <p>To enable verbose output from CTest, run <code>ctest -V</code> or <code>ctest -W</code> switch for even more verbose output.</p> <p>To exclude some tests, run: <pre><code>ctest -E &lt;test_regex&gt;\n</code></pre> where <code>&lt;test_regex&gt;</code> is a regular expression for the test names from the list.</p> <p>After CTest finishes, it informs about the results and saves all output to the <code>tropic01_model/build/run_logs/</code> directory. Output from the tests and responses from the model are saved.</p> <p>Info</p> <p>The model is automatically started for each test separately, so it behaves like a fresh TROPIC01 straight out of factory. All this and other handling is done by the script <code>scripts/model_runner.py</code>, which is called by CTest.</p> Problems with Secure Channel Session Due to Custom Model Configuration <p>Based on the TROPIC01 model configuration, you may encounter issues with tests or examples that establish a Secure Session. Examples and tests use production keys by default - see Default Pairing Keys in Libtropic for more information.</p> <p>If you configured the model's pairing key slot 0 with engineering sample keys, you have to pass <code>-DLT_SH0_KEYS=\"eng_sample\"</code> to <code>cmake</code> during the build.</p> <p>If you configured the model's pairing key slot 0 with some other keys, define the arrays for your private and public key as global and after <code>#include libtropic_examples.h</code> (or <code>#include libtropic_functional_tests.h</code>), do the following: <pre><code>// Substitute LT_EX_SH0_PRIV for LT_TEST_SH0_PRIV in the case of test source file\n#undef LT_EX_SH0_PRIV\n#define LT_EX_SH0_PRIV &lt;var_name_with_your_private_pairing_key&gt;\n\n// Substitute LT_EX_SH0_PUB for LT_TEST_SH0_PUB in the case of test source file\n#undef LT_EX_SH0_PUB\n#define LT_EX_SH0_PUB &lt;var_name_with_your_public_pairing_key&gt;\n</code></pre></p>"},{"location":"other/tropic01_model/#running-the-tests-with-coverage","title":"Running the Tests with Coverage","text":"<p>We support coverage collection for testing against the model. To activate coverage collection, add switch <code>-DLT_TEST_COVERAGE=1</code> when executing <code>cmake</code>, for example: <pre><code>cmake -DLT_BUILD_TESTS=1 -DLT_TEST_COVERAGE=1 -DLT_CAL=\"mbedtls_v4\" ..\n</code></pre></p> <p>After CTest finishes, you can use gcovr to export results: <pre><code># Execute this from the tropic01_model/ directory!\ngcovr --txt coverage_report.txt --exclude 'build/_deps/.*|\\.\\./tests/.*|\\.\\./vendor/.*'\n</code></pre></p> <p>We use the following parameters:</p> <ul> <li><code>--gcov-exclude</code> excludes selected files from report - we are not interested in measuring coverage of the tests themselves,</li> <li><code>--txt</code> chooses text output format.</li> </ul> <p>Tip: Gcovr Output Formats</p> <p>You can use <code>--html</code> or <code>--html-details</code> output options to export in a HTML format or <code>--markdown</code> to export in a Markdown format. Check out gcovr user guide.</p>"},{"location":"other/tropic01_model/provisioning_data/","title":"Provisioning Data","text":"<p>The <code>tropic01_model/provisioning_data/</code> directory contains so-called lab batch packages, which are data used for provisioning TROPIC01 chips in the Tropic Square lab for testing purposes. In Libtropic, these lab batch packages are used for configuring the TROPIC01 Model. </p> <p>Note</p> <p>Lab batch packages in this directory are stripped \u2014 they contain only the data needed by libtropic.</p>"},{"location":"other/tropic01_model/provisioning_data/#lab-batch-package-contents","title":"Lab Batch Package Contents","text":"<p>For example, the <code>2025-06-27T07-51-29Z__prod_C2S_T200__provisioning__lab_batch_package/</code> lab batch package:</p> <ol> <li><code>cert_chain/</code>: All certificates for the Certificate Store (excluding TROPIC01's eSE device certificate, which is originally not part of the lab batch package and can be found outside the <code>cert_chain/</code> directory).</li> <li><code>i_config/</code>, <code>r_config/</code>: Contains fields that should be written \u2014 currently not used.</li> <li><code>sh0_key_pair/</code>: Contains the public and private key for pairing key slot 0 (SH0PUB, SH0PRIV).</li> <li><code>tropic01_ese_certificate.pem</code>: TROPIC01's eSE device certificate.</li> <li><code>tropic01_ese_private_key.pem</code>: TROPIC01's eSE device private key (STPRIV).</li> </ol>"}]}