{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the documentation page for libtropic!</p> <p>Libtropic is a C-based Software Development Kit (SDK) developed by Tropic Square. Designed for seamless integration, it offers a user-friendly, high-level API that enables host platforms to easily interface with the TROPIC01 secure element.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Get Started: All the things you need to get started with libtropic.</li> <li>API Reference: Detailed libtropic API documentation generated with Doxygen.</li> <li>For Contributors: If you need more information on libtropic to start developing or contributing.</li> <li>Other: Even more information about libtropic.</li> </ul>"},{"location":"doxygen/mainpage/","title":"Introduction","text":"<p>Welcome to the documentation for the libtropic API!</p> <p>For more information about libtropic, visit the libtropic repository.</p>"},{"location":"doxygen/mainpage/#documentation-structure","title":"Documentation Structure","text":"<p>The documentation is organized into the following sections:</p> <ul> <li>Introduction: This page.</li> <li>Topics: Detailed documentation of macros, functions, and data structures, organized by the individual components of the libtropic SDK.</li> <li>Data Structures: A comprehensive overview and index of all available data structures in the libtropic SDK.</li> <li>Files: A list of all header files included in the SDK, along with their descriptions.</li> </ul> <p>We hope this documentation helps you make the most of the libtropic SDK. If you have any questions or need further assistance, please refer to the repository, or, if you are a customer, contact the support team.</p>"},{"location":"for_contributors/","title":"For Contributors","text":"<ul> <li>Contributing Guide</li> <li>Functional Tests</li> <li>Adding a New Embedded Platform</li> <li>Adding a New Cryptographic Backend</li> <li>Building the Documentation</li> </ul>"},{"location":"for_contributors/adding_crypto_backend/","title":"Adding a New Cryptographic Backend","text":"<p>As libtropic was designed with extensibility in mind, it is possible to add a new backend for the cryptographic operations.</p>"},{"location":"for_contributors/adding_crypto_backend/#requirements","title":"Requirements","text":"<p>The new cryptographic backend has to support the following schemes:</p> <ul> <li>AES (GCM)<ul> <li>encryption</li> <li>decryption</li> </ul> </li> <li>ECDSA<ul> <li>signing</li> </ul> </li> <li>ED25519<ul> <li>signing</li> </ul> </li> <li>SHA256<ul> <li>hashing</li> </ul> </li> <li>Curve25519<ul> <li>multiplication on both arbitrary and base point</li> </ul> </li> </ul>"},{"location":"for_contributors/adding_crypto_backend/#guide","title":"Guide","text":"<p>To add a new cryptographic backend (let's say <code>mycrypto</code>):</p> <ol> <li>Create and Implement the Necessary Files, </li> <li>Edit the Main CMakeLists.txt.</li> </ol>"},{"location":"for_contributors/adding_crypto_backend/#create-and-implement-the-necessary-files","title":"Create and Implement the Necessary Files","text":"<ol> <li>Inside <code>hal/crypto/</code>, create a new directory called <code>mycrypto</code>.</li> <li>Inside <code>hal/crypto/mycrypto/</code>, create the following source files:<ul> <li><code>lt_crypto_mycrypto_aesgcm.c</code>,</li> <li><code>lt_crypto_mycrypto_ecdsa.c</code>,</li> <li><code>lt_crypto_mycrypto_ed25519.c</code>,</li> <li><code>lt_crypto_mycrypto_sha256.c</code>,</li> <li><code>lt_crypto_mycrypto_hmac_sha256.c</code>,</li> <li><code>lt_crypto_mycrypto_x25519.c</code>.</li> </ul> </li> <li> <p>In each of the source files, implement all required functions - they are declared in respective headers inside the <code>src/</code> directory:</p> <ul> <li><code>lt_aesgcm.h</code>: AES-GCM functions,</li> <li><code>lt_ecdsa.h</code>: ECDSA functions,</li> <li><code>lt_ed25519.h</code>: ED25519 functions,</li> <li><code>lt_sha256.h</code>: SHA256 functions,</li> <li><code>lt_hmac_sha256.h</code>: HMAC SHA256 functions,</li> <li><code>lt_x25519.h</code>: Curve25519 functions.</li> </ul> <p>Look into each header - the exact purpose of every function is described in its comment. Copy the function declarations from the headers to the source files and implement the functions.</p> <p>Example</p> <p>To implement Curve25519 functions, copy declarations from <code>lt_x25519.h</code> to <code>lt_crypto_mycrypto_x25519.c</code> and provide implementations. You can use existing ports inside <code>hal/crypto/</code> for inspiration.</p> </li> </ol>"},{"location":"for_contributors/adding_crypto_backend/#edit-the-main-cmakeliststxt","title":"Edit the Main CMakeLists.txt","text":"<p>The cryptographic provider is selected using the <code>LT_CRYPTO</code> CMake option - a string, specifying the provider, is expected. Currently, <code>trezor_crypto</code> is the only available provider.</p> <p>The following steps describe how the <code>CMakeLists.txt</code> has to be edited to add support for the new cryptographic provider:</p> <ol> <li>In the <code>Collect files</code> section, add the new source files to the compilation process. Use the following template, modify it accordingly, and paste it above the <code># --- add new crypto sources above this line ---</code> comment: <pre><code>set(SDK_SRCS ${SDK_SRCS}\n    ${CMAKE_CURRENT_SOURCE_DIR}/hal/crypto/mycrypto/lt_crypto_mycrypto_aesgcm.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hal/crypto/mycrypto/lt_crypto_mycrypto_ed25519.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hal/crypto/mycrypto/lt_crypto_mycrypto_ecdsa.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hal/crypto/mycrypto/lt_crypto_mycrypto_sha256.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hal/crypto/mycrypto/lt_crypto_mycrypto_hmac_sha256.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hal/crypto/mycrypto/lt_crypto_mycrypto_x25519.c\n)\n</code></pre></li> </ol> <p>At the end of <code>CMakeLists.txt</code>, in the section <code># LT_CRYPTO handling</code> do the following:</p> <ol> <li>Add the new provider to the <code>CRYPTO_PROVIDERS</code> list: <pre><code># Supported crypto providers\nset(CRYPTO_PROVIDERS \"trezor_crypto\" \"mycrypto\")\n</code></pre></li> <li>Define new internal macro: <pre><code># These are internal macros for crypto providers\nset(LT_CRYPTO_TREZOR   0 CACHE INTERNAL \"\")\nset(LT_CRYPTO_MYCRYPTO 0 CACHE INTERNAL \"\") # &lt;-- new addition\n</code></pre></li> <li>Add new <code>elseif()</code> in the <code>LT_CRYPTO</code> handling: <pre><code># Handle LT_CRYPTO\nif(LT_CRYPTO STREQUAL \"trezor_crypto\")\n\n    # ... trezor_crypto handling ...\n\n# --- start of new additions ---\nelseif(LT_CRYPTO STREQUAL \"mycrypto\")\n\n    message(STATUS \"Crypto provider set to mycrypto\")\n    set(LT_CRYPTO_MYCRYPTO 1)\n\n    add_subdirectory(vendor/mycrypto/ \"mycrypto\")\n    target_compile_definitions(mycrypto PRIVATE &lt;edit_me&gt;) # Edit or remove.\n    target_link_libraries(tropic PRIVATE mycrypto)\n    # Add more lines if necessary.\n\n# --- end of new additions ---\nelse()\n    # ...\nendif()\n</code></pre></li> <li>Propagate the new internal macro <code>LT_CRYPTO_MYCRYPTO</code>: <pre><code># Propagate crypto provider internal switches\ntarget_compile_definitions(tropic PUBLIC\n    LT_CRYPTO_TREZOR=${LT_CRYPTO_TREZOR}\n    LT_CRYPTO_MYCRYPTO=${LT_CRYPTO_MYCRYPTO}\n)\n</code></pre></li> </ol>"},{"location":"for_contributors/adding_embedded_platform/","title":"Adding a New Embedded Platform","text":"<p>Libtropic is written as platform-independent, so no changes to the main code base are needed when adding a support for a new platform. However, to define how the communication on the L1 Layer will work, a new HAL (Hardware Abstract Layer) has to be implemented. Currently available HALs are located in <code>hal/port/</code>.</p>"},{"location":"for_contributors/adding_embedded_platform/#guide","title":"Guide","text":"<p>To create a new HAL:</p> <ol> <li>Create and Implement the Necessary Files,</li> <li>Use the New HAL.</li> </ol> <p>Tip</p> <p>For inspiration, see existing HALs inside <code>hal/port/</code>.</p>"},{"location":"for_contributors/adding_embedded_platform/#create-and-implement-the-necessary-files","title":"Create and Implement the Necessary Files","text":"<ol> <li>Inside <code>hal/port/</code>, create a new directory, for example called <code>newplatform</code>.  <p>Note</p> <p>The platform directory inside <code>hal/port/</code> might already exist, so you do not have to create a new one, just use the existing one (e.g. <code>stm32</code>).</p> </li> <li>Inside <code>hal/port/newplatform</code>, create two new files, where <code>&lt;additional_info&gt;</code> can be a name of the board or the protocol name used (e.g. <code>spi</code>, <code>tcp</code>, ...):<ul> <li><code>libtropic_port_newplatform_&lt;additional_info&gt;.h</code>,</li> <li><code>libtropic_port_newplatform_&lt;additional_info&gt;.c</code>.</li> </ul> </li> <li>Inside <code>libtropic_port_newplatform_&lt;additional_info&gt;.h</code>, declare:<ol> <li>a new device structure with public and private members in a following way: <pre><code>typedef struct lt_dev_newplatform_&lt;additional_info&gt; {\n    // Public part\n    /** @brief @public first public member comment */\n    // ...\n    /** @brief @public n-th public member comment */\n\n    // Private part\n    /** @brief @private first private member comment */\n    // ...\n    /** @brief @private n-th pivate member comment */\n} lt_dev_newplatform_&lt;additional_info&gt;;\n</code></pre> These members are usually physical pin numbers, SPI handles or other information needed in the HAL functions, handling the platform-specific interface on the L1 Layer.</li> <li>additional macros or types you will need in <code>libtropic_port_newplatform_&lt;additional_info&gt;.c</code>.</li> </ol> </li> <li>Inside <code>libtropic_port_newplatform_&lt;additional_info&gt;.c</code>, implement:<ol> <li>all functions declared in <code>include/libtropic_port.h</code>. All of the port functions have an instance of <code>lt_l2_state_t</code> as one of the parameters, where your device structure from 3.a. will be saved, so you can get it in a following way: <pre><code>// one of the functions from include/libtropic_port.h\nlt_ret_t lt_port_spi_csn_high(lt_l2_state_t *s2)\n{\n    lt_dev_newplatform_&lt;additional_info&gt; *device =\n        (lt_dev_newplatform_&lt;additional_info&gt; *)(s2-&gt;device);\n\n    // Your implementation ...\n\n    return LT_OK;\n}\n</code></pre></li> <li>additional <code>static</code> functions you might need.</li> </ol> </li> </ol>"},{"location":"for_contributors/adding_embedded_platform/#use-the-new-hal","title":"Use the New HAL","text":"<ol> <li>Add the new HAL files inside your <code>CMakeLists.txt</code> or <code>Makefile</code> - see Adding to an Existing Project section for an inspiration.</li> <li>Initialize and use the new HAL in your code: <pre><code>#include \"libtropic_port_newplatform_&lt;additional_info&gt;.h\"\n#include \"libtropic_common.h\"\n\nint main(void) {\n    lt_handle_t h = {0}; // Libtropic's handle.\n    lt_dev_newplatform_&lt;additional_info&gt; my_device;\n    // Initialize the device structure.\n    my_device.first_member = \"some value for the first member\";\n    my_device.nth_member = \"some value for the n-th member\";\n    // Save a pointer to `my_device` inside the libtropic's handle,\n    // so you can get it in the port functions.\n    h.l2.device = &amp;my_device;\n\n    // Initialize the handle.\n    lt_ret_t ret = lt_init(h);\n    if (LT_OK != ret) {\n        lt_deinit(h);\n        return -1;\n    }\n\n    // Do your stuff ...\n\n    // Deinitialize the handle after you are done.\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre></li> </ol>"},{"location":"for_contributors/building_documentation/","title":"Building the Documentation","text":"<p>Libtropic documentation is built using the two following frameworks, each building a different part of the documentation:</p> <ol> <li>MkDocs, used to generate the pages you are seeing right now,</li> <li>Doxygen, used to generate the API Reference from the libtropic source code.</li> </ol> <p>Normally, you should not need to build the documentation yourself - it is available on our GitHub Pages, where versions for the master branch and all releases are automatically built and released by our GitHub Actions. However, in the case of contributing to the documentation, it is handy to be able to build it locally and preview the new changes. Refer to the following sections for steps on how to do that.</p>"},{"location":"for_contributors/building_documentation/#installation-of-the-dependencies","title":"Installation of the Dependencies","text":"<p>Important</p> <p>Before proceeding, you need to have Python 3.x installed on your system.</p> <p>To install MkDocs, do the following:</p> <ol> <li>We recommend creating a Python Virtual Environment, for example with a name <code>.docs-venv</code>: <pre><code>python3 -m venv .docs-venv\nsource .docs-venv/bin/activate\n</code></pre></li> <li>Update <code>pip</code> and install the needed <code>pip</code> packages using <code>docs/requirements.txt</code>: <pre><code>pip install --upgrade pip\npip install -r docs/requirements.txt\n</code></pre></li> </ol> <p>After that, install Doxygen and Graphviz (used for the diagrams) - installation depends on your system, but we will use Ubuntu in this example: <pre><code>sudo apt-get install doxygen graphviz\n</code></pre></p>"},{"location":"for_contributors/building_documentation/#building-with-doxygen","title":"Building with Doxygen","text":"<p>First, the API Reference has to be built using Doxygen:</p> <ol> <li>Switch to <code>docs/doxygen/</code>: <pre><code>cd docs/doxygen/\n</code></pre></li> <li>Build: <pre><code>doxygen Doxyfile.in\n</code></pre></li> </ol> <p>The API Reference should be now built in <code>docs/doxygen/build/html/</code>.</p> <p>Note</p> <p>These steps have to be done each time the contents of <code>docs/doxygen/</code> change and you want to preview the changes.</p>"},{"location":"for_contributors/building_documentation/#building-with-mkdocs","title":"Building with MkDocs","text":"<p>MkDocs has the ability to run a builtin development server on localhost, where the documentation is automatically deployed. To run it, switch to the root libtropic directory, where <code>mkdocs.yml</code> is located, and run: <pre><code>mkdocs serve\n</code></pre> In the terminal, you should see the address of the server. While holding CTRL, left-click the address to open it in your browser (or just manually copy it).</p> <p>Warning</p> <p>MkDocs does not rebuilt the Doxygen documentation automatically - to rebuild it, repeat the steps from section Building with Doxygen.</p> <p>Tip</p> <p>Each time you edit some files inside <code>docs/</code>, the server does not have to be stopped and run again - the server content will be automatically reloaded on each file save.</p>"},{"location":"for_contributors/building_documentation/#versioned-documentation","title":"Versioned Documentation","text":"<p>When you build the documentation using the steps from the section Building with MkDocs, the version selector in the page header is not visible as it is on our GitHub Pages. That is because for the versioning, we use the mike plugin for MkDocs. This plugin maintains the <code>gh-pages</code> branch, from which the GitHub Pages are deployed.</p>"},{"location":"for_contributors/building_documentation/#previewing-the-versioned-documentation","title":"Previewing the Versioned Documentation","text":"<p>The most common and safe use case is to locally preview the state of the documentation that is deployed to our GitHub Pages. Do the following steps to achieve that:</p> <ol> <li>Make sure you have the latest version of the <code>gh-pages</code> branch from <code>origin</code>: <pre><code>git fetch origin\ngit pull origin gh-pages\n</code></pre> Do not <code>git checkout gh-pages</code>, because you will not be able to build the documentation there. Do <code>git checkout</code> with <code>master</code>, <code>develop</code> or any other branch based from one of these.</li> <li>Run a builtin development server with the contents of <code>gh-pages</code>: <pre><code>mike serve\n</code></pre> In the terminal, you should see the address of the server. While holding CTRL, left-click the address to open it in your browser (or just manually copy it).</li> </ol>"},{"location":"for_contributors/building_documentation/#editing-the-versioned-documentation","title":"Editing the Versioned Documentation","text":"<p>Danger</p> <p>Some of the following commands change the state of the local <code>git</code> repository, specifically the <code>gh-pages</code> branch, and possibly the <code>origin</code> remote!</p> <p>If you need to locally deploy a new version and preview it, you have to modify the <code>gh-pages</code> branch. To do that, run: <pre><code>mike deploy &lt;version_name&gt;\n</code></pre> After running this, <code>gh-pages</code> branch will be created (if it does not already exist) and the generated documentation will be pushed to it.</p> <p>Danger</p> <p>If you add the <code>--push</code> flag, the <code>gh-pages</code> branch will be pushed to <code>origin</code> - we do not recommend doing that! This applies to most of the <code>mike</code> commands.</p> <p>To see all existing versions, run: <pre><code>mike list\n</code></pre></p> <p>Note</p> <p>This command is safe - it does not change <code>gh-pages</code> branch.</p> <p>To remove a specific version, run: <pre><code>mike delete \n</code></pre> There are more commands available - refer to the mike repository for more information.</p>"},{"location":"for_contributors/contributing_guide/","title":"Contributing Guide","text":"<p>We love contributions! To make contributing simple for both sides, please:</p> <ul> <li>Open an issue and describe how you would like to contribute and discuss details with us.</li> <li>Create a branch from the develop branch and do the changes:<ul> <li>Make sure to follow specifics in our Coding Style.</li> <li>Make sure to use Code Formatter, otherwise the PR check will fail and cannot be merged.</li> <li>Make sure the branch passes Tests against model -- otherwise, the PR check will fail.</li> <li>Make sure to run Static Analysis.</li> <li>Make sure your Commit Messages follow our guidelines.</li> </ul> </li> <li>Create pull request.</li> </ul>"},{"location":"for_contributors/contributing_guide/#coding-style","title":"Coding Style","text":""},{"location":"for_contributors/contributing_guide/#structures-and-enums","title":"Structures and Enums","text":"<p>In the public API (<code>include/</code>), we define structured types and enumerations using <code>typedef</code>. We do NOT omit structure (enum) name, to keep possibility to declare using <code>struct</code>/<code>enum</code> keywords. Example:</p> <pre><code>typedef struct my_struct {\n    ...\n} my_struct;\n\ntypedef enum my_enum {\n    ...\n} my_enum;\n</code></pre> <p>Anywhere else, we do not use typedefs.</p>"},{"location":"for_contributors/contributing_guide/#code-formatter","title":"Code Formatter","text":"<p>We use the <code>clang-format</code> tool for code formatting. Its installation varies dependening on the linux distribution. </p> <p>Important</p> <p>We recommend using version 16 or higher.</p> <p>To check if <code>clang-format</code> is available on your machine, run: <pre><code>clang-format --version\n</code></pre></p> <p>We use <code>clang-format</code> to check code format on pushes and PRs into the master and develop branches - this is implemented in the action <code>.github/clang_format_check.yml</code>. It only checks the format and does not fix it - that is the contributor's responsibility.</p>"},{"location":"for_contributors/contributing_guide/#how-to-use-it","title":"How to Use It","text":"<p>There are multiple ways to format the code using <code>clang-format</code>:</p> <ol> <li>For each file with wrong formatting, run: <pre><code>clang-format -i &lt;path_to_the_file_to_format&gt;\n</code></pre></li> <li>If you are using VSCode and the <code>cpptools</code> extension, you can create <code>.vscode/settings.json</code> with the following contents (if it does not already exist): <pre><code>{ // Add this bracket only if your settings.json file is empty\n    \"[c]\": {\n        \"editor.defaultFormatter\": \"ms-vscode.cpptools\",\n        \"editor.formatOnSave\": true\n    },\n    \"C_Cpp.formatting\": \"clangFormat\"\n} // Add this bracket only if your settings.json file is empty\n</code></pre> This will format the file on each save.</li> <li>There is also the <code>git-clang-format</code> tool, which integrates <code>clang-format</code> with <code>git</code>, but we have not used that yet.</li> <li>Possibly other ways...</li> </ol>"},{"location":"for_contributors/contributing_guide/#static-analysis","title":"Static Analysis","text":"<p>To run static analysis, follow these steps:</p> <ol> <li>Choose a static analysis tool (e.g., cppcheck, clang-tidy).</li> <li>Configure the tool to analyze the library code.</li> <li>Run the analysis and review the reported issues.</li> </ol>"},{"location":"for_contributors/contributing_guide/#commit-messages","title":"Commit Messages","text":"<p>Our commit message format is inspired by Conventional Commits guidelines.</p> <p>The commit messages should fulfill the following: <pre><code>&lt; type &gt;[ optional scope ]: &lt; description &gt;\n[ optional JIRA REF ]\n[ optional body ]\n[ optional footer ( s ) ]\n</code></pre></p> <p>Where the meaning of individual \ufb01elds is:</p> <pre><code>&lt;type&gt; - Type of commit. Can be one of following:\n    - feat     - A new feature.\n    - build    - A change to build or compile scripts.\n    - ci       - A change to continuous integration setup and scripting.\n    - doc      - A change to documentation.\n    - refactor - A refactoring of code. Shall not change functionality.\n    - test     - A change in tests or test-bench environment.\n    - \ufb01x       - Fix of incorrect functionality.\n    - perf     - Performance enhancement.\n    - deps     - A change to dependency settings\n\n&lt;description&gt;  - Part of the repository or \ufb02ow where the change is made. The \ufb01rst line of the commit message shall be at most 72 characters long.\n\nscope          - Optional part of the repository or \ufb02ow where the change is made.\n\nJIRA REF       - Optional reference to a JIRA issue\n\nbody           - Optional arbitrary number of paragraphs describing what the commit does.\n\nfooter         - Optional footer (see https://www.conventionalcommits.org/en/v1.0.0/#specification)\n</code></pre>"},{"location":"for_contributors/functional_tests/","title":"Functional Tests","text":"<p>Functional tests are used to verify the libtropic core API and are implemented in <code>tests/functional/</code>. In the <code>libtropic</code> repository, these tests are run against the TROPIC01 Model only. Testing aganist the TROPIC01 model is also utilized in a CI job, triggered for the <code>master</code> and <code>develop</code> branches (pushes and pull requests). The tests can also be run in the libtropic platform repositories.</p> <p>The functional tests are organized into two categories, as some of them may cause irreversible changes to the chip:</p> <ul> <li>Reversible (<code>lt_test_rev_*.c</code>): only reversible operations are executed on the TROPIC01 chip.</li> <li>Irreversible (<code>lt_test_ire_*.c</code>): irreversible operations are executed - the state or contents of the TROPIC01 chip cannot be reverted.</li> </ul> <p>Note</p> <p>Functional tests are not compiled by default. To compile functional tests, either</p> <ul> <li>pass <code>-DLT_BUILD_TESTS=1</code> to <code>cmake</code> during compilation, or</li> <li>in your CMake file, switch the option on: <code>set(LT_BUILD_TESTS ON)</code>.</li> </ul> <p>Note</p> <p>During build, SH0 keypair is automatically chosen from <code>libtropic/provisioning_data/&lt;lab_batch_package_directory&gt;/sh0_key_pair/</code>, this SH0 key is present in the majority of distributed TROPIC01 chips. In certain cases (first   engineering samples) it might be necessary to manually set it (in PEM or DER format) with following cmake switch: <code>-DLT_SH0_PRIV_PATH=&lt;path to sh0_priv_engineering_sample01.pem&gt;</code></p>"},{"location":"for_contributors/functional_tests/#adding-a-new-test","title":"Adding a New Test","text":"<p>To add a new test, you need to:</p> <ol> <li>Decide whether the test is reversible or not (see Test Types and Cleanup if you are not sure).</li> <li>Write the new test (see Test Template).</li> <li>Add the declaration together with a Doxygen comment to <code>include/libtropic_functional_tests.h</code>.</li> <li>Add the test to the root <code>CMakeLists.txt</code>:<ul> <li>In the section \"LIBTROPIC FUNCTIONAL TESTS\", add the test name to the <code>LIBTROPIC_TEST_LIST</code>   (it has to be the same as the name of the function which implements the test)</li> <li>Below the <code>LIBTROPIC_TEST_LIST</code>, there is a section where <code>SDK_SRCS</code> is extended   with test source files. Add the source file of your test here.</li> </ul> </li> <li>Make sure your test works - you can run it against the TROPIC01 Model. If the test    fails, you either:<ul> <li>Did a mistake in the test. Fix it.</li> <li>Or you found a bug - if you are certain it is a bug and not a problem in your test,   open an issue. Thanks!</li> </ul> </li> </ol>"},{"location":"for_contributors/functional_tests/#test-types-and-cleanup","title":"Test Types and Cleanup","text":"<p>As the tests are also ran against the real chips, we recognize two types of tests:</p> <ol> <li>Reversible. This type of test shall not make any irreversible changes to the chip. It may    happen that the test is interrupted by a failed assert. For these cases, there is a possibility    to define a cleanup function, which is called on every failed assert before the test termination.    If the test does some changes to the chip, which should be reverted after the end of the test,    the cleanup function for the test must be implemented, to make the test truly reversible.</li> <li>Irreversible. This type of test causes changes which are not reversible by nature (e.g. I-Config    modifications). These tests do not have to implement the cleanup function, as the chip state or    contents cannot be reverted after the test ends.</li> </ol>"},{"location":"for_contributors/functional_tests/#cleanup-function","title":"Cleanup Function","text":"<p>If the assert fails, the assert function checks whether the <code>lt_test_cleanup_function</code> function pointer is not <code>NULL</code>. If not, the cleanup function is called automatically before terminating the test. By default, the pointer is initialized to <code>NULL</code>.</p> <p>If you need a cleanup function, please create the function and assign the <code>lt_test_cleanup_function</code> at the right moment in the test (e.g. after you backed up data you would like to restore).</p> <p>You can of course reuse your cleanup function at the end of the test, so you don't have to duplicate the cleanup code if it would be the same. If you wrap the function call in the <code>LT_TEST_ASSERT</code>, do not forget to set <code>lt_test_cleanup_function</code> back to <code>NULL</code> beforehands, otherwise the cleanup will be called twice.</p>"},{"location":"for_contributors/functional_tests/#test-template","title":"Test Template","text":"<p>Change the lines with <code>TODO</code>.</p> <pre><code>/**\n * @file TODO: FILL ME\n * @brief TODO: FILL ME\n * @author Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_functional_tests.h\"\n#include \"libtropic_logging.h\"\n\n// Shared with cleanup function.\n// TODO: CAN BE REMOVED IF CLEANUP NOT USED.\nlt_handle_t *g_h;\n\n// TODO: REMOVE OR EDIT\nstatic lt_ret_t lt_new_test_cleanup(void)\n{\n    LT_LOG_INFO(\"Starting secure session with slot %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_verify_chip_and_start_secure_session(g_h, sh0priv, sh0pub, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to establish secure session, ret=%s\", lt_ret_verbose(ret));\n        return ret;\n    }\n\n    // TODO: REST OF THE CLEANUP DUTIES\n\n    return LT_OK;\n}\n\nvoid lt_new_test(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"----------------------------------------------\");\n    LT_LOG_INFO(\"lt_new_test()\");\n    LT_LOG_INFO(\"----------------------------------------------\");\n\n    // TODO/NOTE: If you use cleanup, do not forget to assign handle to a globally available pointer,\n    // so you can use the handle in the cleanup function.\n    g_h = h;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    LT_TEST_ASSERT(LT_OK, lt_init(h));\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    LT_TEST_ASSERT(LT_OK, lt_verify_chip_and_start_secure_session(h, sh0priv, sh0pub, TR01_PAIRING_KEY_SLOT_INDEX_0));\n    LT_LOG_LINE();\n\n    // TODO: DO THE TESTING HERE\n    // Add this line if you need cleanup. Add it where appropriate -- e.g. after backing up data\n    // you need to restore in the cleanup.\n    lt_test_cleanup_function = &amp;lt_new_test_cleanup;\n\n    // Call cleanup function, but don't call it from LT_TEST_ASSERT anymore.\n    lt_test_cleanup_function = NULL;\n    LT_LOG_INFO(\"Starting post-test cleanup\");\n    LT_TEST_ASSERT(LT_OK, lt_new_test_cleanup());\n    LT_LOG_INFO(\"Post-test cleanup was successful\");\n}\n</code></pre>"},{"location":"get_started/","title":"Get Started","text":"<p>This section provides information to help you get started with libtropic.</p> <ul> <li>Libtropic Architecture</li> <li>Integrating Libtropic</li> <li>Examples</li> <li>Logging</li> <li>Debugging</li> </ul>"},{"location":"get_started/debugging/","title":"Debugging","text":"<p>When debugging, some additional compiler flags are needed to produce debugging information. These flags can be added using the CMake's <code>CMAKE_BUILD_TYPE</code> environment variable by:</p> <ol> <li>specifying <code>-DCMAKE_BUILD_TYPE=Debug</code> when executing <code>cmake</code> in the command line,</li> <li>putting <code>set(CMAKE_BUILD_TYPE \"Debug\")</code> into yours or the libtropic's main <code>CMakeLists.txt</code>.</li> </ol> <p>After this, you can use debugging tools of your choice, e.g. gdb or Valgrind. Refer to each tool's documentation for the installation instructions.</p> <p>If you want to use AddressSanitizer, you have to add more compiler flags. That is why we added the <code>LT_ASAN</code> option into our main <code>CMakeLists.txt</code>, along with the <code>LT_ASAN_COMPILE_FLAGS</code> and <code>LT_ASAN_LINK_FLAGS</code> variables. If your project is using CMake, you can add the following lines into your <code>CMakeLists.txt</code> file: <pre><code>if(LT_ASAN)\n    message(STATUS \"AddressSanitizer (ASan) is enabled for the entire project.\")\n    add_compile_options(${LT_ASAN_COMPILE_FLAGS})\n    add_link_options(${LT_ASAN_LINK_FLAGS})\nendif()\n</code></pre> After that, you will be able to link the static version of AddressSanitizer, if <code>LT_ASAN</code> is set either via the command line or directly in <code>CMakeLists.txt</code>.</p> <p>Tip</p> <p>If you are debugging on any Unix-like operating system, you do not have to make any changes and can directly debug with the TROPIC01 Model, where the environment for debugging is already prepared (the section provides all information on how to do that).</p>"},{"location":"get_started/libtropic_architecture/","title":"Libtropic Architecture","text":"<p>Before talking about Libtropic's architecture, it is important to understand the communication between the Host MCU and TROPIC01. Both of these parties communicate via a multi-layer serial protocol, consisting of the following three layers:</p> <ol> <li>Phyiscal Layer (L1). A transfer is a unit of communication and a 4-wire SPI interface is used.</li> <li>Data Link Layer (L2). A frame is a unit of communication, which is organized into multiple fields. During L2 communication, the Host MCU sends an L2 Request frame and TROPIC01 return an L2 Reponse frame. Communication on the L2 Layer is not encrypted and thus used for non-secure information about TROPIC01 and L3 communication set up.</li> <li>Secure Session Layer (L3). A packet is a unit of communication. L3 communication requires an established Secure Channel Session. Then, the Host MCU can communicate through sending L3 Command packets and TROPIC01 responds with L3 Result packets. The communication is executed on an encrypted channel (Secure Channel) with strong forward secrecy based on a Noise Protocol Framework.</li> </ol> <p>For more information about TROPIC01, please refer to TROPIC01 repository.</p> <p>Libtropic's architecture is visualized in the following figure:</p>      Libtropic Architecture    <p>Libtropic consists of:</p> <ol> <li>Libtropic Public API. Macros and data structures are available in <code>include/libtropic_common.h</code> and function declarations in <code>include/libtropic.h</code> (implemented in <code>src/libtropic.c</code>). Interface of these functions is tightly related to TROPIC01's commands, defined in the User API (can be found in the TROPIC01 repository). These public functions are used for Unencrypted Communication, which is achieved by calling the Layer 2 API, and Encrypted Communication, achieved by calling the Layer 3 API and using one of the available Cryptography Libraries for cryptography operations on the Host MCU side.</li> <li>Helpers. Functions also declared in <code>include/libtropic.h</code>, that either wrap one or more Libtropic API functions to simplify some operations (e.g. the function <code>lt_verify_and_chip_and_start_secure_session()</code> for easier Secure Session establishment), or provide some additional functionality (e.g. the function <code>lt_print_chip_id()</code> for interpreting TROPIC01's <code>CHIP_ID</code> and printing it).</li> <li>Examples. Show example usage of Libtropic, using both the Libtropic API and Helpers.</li> <li>Functional Tests. Used to verify the libtropic core API, using both the Libtropic API and Helpers.</li> <li>L3 Layer API. Functions called by the Libtropic Public API during Encrypted Communication.</li> <li>L2 Layer API. Functions called by the Libtropic Public API during Unencrypted Communication.</li> <li>L1 Layer API. Functions called by the L2 Layer API and wrapping port-specific L1 Layer functions, which are implemented by the HALs (Hardware Abstract Layers) in <code>hal/port/</code>. These HALs are initialized using the Libtropic Public API. The library can be compiled with support for only one hardware abstraction layer (HAL) at a time, but the HAL allows communication with multiple chips.</li> </ol> <p>Tip</p> <p>For more information about Libtropic's functions, refer to the API Reference.</p>"},{"location":"get_started/logging/","title":"Logging","text":"<p>Libtropic contains a logging functionality, which is disabled by default (unless you compile tests or examples).</p> <p>You may find it useful to enable logging during libtropic evaluation or integration. There are five logging levels:</p> <ul> <li>none (default unless compiling tests or examples),</li> <li>error,</li> <li>warning,</li> <li>info,</li> <li>debug.</li> </ul> <p>One of these logging levels can be switched on using the CMake switch <code>-DLT_LOG_LVL</code>, which is passed to <code>cmake</code> when building the project. The following table summarizes all logging levels and a switch corresponding to each level:</p> Level CMake switch none <code>-DLT_LOG_LVL=None</code> error <code>-DLT_LOG_LVL=Error</code> warning <code>-DLT_LOG_LVL=Warning</code> info <code>-DLT_LOG_LVL=Info</code> debug <code>-DLT_LOG_LVL=Debug</code>"},{"location":"get_started/logging/#how-to-log","title":"How to Log","text":"<p>Logging can be done using logging macros, which are defined in <code>include/libtropic_logging.h</code>. Following logging macros are available:</p> <ul> <li><code>LT_LOG_INFO</code>,</li> <li><code>LT_LOG_WARN</code>,</li> <li><code>LT_LOG_ERROR</code>,</li> <li><code>LT_LOG_DEBUG</code>.</li> </ul> <p>Each macro corresponds to a verbosity level, which is activated with the aforementioned CMake switch. Macros have the same interface as the <code>printf</code> function, as they are essentially a wrapper over <code>printf</code>.</p> <p>Important</p> <p>Avoid passing function calls as macro arguments (except for simple formatting helpers like <code>lt_ret_verbose</code> or <code>strerror</code>). Logging macros may be completely removed at lower verbosity levels, meaning any function calls inside them will not execute.</p> <p>This is safe (using <code>lt_ret_verbose()</code> helper function only):</p> <pre><code>LT_LOG_INFO(\"Error code: %d, error string: %s\", ret, lt_ret_verbose(ret));\n</code></pre> <p>This is unsafe \u2014 <code>lt_init()</code> will never run if logging is disabled:</p> <pre><code>LT_LOG_INFO(\"Initializing handle: %d\", lt_init(&amp;h));\n</code></pre> <p>Correct approach \u2014 call the function first, then log its result:</p> <pre><code>int ret = lt_init(&amp;h);\nLT_LOG_INFO(\"Initializing handle: %d\", ret);\n</code></pre> <p>Note</p> <p>There are also macros used for assertion. These are used in functional tests.</p>"},{"location":"get_started/examples/","title":"Examples","text":"<p>The <code>examples/</code> directory contains multiple examples demonstrating how to use libtropic. Please read this entire page before diving into the examples!</p>"},{"location":"get_started/examples/#example-categories","title":"Example Categories","text":"<p>Some examples may cause irreversible changes to the chip, so they are organized into two categories:</p> <ul> <li>Reversible Examples</li> <li>Irreversible Examples</li> </ul> <p>Note</p> <p>Irreversible changes include writing to I-config, writing or invalidating pairing keys, or performing a firmware update.</p>"},{"location":"get_started/examples/#building","title":"Building","text":"<p>Examples can be compiled using the <code>LT_BUILD_EXAMPLES</code> flag. You can enable the flag in two ways:</p> <ul> <li>During compilation by passing <code>-DLT_BUILD_EXAMPLES=1</code> to <code>cmake</code>, or</li> <li>in your project's <code>CMakeLists.txt</code>: <code>set(LT_BUILD_EXAMPLES ON)</code>.</li> </ul> <p>It is recommended to try the examples in one of our platform repositories using a real TROPIC01 chip on one of our supported platforms, or on a TROPIC01 model directly on your computer. Both the platform repositories and the model contain detailed guides on example compilation.</p> <p>Note</p> <p>During the build process, you may encounter issues with pairing keys. Although the default (production) key is present in the majority of distributed TROPIC01 chips, the first chip revisions (engineering samples) might contain a different key. This key must be selected manually during the build using the following CMake switch: <code>-DLT_SH0_PRIV_PATH=&lt;path to sh0_priv_engineering_sample01.pem&gt;</code>. Check out the platform repositories or the TROPIC01 model for more information.</p>"},{"location":"get_started/examples/#should-i-use-the-model-or-a-real-chip","title":"Should I Use the Model or a Real Chip?","text":"<p>All of the examples are compatible with the TROPIC01 chip, and the majority of them are also compatible with the TROPIC01 model. It is highly recommended to try the model first, especially for irreversible examples, as they make irreversible changes to the real chip.</p> <p>Some examples are not compatible with the model (such as the firmware update example). Any such incompatibility is always noted in the example description in this documentation.</p>"},{"location":"get_started/examples/#where-do-i-start","title":"Where Do I Start?","text":"<p>We recommend starting with Reversible Examples, specifically <code>lt_ex_hello_world.c</code>. This example demonstrates the usage of basic libtropic API functions. After understanding this example, you can dive into more complex ones.</p>"},{"location":"get_started/examples/irreversible_examples/","title":"Irreversible Examples","text":"<p>To provide better orientation, we highlight specific properties of each example, namely:</p> <ul> <li>Reversibility,</li> <li>Model compatibility,</li> <li>Level of complexity (\ud83d\udc23 -&gt; \ud83d\udc24 -&gt; \ud83d\udc13).</li> </ul> <p>The source code for the examples can be found in the <code>examples/</code> directory and also within this document inside \"Source Code\" boxes.</p> <p>Tip</p> <p>You can copy the example code using the  icon located in the top-right corner of each source code listing.</p>"},{"location":"get_started/examples/irreversible_examples/#lt_ex_hw_walletc","title":"lt_ex_hw_wallet.c","text":"<ul> <li>\u26a0\ufe0f Irreversible</li> <li>\u2705 Compatible with the model</li> <li>\ud83d\udc13 Level: Advanced</li> </ul> <p>This example demonstrates how to use configuration objects and different pairing keys to manage access to TROPIC01 features. A hardware wallet device scenario is used as a model for this example.</p> <p>In this example, you will:</p> <ul> <li>Understand how the R-config is structured and how permissions are managed using the R-config.</li> <li>Learn how the R-config can be modified using the libtropic API:<ul> <li><code>lt_r_config_erase()</code>: L3 command to erase the R-config.</li> <li><code>lt_write_whole_R_config()</code>: helper function to write the whole R-config with an instance of <code>struct lt_config_t</code>.</li> <li><code>lt_read_whole_R_config()</code>: helper function to read the whole R-config into an instance of <code>struct lt_config_t</code>.  <p>Note</p> <p>If you need to modify only one entry in the R-config, you can use <code>lt_r_config_write()</code> or <code>lt_r_config_read()</code>.</p> </li> </ul> </li> <li>Learn how to manage pairing keys:<ul> <li><code>lt_pairing_key_write()</code>: L3 command to write a pairing key.</li> <li><code>lt_pairing_key_invalidate()</code>: L3 command to invalidate a pairing key.</li> </ul> </li> <li>Learn how to work with keys based on elliptic curves (ECC) on TROPIC01:<ul> <li><code>lt_ecc_key_store()</code>: L3 command to store an ECC key.</li> <li><code>lt_ecc_key_read()</code>: L3 command to read an ECC key.</li> <li><code>lt_ecc_key_generate()</code>: L3 command to generate an ECC key.</li> </ul> </li> <li>Learn how to use EDDSA to sign messages and verify signatures.</li> <li>Learn how to use a monotonic counter.</li> </ul> Source code <pre><code>/**\n * @file lt_ex_hw_wallet.c\n * @brief Example usage of TROPIC01 chip in a generic *hardware wallet* project.\n * @author Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include &lt;inttypes.h&gt;\n\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_examples.h\"\n#include \"libtropic_logging.h\"\n#include \"string.h\"\n\n/** @brief Message to send with Ping L3 command. */\n#define PING_MSG \"Ping message for TROPIC01\"\n/** @brief Size of the Ping message, including '\\0'. */\n#define PING_MSG_SIZE 26\n\n/** @brief Attestation key for ECC slot 0. */\nuint8_t attestation_key[TR01_CURVE_PRIVKEY_LEN]\n    = {0x22, 0x57, 0xa8, 0x2f, 0x85, 0x8f, 0x13, 0x32, 0xfa, 0x0f, 0xf6, 0x0c, 0x76, 0x29, 0x42, 0x70,\n       0xa9, 0x58, 0x9d, 0xfd, 0x47, 0xa5, 0x23, 0x78, 0x18, 0x4d, 0x2d, 0x38, 0xf0, 0xa7, 0xc4, 0x01};\n\n/**\n * @brief Creates an HW wallet example config from the virgin R config.\n *\n * @param r_config R config to modify\n */\nstatic void create_example_r_config(struct lt_config_t *r_config)\n{\n    //-------CFG_START_UP------------------------------------\n    // Enable MBIST and RNGTEST (DIS in their names stands for disable, so writing 0 enables them)\n    r_config-&gt;obj[TR01_CFG_START_UP_IDX]\n        &amp;= ~(BOOTLOADER_CO_CFG_START_UP_MBIST_DIS_MASK | BOOTLOADER_CO_CFG_START_UP_RNGTEST_DIS_MASK);\n\n    //-------CFG_SENSORS-------------------------------------\n    // Enable all sensors (DIS in their names stands for disable, so writing 0 enables them)\n    r_config-&gt;obj[TR01_CFG_SENSORS_IDX] &amp;= ~(\n        BOOTLOADER_CO_CFG_SENSORS_PTRNG0_TEST_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_PTRNG1_TEST_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_OSCILLATOR_MON_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_SHIELD_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_VOLTAGE_MON_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_GLITCH_DET_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_TEMP_SENS_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_LASER_DET_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_EM_PULSE_DET_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_CPU_ALERT_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_PIN_VERIF_BIT_FLIP_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_SCB_BIT_FLIP_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_CPB_BIT_FLIP_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_ECC_BIT_FLIP_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_R_MEM_BIT_FLIP_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_EKDB_BIT_FLIP_DIS_MASK\n        | BOOTLOADER_CO_CFG_SENSORS_I_MEM_BIT_FLIP_DIS_MASK | BOOTLOADER_CO_CFG_SENSORS_PLATFORM_BIT_FLIP_DIS_MASK);\n\n    //-------CFG_DEBUG---------------------------------------\n    // Disable FW logging\n    r_config-&gt;obj[TR01_CFG_DEBUG_IDX] &amp;= ~BOOTLOADER_CO_CFG_DEBUG_FW_LOG_EN_MASK;\n\n    //-------TR01_CFG_GPO-----------------------------------------\n    // Keep at reset value\n\n    //-------TR01_CFG_SLEEP_MODE----------------------------------\n    // Enable sleep mode\n    r_config-&gt;obj[TR01_CFG_SLEEP_MODE_IDX] |= APPLICATION_CO_CFG_SLEEP_MODE_SLEEP_MODE_EN_MASK;\n\n    //------- TR01_CFG_UAP_PAIRING_KEY_WRITE ---------------------\n    // Disable writing pairing keys for all slots\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_WRITE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH0(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_WRITE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH1(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_WRITE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH2(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_WRITE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH3(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_PAIRING_KEY_READ ----------------------\n    // All sessions can read pairing keys\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_READ_IDX] |= LT_TO_PAIRING_KEY_SH0(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_READ_IDX] |= LT_TO_PAIRING_KEY_SH1(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_READ_IDX] |= LT_TO_PAIRING_KEY_SH2(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_READ_IDX] |= LT_TO_PAIRING_KEY_SH3(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_PAIRING_KEY_INVALIDATE ----------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH0(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH1(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH2(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] &amp;= ~LT_TO_PAIRING_KEY_SH3(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Pairing key SH0PUB can be invalidated only from session with SH0PUB\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] |= LT_TO_PAIRING_KEY_SH0(LT_SESSION_SH0_HAS_ACCESS);\n    // 3. Pairing keys SH1PUB, SH2PUB and SH3PUB can be invalidated only from session with SH3PUB\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] |= LT_TO_PAIRING_KEY_SH1(LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] |= LT_TO_PAIRING_KEY_SH2(LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_PAIRING_KEY_INVALIDATE_IDX] |= LT_TO_PAIRING_KEY_SH3(LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_R_CONFIG_WRITE_ERASE ------------------\n    // Keep at reset value, not used currently\n\n    //------- TR01_CFG_UAP_R_CONFIG_READ -------------------------\n    // Keep at reset value, not used currently\n\n    //------- TR01_CFG_UAP_I_CONFIG_WRITE ------------------------\n    // Keep at reset value, not used currently\n\n    //------- TR01_CFG_UAP_I_CONFIG_READ -------------------------\n    // Keep at reset value, not used currently\n\n    //------- TR01_CFG_UAP_PING ----------------------------------\n    // Enable for all pairing keys\n    r_config-&gt;obj[TR01_CFG_UAP_PING_IDX] |= (LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS\n                                             | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_R_MEM_DATA_WRITE ----------------------\n    // Reset value, not used currently\n\n    //------- TR01_CFG_UAP_R_MEM_DATA_READ -----------------------\n    // Reset value, not used currently\n\n    //------- TR01_CFG_UAP_R_MEM_DATA_ERASE ----------------------\n    // Reset value, not used currently\n\n    //------- TR01_CFG_UAP_RANDOM_VALUE_GET ----------------------\n    // Enable for all pairing keys\n    r_config-&gt;obj[TR01_CFG_UAP_RANDOM_VALUE_GET_IDX] |= (LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS\n                                                         | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_ECC_KEY_GENERATE ----------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_GENERATE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_0_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_GENERATE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_8_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_GENERATE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_16_23(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_GENERATE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_24_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Only session with SH3PUB can generate keys in slots 8-31\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_GENERATE_IDX]\n        |= (LT_TO_ECC_KEY_SLOT_8_15(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_ECC_KEY_SLOT_16_23(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_ECC_KEY_SLOT_24_31(LT_SESSION_SH3_HAS_ACCESS));\n\n    //------- TR01_CFG_UAP_ECC_KEY_STORE -------------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_STORE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_0_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_STORE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_8_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_STORE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_16_23(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_STORE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_24_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH1PUB can store key into ECC key slot 0-7\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_STORE_IDX] |= LT_TO_ECC_KEY_SLOT_0_7(LT_SESSION_SH1_HAS_ACCESS);\n    // 3. Session with SH3PUB can store key into ECC key slot 8-31\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_STORE_IDX] |= LT_TO_ECC_KEY_SLOT_8_15(LT_SESSION_SH3_HAS_ACCESS)\n                                                     | LT_TO_ECC_KEY_SLOT_16_23(LT_SESSION_SH3_HAS_ACCESS)\n                                                     | LT_TO_ECC_KEY_SLOT_24_31(LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_ECC_KEY_READ --------------------------\n    // Enable for all pairing keys\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_READ_IDX] |= LT_TO_ECC_KEY_SLOT_0_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_READ_IDX] |= LT_TO_ECC_KEY_SLOT_8_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_READ_IDX] |= LT_TO_ECC_KEY_SLOT_16_23(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_READ_IDX] |= LT_TO_ECC_KEY_SLOT_24_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_ECC_KEY_ERASE -------------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_ERASE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_0_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_ERASE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_8_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_ERASE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_16_23(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_ERASE_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_24_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH1PUB can erase ECC key slots 0-7\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_ERASE_IDX] |= LT_TO_ECC_KEY_SLOT_0_7(LT_SESSION_SH1_HAS_ACCESS);\n    // 3. Session with SH3PUB can erase ECC key slots 8-31\n    r_config-&gt;obj[TR01_CFG_UAP_ECC_KEY_ERASE_IDX] |= LT_TO_ECC_KEY_SLOT_8_15(LT_SESSION_SH3_HAS_ACCESS)\n                                                     | LT_TO_ECC_KEY_SLOT_16_23(LT_SESSION_SH3_HAS_ACCESS)\n                                                     | LT_TO_ECC_KEY_SLOT_24_31(LT_SESSION_SH3_HAS_ACCESS);\n\n    //------- TR01_CFG_UAP_ECDSA_SIGN ----------------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_ECDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_0_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_8_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_16_23(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_ECDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_24_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH3PUB can sign with all ECC key slots\n    r_config-&gt;obj[TR01_CFG_UAP_ECDSA_SIGN_IDX]\n        |= (LT_TO_ECC_KEY_SLOT_0_7(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_ECC_KEY_SLOT_8_15(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_ECC_KEY_SLOT_16_23(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_ECC_KEY_SLOT_24_31(LT_SESSION_SH3_HAS_ACCESS));\n\n    //------- TR01_CFG_UAP_EDDSA_SIGN ----------------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_EDDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_0_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_EDDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_8_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_EDDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_16_23(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_EDDSA_SIGN_IDX] &amp;= ~LT_TO_ECC_KEY_SLOT_24_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH3PUB can sign with all ECC key slots\n    r_config-&gt;obj[TR01_CFG_UAP_EDDSA_SIGN_IDX]\n        |= (LT_TO_ECC_KEY_SLOT_0_7(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_ECC_KEY_SLOT_8_15(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_ECC_KEY_SLOT_16_23(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_ECC_KEY_SLOT_24_31(LT_SESSION_SH3_HAS_ACCESS));\n\n    //------- TR01_CFG_UAP_MCOUNTER_INIT -------------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_INIT_IDX] &amp;= ~LT_TO_MCOUNTER_0_3(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_INIT_IDX] &amp;= ~LT_TO_MCOUNTER_4_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_INIT_IDX] &amp;= ~LT_TO_MCOUNTER_8_11(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_INIT_IDX] &amp;= ~LT_TO_MCOUNTER_12_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH3PUB can init all mcounters\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_INIT_IDX]\n        |= (LT_TO_MCOUNTER_0_3(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_MCOUNTER_4_7(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_MCOUNTER_8_11(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_MCOUNTER_12_15(LT_SESSION_SH3_HAS_ACCESS));\n\n    //------- TR01_CFG_UAP_MCOUNTER_GET --------------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_GET_IDX] &amp;= ~LT_TO_MCOUNTER_0_3(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_GET_IDX] &amp;= ~LT_TO_MCOUNTER_4_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_GET_IDX] &amp;= ~LT_TO_MCOUNTER_8_11(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_GET_IDX] &amp;= ~LT_TO_MCOUNTER_12_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH3PUB can get all mcounters\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_GET_IDX]\n        |= (LT_TO_MCOUNTER_0_3(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_MCOUNTER_4_7(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_MCOUNTER_8_11(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_MCOUNTER_12_15(LT_SESSION_SH3_HAS_ACCESS));\n\n    //------- TR01_CFG_UAP_MCOUNTER_UPDATE -----------------------\n    // 1. Disable all, then enable only specific ones\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_UPDATE_IDX] &amp;= ~LT_TO_MCOUNTER_0_3(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_UPDATE_IDX] &amp;= ~LT_TO_MCOUNTER_4_7(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_UPDATE_IDX] &amp;= ~LT_TO_MCOUNTER_8_11(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_UPDATE_IDX] &amp;= ~LT_TO_MCOUNTER_12_15(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    // 2. Session with SH3PUB can update all mcounters\n    r_config-&gt;obj[TR01_CFG_UAP_MCOUNTER_UPDATE_IDX]\n        |= (LT_TO_MCOUNTER_0_3(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_MCOUNTER_4_7(LT_SESSION_SH3_HAS_ACCESS)\n            | LT_TO_MCOUNTER_8_11(LT_SESSION_SH3_HAS_ACCESS) | LT_TO_MCOUNTER_12_15(LT_SESSION_SH3_HAS_ACCESS));\n\n    //------- TR01_CFG_UAP_MAC_AND_DESTROY_ADDR -----------------------\n    // Enable for all pairing key slots\n    r_config-&gt;obj[TR01_CFG_UAP_MAC_AND_DESTROY_IDX] |= LT_TO_MACANDD_SLOT_0_31(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MAC_AND_DESTROY_IDX] |= LT_TO_MACANDD_SLOT_32_63(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MAC_AND_DESTROY_IDX] |= LT_TO_MACANDD_SLOT_64_95(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n    r_config-&gt;obj[TR01_CFG_UAP_MAC_AND_DESTROY_IDX] |= LT_TO_MACANDD_SLOT_96_127(\n        LT_SESSION_SH0_HAS_ACCESS | LT_SESSION_SH1_HAS_ACCESS | LT_SESSION_SH2_HAS_ACCESS | LT_SESSION_SH3_HAS_ACCESS);\n}\n\n/**\n * @brief Initial session, when chip is powered for the first time during manufacturing.\n *        This function writes chip's configuration into R config.\n *\n * @param h  Device's handle\n * @return   0 if success, -1 otherwise\n */\nstatic int session_initial(lt_handle_t *h)\n{\n    lt_ret_t ret;\n    struct lt_config_t r_config;\n    uint8_t *pub_keys[] = {sh0pub, sh1pub, sh2pub, sh3pub};\n\n    LT_LOG_INFO(\"Initializing handle\");\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_verify_chip_and_start_secure_session(h, sh0priv, sh0pub, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to start Secure Session with key %d, ret=%s\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0,\n                     lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Reading the whole R config:\");\n    ret = lt_read_whole_R_config(h, &amp;r_config);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to read R config, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    for (int i = 0; i &lt; LT_CONFIG_OBJ_CNT; i++) {\n        LT_LOG_INFO(\"%s: 0x%08\" PRIx32, cfg_desc_table[i].desc, r_config.obj[i]);\n    }\n\n    LT_LOG_INFO(\"Creating an example config from the read R config...\");\n    create_example_r_config(&amp;r_config);\n\n    LT_LOG_INFO(\"Erasing R config in case it is already written...\");\n    ret = lt_r_config_erase(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to erase R config, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Writing the whole R config with the example config...\");\n    ret = lt_write_whole_R_config(h, &amp;r_config);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to write R config, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Reading the whole R config again:\");\n    ret = lt_read_whole_R_config(h, &amp;r_config);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to read R config, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    for (int i = 0; i &lt; LT_CONFIG_OBJ_CNT; i++) {\n        LT_LOG_INFO(\"%s: 0x%08\" PRIx32, cfg_desc_table[i].desc, r_config.obj[i]);\n    }\n\n    // Write pairing keys into slots 1,2,3\n    for (uint8_t i = TR01_PAIRING_KEY_SLOT_INDEX_1; i &lt;= TR01_PAIRING_KEY_SLOT_INDEX_3; i++) {\n        LT_LOG_INFO(\"Writing to pairing key slot %\" PRIu8 \"...\", i);\n        ret = lt_pairing_key_write(h, pub_keys[i], i);\n        if (LT_OK != ret) {\n            LT_LOG_ERROR(\"Failed to write pairing key, ret=%s\", lt_ret_verbose(ret));\n            return -1;\n        }\n        LT_LOG_INFO(\"\\tOK\");\n    }\n\n    LT_LOG_INFO(\"Invalidating pairing key slot %d...\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_pairing_key_invalidate(h, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to invalidate pairing key slot, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Rebooting TROPIC01 to apply changes...\");\n    ret = lt_reboot(h, TR01_REBOOT);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to reboot, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * @brief Session with pairing key slot 0\n *\n * @param h  Device's handle\n * @return   0 if success, -1 otherwise\n */\nstatic int session0(lt_handle_t *h)\n{\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d (should fail)\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_verify_chip_and_start_secure_session(h, sh0priv, sh0pub, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_L2_HSK_ERR != ret) {\n        LT_LOG_ERROR(\"Return value is not LT_L2_HSK_ERR, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * @brief Session with pairing key slot 1\n *\n * @param h  Device's handle\n * @return   0 if success, -1 otherwise\n */\nstatic int session1(lt_handle_t *h)\n{\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_1);\n    ret = lt_verify_chip_and_start_secure_session(h, sh1priv, sh1pub, TR01_PAIRING_KEY_SLOT_INDEX_1);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to start Secure Session with key %d, ret=%s\", (int)TR01_PAIRING_KEY_SLOT_INDEX_1,\n                     lt_ret_verbose(ret));\n        return -1;\n    }\n\n    uint8_t recv_buf[PING_MSG_SIZE];\n    LT_LOG_INFO(\"Sending Ping command with message:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", PING_MSG);\n    ret = lt_ping(h, (const uint8_t *)PING_MSG, recv_buf, PING_MSG_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Ping command failed, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Message received from TROPIC01:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", recv_buf);\n\n    LT_LOG_INFO(\"Storing attestation key into ECC slot %d...\", (int)TR01_ECC_SLOT_0);\n    ret = lt_ecc_key_store(h, TR01_ECC_SLOT_0, TR01_CURVE_ED25519, attestation_key);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to store ECC key to slot %d, ret=%s\", (int)TR01_ECC_SLOT_0, lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    uint8_t dummy_key[TR01_SHIPUB_LEN] = {0};\n    LT_LOG_INFO(\"Writing all pairing key slots (should fail):\");\n    for (uint8_t i = TR01_PAIRING_KEY_SLOT_INDEX_0; i &lt;= TR01_PAIRING_KEY_SLOT_INDEX_3; i++) {\n        LT_LOG_INFO(\"\\tWriting pairing key slot %\" PRIu8 \"...\", i);\n        ret = lt_pairing_key_write(h, dummy_key, i);\n        if (LT_L3_UNAUTHORIZED != ret) {\n            LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n            return -1;\n        }\n        LT_LOG_INFO(\"\\t\\tOK\");\n    }\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * @brief Session with pairing key slot 2\n *\n * @param h  Device's handle\n * @return   0 if success, -1 otherwise\n */\nstatic int session2(lt_handle_t *h)\n{\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_2);\n    ret = lt_verify_chip_and_start_secure_session(h, sh2priv, sh2pub, TR01_PAIRING_KEY_SLOT_INDEX_2);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to start Secure Session with key %d, ret=%s\", (int)TR01_PAIRING_KEY_SLOT_INDEX_2,\n                     lt_ret_verbose(ret));\n        return -1;\n    }\n\n    uint8_t recv_buf[PING_MSG_SIZE];\n    LT_LOG_INFO(\"Sending Ping command with message:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", PING_MSG);\n    ret = lt_ping(h, (const uint8_t *)PING_MSG, recv_buf, PING_MSG_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Ping command failed, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Message received from TROPIC01:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", recv_buf);\n\n    uint8_t dummy_key[TR01_CURVE_PRIVKEY_LEN] = {0};\n    LT_LOG_INFO(\"Trying to store key into ECC slot %d (should fail)\", (int)TR01_ECC_SLOT_0);\n    ret = lt_ecc_key_store(h, TR01_ECC_SLOT_0, TR01_CURVE_ED25519, dummy_key);\n    if (LT_L3_UNAUTHORIZED != ret) {\n        LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Writing all pairing key slots (should fail):\");\n    for (uint8_t i = TR01_PAIRING_KEY_SLOT_INDEX_0; i &lt;= TR01_PAIRING_KEY_SLOT_INDEX_3; i++) {\n        LT_LOG_INFO(\"\\tWriting pairing key slot %\" PRIu8 \"...\", i);\n        ret = lt_pairing_key_write(h, dummy_key, i);\n        if (LT_L3_UNAUTHORIZED != ret) {\n            LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n            return -1;\n        }\n        LT_LOG_INFO(\"\\t\\tOK\");\n    }\n\n    uint32_t mcounter_value = 0x000000ff;\n    LT_LOG_INFO(\"Initializing mcounter 0 (should fail)...\");\n    ret = lt_mcounter_init(h, TR01_MCOUNTER_INDEX_0, mcounter_value);\n    if (LT_L3_UNAUTHORIZED != ret) {\n        LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Updating mcounter 0 (should fail)...\");\n    ret = lt_mcounter_update(h, TR01_MCOUNTER_INDEX_0);\n    if (LT_L3_UNAUTHORIZED != ret) {\n        LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Getting mcounter 0 (should fail)...\");\n    ret = lt_mcounter_get(h, TR01_MCOUNTER_INDEX_0, &amp;mcounter_value);\n    if (LT_L3_UNAUTHORIZED != ret) {\n        LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * @brief Session with pairing key slot 3\n *\n * @param h  Device's handle\n * @return   0 if success, -1 otherwise\n */\nstatic int session3(lt_handle_t *h)\n{\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_3);\n    ret = lt_verify_chip_and_start_secure_session(h, sh3priv, sh3pub, TR01_PAIRING_KEY_SLOT_INDEX_3);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to start Secure Session with key %d, ret=%s\", (int)TR01_PAIRING_KEY_SLOT_INDEX_3,\n                     lt_ret_verbose(ret));\n        return -1;\n    }\n\n    uint8_t recv_buf[PING_MSG_SIZE];\n    LT_LOG_INFO(\"Sending Ping command with message:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", PING_MSG);\n    ret = lt_ping(h, (const uint8_t *)PING_MSG, recv_buf, PING_MSG_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Ping command failed, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Message received from TROPIC01:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", recv_buf);\n\n    LT_LOG_INFO(\"Signing with attestation key which was updated through pairing key slot 1\");\n    uint8_t msg[] = {'a', 'h', 'o', 'j'};\n    uint8_t rs[TR01_ECDSA_EDDSA_SIGNATURE_LENGTH];\n    ret = lt_ecc_eddsa_sign(h, TR01_ECC_SLOT_0, msg, sizeof(msg), rs);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to sign, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Reading ECC key slot %d...\", (int)TR01_ECC_SLOT_0);\n    uint8_t ed25519_pubkey[TR01_CURVE_ED25519_PUBKEY_LEN];\n    lt_ecc_curve_type_t curve;\n    lt_ecc_key_origin_t origin;\n    ret = lt_ecc_key_read(h, TR01_ECC_SLOT_0, ed25519_pubkey, sizeof(ed25519_pubkey), &amp;curve, &amp;origin);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to read ECC slot, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Verifying with lt_ecc_eddsa_sig_verify()...\");\n    ret = lt_ecc_eddsa_sig_verify(msg, sizeof(msg), ed25519_pubkey, rs);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to verify, ret%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Generating ECC key in slot %d...\", (int)TR01_ECC_SLOT_8);\n    ret = lt_ecc_key_generate(h, TR01_ECC_SLOT_8, TR01_CURVE_ED25519);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to generate ECC key, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Generating ECC key in slot %d...\", (int)TR01_ECC_SLOT_16);\n    ret = lt_ecc_key_generate(h, TR01_ECC_SLOT_16, TR01_CURVE_ED25519);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to generate ECC key, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Generating ECC key in slot %d...\", (int)TR01_ECC_SLOT_24);\n    ret = lt_ecc_key_generate(h, TR01_ECC_SLOT_24, TR01_CURVE_ED25519);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to generate ECC key, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Getting %d random bytes...\", (int)TR01_RANDOM_VALUE_GET_LEN_MAX);\n    uint8_t buff[TR01_RANDOM_VALUE_GET_LEN_MAX];\n    ret = lt_random_value_get(h, buff, TR01_RANDOM_VALUE_GET_LEN_MAX);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to get random bytes, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    uint32_t mcounter_value = 0x000000ff;\n    LT_LOG_INFO(\"Initializing mcounter 0...\");\n    ret = lt_mcounter_init(h, TR01_MCOUNTER_INDEX_0, mcounter_value);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize mcounter, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Updating mcounter 0...\");\n    ret = lt_mcounter_update(h, TR01_MCOUNTER_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to update mcounter, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Getting mcounter 0...\");\n    ret = lt_mcounter_get(h, TR01_MCOUNTER_INDEX_0, &amp;mcounter_value);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to get mcounter, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    uint8_t dummy_key[TR01_CURVE_PRIVKEY_LEN];\n    LT_LOG_INFO(\"Trying to store key into ECC slot %d (should fail)\", (int)TR01_ECC_SLOT_0);\n    ret = lt_ecc_key_store(h, TR01_ECC_SLOT_0, TR01_CURVE_ED25519, dummy_key);\n    if (LT_L3_UNAUTHORIZED != ret) {\n        LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Writing all pairing key slots (should fail):\");\n    for (uint8_t i = TR01_PAIRING_KEY_SLOT_INDEX_0; i &lt;= TR01_PAIRING_KEY_SLOT_INDEX_3; i++) {\n        LT_LOG_INFO(\"\\tWriting pairing key slot %\" PRIu8 \"...\", i);\n        ret = lt_pairing_key_write(h, dummy_key, i);\n        if (LT_L3_UNAUTHORIZED != ret) {\n            LT_LOG_ERROR(\"Return value is not LT_L3_UNAUTHORIZED, ret=%s\", lt_ret_verbose(ret));\n            return -1;\n        }\n        LT_LOG_INFO(\"\\t\\tOK\");\n    }\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n\nint lt_ex_hardware_wallet(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"==========================================\");\n    LT_LOG_INFO(\"==== TROPIC01 Hardware Wallet Example ====\");\n    LT_LOG_INFO(\"==========================================\");\n\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"Initial session with pairing key slot 0\");\n    if (session_initial(h) == -1) {\n        if (h-&gt;l3.session_status == LT_SECURE_SESSION_ON) lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Session with pairing key slot 0\");\n    if (session0(h) == -1) {\n        if (h-&gt;l3.session_status == LT_SECURE_SESSION_ON) lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Session with pairing key slot 1\");\n    if (session1(h) == -1) {\n        if (h-&gt;l3.session_status == LT_SECURE_SESSION_ON) lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Session with pairing key slot 2\");\n    if (session2(h) == -1) {\n        if (h-&gt;l3.session_status == LT_SECURE_SESSION_ON) lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Session with pairing key slot 3\");\n    if (session3(h) == -1) {\n        if (h-&gt;l3.session_status == LT_SECURE_SESSION_ON) lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"get_started/examples/irreversible_examples/#lt_ex_fw_updatec","title":"lt_ex_fw_update.c","text":"<ul> <li>\u26a0\ufe0f Irreversible</li> <li>\u274c Incompatible with the model</li> <li>\ud83d\udc24 Level: Moderate</li> </ul> <p>This example explains the firmware update process for both ABAB and ACAB silicon revisions. Use this example as a reference for integrating TROPIC01 firmware updates into your application. You will learn:</p> <ul> <li>How to read the current firmware versions.</li> <li>How to update the firmware using <code>lt_do_mutable_fw_update()</code>.</li> </ul> Source code <pre><code>/**\n * @file lt_ex_fw_update.c\n * @name Firmware update\n * @brief This code performs firmware update of TROPIC01 chip, works on both ABAB and ACAB silicon revisions.\n *\n * @author Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include &lt;inttypes.h&gt;\n\n#include \"fw_CPU.h\"\n#include \"fw_SPECT.h\"\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_examples.h\"\n#include \"libtropic_logging.h\"\n#include \"string.h\"\n\n/**\n * @brief Example how to update TROPIC01 firmware. Process is described in detail in 'ODN_TR01_app_007_fw_update.pdf'\n * Application Note.\n *\n * It is recommended to update both Application firmware banks with the same Application firmware\n * and both SPECT firmware banks with the same SPECT firmware.\n *\n * @param h Pointer to lt_handle_t structure\n * @returns 0 on success, -1 otherwise\n */\n\nint lt_ex_fw_update(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"====================================\");\n    LT_LOG_INFO(\"==== TROPIC01 FW update Example ====\");\n    LT_LOG_INFO(\"====================================\");\n\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    // The chip must be rebooted into MAINTENANCE mode to perform a firmware update.\n    LT_LOG_LINE();\n    LT_LOG_INFO(\"Updating TR01_FW_BANK_FW1 and TR01_FW_BANK_SPECT1\");\n    LT_LOG_INFO(\"Rebooting into Maintenance mode\");\n    ret = lt_reboot(h, TR01_MAINTENANCE_REBOOT);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"lt_reboot() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    if (h-&gt;l2.mode == LT_TR01_MAINTENANCE_MODE) {\n        LT_LOG_INFO(\"Chip is in maintenance mode, executing bootloader\");\n        LT_LOG_INFO(\"Updating RISC-V FW\");\n        ret = lt_do_mutable_fw_update(h, fw_CPU, sizeof(fw_CPU), TR01_FW_BANK_FW1);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"RISC-V FW update failed, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n        LT_LOG_INFO(\"OK\");\n\n        LT_LOG_INFO(\"Updating SPECT FW\");\n        ret = lt_do_mutable_fw_update(h, fw_SPECT, sizeof(fw_SPECT), TR01_FW_BANK_SPECT1);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"SPECT FW update failed, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n        LT_LOG_INFO(\"OK\");\n    }\n    else {\n        LT_LOG_ERROR(\"Chip couldn't get into MAINTENANCE mode\");\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    // The chip must be rebooted into MAINTENANCE mode to perform a firmware update.\n    LT_LOG_INFO(\"Updating TR01_FW_BANK_FW2 and TR01_FW_BANK_SPECT2\");\n    LT_LOG_INFO(\"Rebooting into Maintenance mode\");\n    ret = lt_reboot(h, TR01_MAINTENANCE_REBOOT);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"lt_reboot() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    if (h-&gt;l2.mode == LT_TR01_MAINTENANCE_MODE) {\n        LT_LOG_INFO(\"Chip is in maintenance mode, executing bootloader\");\n        LT_LOG_INFO(\"Updating RISC-V FW\");\n        ret = lt_do_mutable_fw_update(h, fw_CPU, sizeof(fw_CPU), TR01_FW_BANK_FW2);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"RISC-V FW update failed, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n        LT_LOG_INFO(\"OK\");\n\n        LT_LOG_INFO(\"Updating SPECT FW\");\n        ret = lt_do_mutable_fw_update(h, fw_SPECT, sizeof(fw_SPECT), TR01_FW_BANK_SPECT2);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"SPECT FW update failed, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n        LT_LOG_INFO(\"OK\");\n    }\n    else {\n        LT_LOG_ERROR(\"Chip couldn't get into MAINTENANCE mode\");\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_LINE();\n    LT_LOG(\"Successfully updated all 4 FW banks\");\n    LT_LOG_LINE();\n\n    ret = lt_print_fw_header(h, TR01_FW_BANK_FW1, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_FW1 header, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    ret = lt_print_fw_header(h, TR01_FW_BANK_FW2, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_FW2 header, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    ret = lt_print_fw_header(h, TR01_FW_BANK_SPECT1, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_SPECT1 header, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    ret = lt_print_fw_header(h, TR01_FW_BANK_SPECT2, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_SPECT2 header, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Rebooting into Application mode\");\n    ret = lt_reboot(h, TR01_REBOOT);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"lt_reboot() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    if (h-&gt;l2.mode == LT_TR01_APP_MODE) {\n        LT_LOG_INFO(\"Chip is executing firmwares of following versions:\");\n        LT_LOG_INFO(\"Reading RISC-V FW version\");\n        // This variable is reused on more places in this block to store different firmware versions\n        uint8_t fw_ver[TR01_L2_GET_INFO_RISCV_FW_SIZE] = {0};\n\n        ret = lt_get_info_riscv_fw_ver(h, fw_ver);\n        if (ret == LT_OK) {\n            LT_LOG_INFO(\"Chip is executing RISC-V application FW version: %02\" PRIX8 \".%02\" PRIX8 \".%02\" PRIX8\n                        \"    (+ .%02\" PRIX8 \")\",\n                        fw_ver[3], fw_ver[2], fw_ver[1], fw_ver[0]);\n        }\n        else {\n            LT_LOG_ERROR(\"Failed to get RISC-V FW version, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n\n        LT_LOG_INFO(\"Reading SPECT FW version\");\n        ret = lt_get_info_spect_fw_ver(h, fw_ver);\n        if (ret == LT_OK) {\n            LT_LOG_INFO(\"Chip is executing SPECT firmware version: %02\" PRIX8 \".%02\" PRIX8 \".%02\" PRIX8\n                        \"    (+ .%02\" PRIX8 \")\",\n                        fw_ver[3], fw_ver[2], fw_ver[1], fw_ver[0]);\n        }\n        else {\n            LT_LOG_ERROR(\"Failed to get SPECT firmware version, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n    }\n    else {\n        LT_LOG_ERROR(\"Chip couldn't get into APP mode, APP and SPECT firmwares in fw banks are not valid\");\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"get_started/examples/reversible_examples/","title":"Reversible Examples","text":"<p>To provide better orientation, we highlight specific properties of each example, namely:</p> <ul> <li>Reversibility,</li> <li>Model compatibility,</li> <li>Level of complexity (\ud83d\udc23 -&gt; \ud83d\udc24 -&gt; \ud83d\udc13).</li> </ul> <p>The source code for the examples can be found in the <code>examples/</code> directory and also within this document inside \"Source code\" boxes.</p> <p>Tip</p> <p>You can copy the example code using the  icon located in the top-right corner of each source code listing.</p>"},{"location":"get_started/examples/reversible_examples/#lt_ex_hello_worldc","title":"lt_ex_hello_world.c","text":"<ul> <li>\u2705 Reversible</li> <li>\u2705 Compatible with the model</li> <li>\ud83d\udc23 Level: Basic</li> </ul> <p>This example demonstrates the basic libtropic API and can be used to verify that the chip works correctly. In this example, you will learn about the following functions:</p> <ul> <li><code>lt_init()</code>: function used to initialize context for communication with the TROPIC01,</li> <li><code>lt_verify_chip_and_start_secure_session()</code>: helper function to start Secure Session and allow L3 communication,</li> <li><code>lt_ping()</code>: L3 command to verify communication with the TROPIC01,</li> <li><code>lt_session_abort()</code>: L3 command to abort Secure Session,</li> <li><code>lt_deinit()</code>: function used to deinitialize context.</li> </ul> Source code <pre><code>/**\n * @file lt_ex_hello_world.c\n * @brief Establishes Secure Session and executes Ping L3 command.\n * @author Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_examples.h\"\n#include \"libtropic_logging.h\"\n\n/** @brief Message to send with Ping L3 command. */\n#define PING_MSG \"This is Hello World message from TROPIC01!!\"\n/** @brief Size of the Ping message, including '\\0'. */\n#define PING_MSG_SIZE 44\n\nint lt_ex_hello_world(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"======================================\");\n    LT_LOG_INFO(\"==== TROPIC01 Hello World Example ====\");\n    LT_LOG_INFO(\"======================================\");\n\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_verify_chip_and_start_secure_session(h, sh0priv, sh0pub, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to start Secure Session with key %d, ret=%s\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0,\n                     lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    uint8_t recv_buf[PING_MSG_SIZE];\n    LT_LOG_INFO(\"Sending Ping command with message:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", PING_MSG);\n    ret = lt_ping(h, (const uint8_t *)PING_MSG, recv_buf, PING_MSG_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Ping command failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Message received from TROPIC01:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", recv_buf);\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"get_started/examples/reversible_examples/#lt_ex_show_chip_id_and_fwverc","title":"lt_ex_show_chip_id_and_fwver.c","text":"<ul> <li>\u2705 Reversible</li> <li>\u2705 Compatible with the model</li> <li>\ud83d\udc23 Level: Basic</li> </ul> <p>Demonstrates how to read and display the chip\u2019s unique ID and firmware version information (bootloader, application and SPECT firmware versions). You will learn about following functions:</p> <ul> <li><code>lt_reboot()</code>: L2 request to reboot to either application or maintenance mode,</li> <li><code>lt_get_info_riscv_fw_ver()</code>, <code>lt_get_info_spect_fw_ver()</code>: L2 requests to read CPU and SPECT firmware versions,</li> <li><code>lt_get_info_chip_id()</code>: L2 request to read chip identification (e.g., serial number),</li> </ul> Source code <pre><code>/**\n * @file lt_ex_show_chip_id_and_fwver.c\n * @name Show chip ID and firmware versions\n * @brief This example shows how to read TROPIC01's chip ID and firmware versions\n * @note We recommend reading TROPIC01's datasheet before diving into this example!\n *\n * @author Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include &lt;inttypes.h&gt;\n\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_examples.h\"\n#include \"libtropic_logging.h\"\n#include \"string.h\"\n\nint lt_ex_show_chip_id_and_fwver(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"=============================================================\");\n    LT_LOG_INFO(\"==== TROPIC01 show chip ID and firmware versions example ====\");\n    LT_LOG_INFO(\"=============================================================\");\n\n    // This variable is reused on more places in this example to store different firmware versions\n    uint8_t fw_ver[TR01_L2_GET_INFO_RISCV_FW_SIZE] = {0};\n\n    lt_ret_t ret = lt_init(h);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    // First we check versions of both updateable firmwares. For this we need to be in APPLICATION mode.\n    // If there are valid firmwares, chip will execute them on boot. In any case we will try to reboot into application,\n    // in case chip would be in maintenance mode (executing bootloader)\n    LT_LOG_INFO(\"Rebooting into APPLICATION mode to check FW versions\");\n    ret = lt_reboot(h, TR01_REBOOT);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"lt_reboot() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    if (h-&gt;l2.mode == LT_TR01_APP_MODE) {\n        // App runs so we can see what firmwares are running\n        // Getting RISCV app firmware version\n        LT_LOG_INFO(\"Reading RISC-V FW version\");\n        ret = lt_get_info_riscv_fw_ver(h, fw_ver);\n        if (ret == LT_OK) {\n            LT_LOG_INFO(\"Chip is executing RISC-V application FW version: %02\" PRIX8 \".%02\" PRIX8 \".%02\" PRIX8\n                        \"    (+ .%02\" PRIX8 \")\",\n                        fw_ver[3], fw_ver[2], fw_ver[1], fw_ver[0]);\n        }\n        else {\n            LT_LOG_ERROR(\"Failed to get RISC-V FW version, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n\n        LT_LOG_INFO(\"Reading SPECT FW version\");\n        ret = lt_get_info_spect_fw_ver(h, fw_ver);\n        if (ret == LT_OK) {\n            LT_LOG_INFO(\"Chip is executing SPECT firmware version: %02\" PRIX8 \".%02\" PRIX8 \".%02\" PRIX8\n                        \"    (+ .%02\" PRIX8 \")\",\n                        fw_ver[3], fw_ver[2], fw_ver[1], fw_ver[0]);\n        }\n        else {\n            LT_LOG_ERROR(\"Failed to get SPECT firmware version, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n    }\n    else {\n        LT_LOG_ERROR(\"Chip couldn't get into APP mode, APP and SPECT firmwares in fw banks are not valid\");\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Rebooting into MAINTENANCE mode to check bootloader version and fw bank headers\");\n    ret = lt_reboot(h, TR01_MAINTENANCE_REBOOT);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to reboot into MAINTENANCE mode, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    if (h-&gt;l2.mode == LT_TR01_MAINTENANCE_MODE) {\n        LT_LOG_INFO(\"Reading RISC-V FW version (during maintenance chip actually returns bootloader version):\");\n        ret = lt_get_info_riscv_fw_ver(h, fw_ver);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed to get RISC-V FW version, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n\n        LT_LOG_INFO(\"Bootloader version: %02\" PRIX8 \".%02\" PRIX8 \".%02\" PRIX8 \"    (+ .%02\" PRIX8 \")\", fw_ver[3] &amp; 0x7f,\n                    fw_ver[2], fw_ver[1], fw_ver[0]);\n        LT_LOG_LINE();\n\n        LT_LOG_INFO(\"Reading and printing headers of all 4 FW banks:\");\n        ret = lt_print_fw_header(h, TR01_FW_BANK_FW1, printf);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_FW1 header, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n        ret = lt_print_fw_header(h, TR01_FW_BANK_FW2, printf);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_FW2 header, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n        ret = lt_print_fw_header(h, TR01_FW_BANK_SPECT1, printf);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_SPECT1 header, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n        ret = lt_print_fw_header(h, TR01_FW_BANK_SPECT2, printf);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed to print TR01_FW_BANK_SPECT2 header, ret=%s\", lt_ret_verbose(ret));\n            lt_deinit(h);\n            return -1;\n        }\n    }\n    else {\n        LT_LOG_ERROR(\"Chip couldn't get into MAINTENANCE mode\");\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    struct lt_chip_id_t chip_id = {0};\n\n    LT_LOG_INFO(\"Reading Chip ID:\");\n    ret = lt_get_info_chip_id(h, &amp;chip_id);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to get chip ID, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    ret = lt_print_chip_id(&amp;chip_id, printf);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to print chip ID, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"get_started/examples/reversible_examples/#lt_ex_hello_world_separate_apic","title":"lt_ex_hello_world_separate_API.c","text":"<ul> <li>\u2705 Reversible</li> <li>\u2705 Compatible with the model</li> <li>\ud83d\udc24 Level: Moderate</li> </ul> <p>Functionally similar to <code>lt_ex_hello_world.c</code>, but it uses distinct API calls for incoming and outgoing data. This approach is useful for secure, tunneled communication, such as during chip provisioning in a factory.</p> <p>You will learn about low-level API functions used to process outgoing and incoming data. For example:</p> <ul> <li><code>lt_out__session_start()</code>: prepare Handshake_Req L2 request (for Secure Session establishment),</li> <li><code>lt_l2_send()</code>: send L2 request,</li> <li><code>lt_l2_receive()</code>: receive L2 response.</li> <li><code>lt_in__session_start()</code>: process L2 response to the Handshake_Req,</li> </ul> Source code <pre><code>/**\n * @file lt_ex_hello_world_separate_API.c\n * @brief Establishes Secure Session and executes Ping L3 command using separated API.\n * @author Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include \"libtropic.h\"\n#include \"libtropic_examples.h\"\n#include \"libtropic_l2.h\"\n#include \"libtropic_l3.h\"\n#include \"libtropic_logging.h\"\n\n/** @brief Message to send with Ping L3 command. */\n#define PING_MSG \"This is Hello World message from TROPIC01!!\"\n/** @brief Size of the Ping message, including '\\0'. */\n#define PING_MSG_SIZE 44\n\nint lt_ex_hello_world_separate_API(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"=========================================================\");\n    LT_LOG_INFO(\"====  TROPIC01 Hello World with Separate API Example ====\");\n    LT_LOG_INFO(\"=========================================================\");\n\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Getting Certificate Store from TROPIC01\");\n    uint8_t cert1[TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE], cert2[TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE],\n        cert3[TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE], cert4[TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE];\n    struct lt_cert_store_t store\n        = {.certs = {cert1, cert2, cert3, cert4},\n           .buf_len = {TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE, TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE,\n                       TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE, TR01_L2_GET_INFO_REQ_CERT_SIZE_SINGLE}};\n    ret = lt_get_info_cert_store(h, &amp;store);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to get Certificate Store, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    // Get only stpub, we don't verify certificate chain here\n    LT_LOG_INFO(\"Getting stpub key from Certificate Store\");\n    uint8_t stpub[TR01_STPUB_LEN];\n    ret = lt_get_st_pub(&amp;store, stpub);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to get stpub key, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    //---------------------------------------------------------------------------------------//\n    // Separated API calls for starting a secure session:\n    lt_host_eph_keys_t host_eph_keys = {0};\n\n    // Initialize session from a server side by creating host_eph_keys-&gt;ehpriv and host_eph_keys-&gt;ehpub,\n    // l2 request is prepared into handle's buffer (h-&gt;l2_buff)\n    LT_LOG_INFO(\"Executing lt_out__session_start()...\");\n    ret = lt_out__session_start(h, TR01_PAIRING_KEY_SLOT_INDEX_0, &amp;host_eph_keys);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_out__session_start() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    // handle's buffer (h-&gt;l2_buff) now contains data which must be transferred over tunnel to TROPIC01\n\n    // Following l2 functions are called on remote host\n    LT_LOG_INFO(\"Executing lt_l2_send()...\");\n    ret = lt_l2_send(&amp;h-&gt;l2);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_l2_send() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"Executing lt_l2_receive()...\");\n    ret = lt_l2_receive(&amp;h-&gt;l2);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_l2_receive() failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    // Handle's buffer (h-&gt;l2_buff) now contains data which must be transferred over tunnel back to the server\n\n    // Once data are back on server's side, bytes are copied into h-&gt;l2_buff\n    // Then following l2 function is called on server side\n    // This function establishes gcm contexts for a session\n    LT_LOG_INFO(\"Executing lt_in__session_start()...\");\n    ret = lt_in__session_start(h, stpub, TR01_PAIRING_KEY_SLOT_INDEX_0, sh0priv, sh0pub, &amp;host_eph_keys);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_in__session_start failed, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_LINE();\n\n    // Now we can use lt_ping() to send a message to TROPIC01 and receive a response, this is done with separate API\n    // calls\n    uint8_t recv_buf[PING_MSG_SIZE];\n    LT_LOG_INFO(\"Executing lt_out__ping() with message:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", PING_MSG);\n    ret = lt_out__ping(h, (const uint8_t *)PING_MSG, PING_MSG_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_out__ping failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Executing lt_l2_send_encrypted_cmd()...\");\n    ret = lt_l2_send_encrypted_cmd(&amp;h-&gt;l2, h-&gt;l3.buff, h-&gt;l3.buff_len);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_l2_send_encrypted_cmd failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"Executing lt_l2_recv_encrypted_res()...\");\n    ret = lt_l2_recv_encrypted_res(&amp;h-&gt;l2, h-&gt;l3.buff, h-&gt;l3.buff_len);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_l2_recv_encrypted_res failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Executing lt_in__ping()...\");\n    ret = lt_in__ping(h, recv_buf, PING_MSG_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_in__ping failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Message received from TROPIC01:\");\n    LT_LOG_INFO(\"\\t\\\"%s\\\"\", recv_buf);\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"get_started/examples/reversible_examples/#lt_ex_macanddc","title":"lt_ex_macandd.c","text":"<ul> <li>\u2705 Reversible</li> <li>\u2705 Compatible with the model</li> <li>\ud83d\udc13 Level: Advanced</li> </ul> <p>This example illustrates the MAC-and-destroy feature. You will learn about the following functions:</p> <ul> <li><code>lt_hmac_sha256()</code>: function to compute HMAC based on SHA256,</li> <li><code>lt_mac_and_destroy()</code>: L3 command to process MAC-and-Destroy operation,</li> <li><code>lt_r_mem_data_erase()</code>: L3 command to erase R-memory data slot,</li> <li><code>lt_r_mem_data_write()</code>: L3 command to write R-memory data slot,</li> <li><code>lt_r_mem_data_read()</code>: L3 command to read R-memory data slot,</li> <li><code>lt_random_bytes()</code>: function to generate random number using platform's RNG (not TROPIC01's),</li> </ul> <p>In this example, we also define two functions to implement PIN verification functionality: <code>lt_PIN_set()</code> and <code>lt_PIN_check()</code>. You can use these functions as inspiration for your project.</p> <p>You can find more information in the application note and code comments.</p> Source code <pre><code>/**\n * @file lt_ex_macandd.c\n * @brief Example usage of TROPIC01 flagship feature - 'Mac And Destroy' PIN verification engine.\n * For more info please refer to ODN_TR01_app_002_pin_verif.pdf\n * @author Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include &lt;inttypes.h&gt;\n\n#include \"libtropic.h\"\n#include \"libtropic_examples.h\"\n#include \"libtropic_logging.h\"\n#include \"string.h\"\n\n// Needed to access to lt_random_bytes()\n#include \"lt_random.h\"\n// Needed to access HMAC_SHA256\n#include \"lt_hmac_sha256.h\"\n\n/** @brief Last slot in User memory used for storing of M&amp;D related data (only in this example). */\n#define R_MEM_DATA_SLOT_MACANDD (511)\n/** @brief The size of random data passed during MAC-and-Destroy PIN set */\n#define TR01_MAC_AND_DESTROY_MASTER_SECRET_SIZE 32u\n\n/** @brief Size of the print buffer. */\n#define PRINT_BUFF_SIZE 196\n\n#ifndef MACANDD_ROUNDS\n#define MACANDD_ROUNDS 12\n#endif\n\n#if (MACANDD_ROUNDS &gt; 12)\n#error \\\n    \"MACANDD_ROUNDS must be less than 12 here, or generally than TR01_MACANDD_ROUNDS_MAX. Read explanation at the beginning of this file\"\n#endif\n\n/** @brief Minimal size of MAC-and-Destroy additional data */\n#define MAC_AND_DESTROY_ADD_SIZE_MIN 0\n/** @brief Maximal size of MAC-and-Destroy additional data */\n#define MAC_AND_DESTROY_ADD_SIZE_MAX 128u\n/** @brief Minimal size of MAC-and-Destroy PIN input */\n#define MAC_AND_DESTROY_PIN_SIZE_MIN 4u\n/** @brief Maximal size of MAC-and-Destroy PIN input */\n#define MAC_AND_DESTROY_PIN_SIZE_MAX 8u\n\n/**\n * @brief This structure holds data used by host during MAC and Destroy sequence\n * Content of this struct must be stored in non-volatile memory, because it is used\n * between power cycles\n */\nstruct lt_macandd_nvm_t {\n    uint8_t i;\n    uint8_t ci[MACANDD_ROUNDS * TR01_MAC_AND_DESTROY_DATA_SIZE];\n    uint8_t t[LT_HMAC_SHA256_HASH_LEN];\n} __attribute__((__packed__));\n\n/**\n * @brief Simple XOR \"encryption\" function. Replace with another encryption algorithm if needed.\n *\n * @param data         32B of data to be encrypted\n * @param key          32B key used for encryption\n * @param destination  Buffer into which 32B of encrypted data will be placed\n */\nstatic void encrypt(const uint8_t *data, const uint8_t *key, uint8_t *destination)\n{\n    for (uint8_t i = 0; i &lt; 32; i++) {\n        destination[i] = data[i] ^ key[i];\n    }\n}\n\n/**\n * @brief Simple XOR \"decryption\" function. Replace with another decryption algorithm if needed.\n *\n * @param data         32B of data to be decrypted\n * @param key          32B key used for decryption\n * @param destination  Buffer into which 32B of decrypted data will be placed\n */\nstatic void decrypt(const uint8_t *data, const uint8_t *key, uint8_t *destination)\n{\n    for (uint8_t i = 0; i &lt; 32; i++) {\n        destination[i] = data[i] ^ key[i];  //*(data + i) ^= *(key + i);\n    }\n}\n\n/**\n * @brief Example function for setting PIN with Mac And Destroy.\n *\n * @details The New PIN Setup procedure takes the user PIN, add data and high entropy master_secret as an input,\n * initializes the scheme slots and returns a 32-byte key final_key as derivative of the master_secret.\n *\n * The MAC-and-Destroy PIN veri\ufb01cation scheme uses slots located in the TROPIC01\u2019s \ufb02ash memory \u2013 one slot per\n * PIN entry attempt. These slots are \ufb01rst initialized when a new PIN is being set up.\n * The slots are then invalidated (destroyed) one by one with each PIN entry attempt. When the correct PIN is\n * entered, the slots are initialized again, therefore the PIN entry limit is reset.\n * PIN entry attempt fails if:\n *  * PIN is invalid\n *  * The current slot is not initialized for a given PIN\n *  * The current slot is destroyed by previous invalid PIN entry attempt.\n *\n * There are more ways how to implement Mac And Destroy 'PIN set' functionality, differences could be in way of\n * handling nvm data, number of tries, algorithm used for encryption, etc. This function is just one of the possible\n * implementations of \"PIN set\".\n *\n * Take it as an inspiration, copy it into your project and adapt it to your specific hw resources.\n *\n * @param h           Device's handle\n * @param master_secret  32 bytes of random data (determines final_key)\n * @param PIN         Array of bytes (size between MAC_AND_DESTROY_PIN_SIZE_MIN and MAC_AND_DESTROY_PIN_SIZE_MAX)\n * representing PIN\n * @param PIN_size    Length of the PIN field\n * @param add         Additional data to be used in M&amp;D sequence (size between MAC_AND_DESTROY_ADD_SIZE_MIN and\n * MAC_AND_DESTROY_ADD_SIZE_MAX).\n * @param add_size    Length of additional data\n * @param final_key      Buffer into which final key will be placed when all went successfully\n * @return lt_ret_t   LT_OK if correct, otherwise LT_FAIL\n */\nstatic lt_ret_t lt_new_PIN_setup(lt_handle_t *h, const uint8_t *master_secret, const uint8_t *PIN,\n                                 const uint8_t PIN_size, const uint8_t *add, const uint8_t add_size, uint8_t *final_key)\n{\n    if (!h || !master_secret || !PIN || (PIN_size &lt; MAC_AND_DESTROY_PIN_SIZE_MIN)\n        || (PIN_size &gt; MAC_AND_DESTROY_PIN_SIZE_MAX) || (add_size &gt; MAC_AND_DESTROY_ADD_SIZE_MAX) || !add\n        || !final_key) {\n        return LT_PARAM_ERR;\n    }\n    if (h-&gt;l3.session_status != LT_SECURE_SESSION_ON) {\n        return LT_HOST_NO_SESSION;\n    }\n\n    // Clear variable for released final_key so there is known data (zeroes) in case this function ended sooner then\n    // final_key was prepared\n    memset(final_key, 0, TR01_MAC_AND_DESTROY_DATA_SIZE);\n\n    // Variable used during a process of getting a encryption key k_i\n    uint8_t v[LT_HMAC_SHA256_HASH_LEN] = {0};\n    // Variable used during a process of getting a encryption key k_i\n    uint8_t w_i[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n    // Encryption key\n    uint8_t k_i[LT_HMAC_SHA256_HASH_LEN] = {0};\n    // Variable used to initialize slot(s)\n    uint8_t u[LT_HMAC_SHA256_HASH_LEN] = {0};\n\n    // This organizes data which will be stored into nvm\n    struct lt_macandd_nvm_t nvm = {0};\n\n    // User is expected to pass not only PIN, but might also pass another data(e.g. HW ID, ...)\n    // Both arrays are concatenated and used together as an input for KDF\n    uint8_t kdf_input_buff[MAC_AND_DESTROY_PIN_SIZE_MAX + MAC_AND_DESTROY_ADD_SIZE_MAX];\n    memcpy(kdf_input_buff, PIN, PIN_size);\n    memcpy(kdf_input_buff + PIN_size, add, add_size);\n\n    // Erase a slot in R memory, which will be used as a storage for NVM data\n    LT_LOG_INFO(\"Erasing R_Mem User slot %d...\", R_MEM_DATA_SLOT_MACANDD);\n    lt_ret_t ret = lt_r_mem_data_erase(h, R_MEM_DATA_SLOT_MACANDD);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to erase User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // Store number of attempts\n    nvm.i = MACANDD_ROUNDS;\n    // Compute tag t = KDF(s, 0x00), save into nvm struct\n    // Tag will be later used during lt_PIN_entry_check() to verify validity of final_key\n    lt_hmac_sha256(master_secret, TR01_MAC_AND_DESTROY_MASTER_SECRET_SIZE, (uint8_t[]){0x00}, 1, nvm.t);\n\n    // Compute u = KDF(s, 0x01)\n    // This value will be sent through M&amp;D sequence to initialize a slot\n    lt_hmac_sha256(master_secret, TR01_MAC_AND_DESTROY_MASTER_SECRET_SIZE, (uint8_t[]){0x01}, 1, u);\n\n    // Compute v = KDF(0, PIN||A) where 0 is all zeroes key\n    const uint8_t zeros[32] = {0};\n    lt_hmac_sha256(zeros, sizeof(zeros), kdf_input_buff, PIN_size + add_size, v);\n\n    for (int i = 0; i &lt; nvm.i; i++) {\n        uint8_t ignore[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n\n        // This call of a M&amp;D sequence results in initialization of one slot\n        LT_LOG_INFO(\"Doing M&amp;D sequence to initialize a slot...\");\n        ret = lt_mac_and_destroy(h, i, u, ignore);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed while doing M&amp;D sequence, ret=%s\", lt_ret_verbose(ret));\n            goto exit;\n        }\n        LT_LOG_INFO(\"\\tOK\");\n\n        // This call of a M&amp;D sequence overwrites a previous slot, but key w is returned.\n        // This key is later used to derive k_i (used to encrypt precious final_key)\n        LT_LOG_INFO(\"Doing M&amp;D sequence to overwrite previous slot...\");\n        ret = lt_mac_and_destroy(h, i, v, w_i);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed while doing M&amp;D sequence, ret=%s\", lt_ret_verbose(ret));\n            goto exit;\n        }\n        LT_LOG_INFO(\"\\tOK\");\n\n        // Now the slot is initialized again by calling M&amp;D sequence again with 'u'\n        LT_LOG_INFO(\"Doing M&amp;D sequence again to initialize a slot...\");\n        ret = lt_mac_and_destroy(h, i, u, ignore);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed while doing M&amp;D sequence, ret=%s\", lt_ret_verbose(ret));\n            goto exit;\n        }\n        LT_LOG_INFO(\"\\tOK\");\n\n        // Derive k_i = KDF(w_i, PIN||A); k_i will be used to encrypt master_secret\n        lt_hmac_sha256(w_i, sizeof(w_i), kdf_input_buff, PIN_size + add_size, k_i);\n\n        // Encrypt master_secret using k_i as a key and store ciphertext into non volatile storage\n        encrypt(master_secret, k_i, nvm.ci + (i * TR01_MAC_AND_DESTROY_DATA_SIZE));\n    }\n\n    // Persistently save nvm data into TROPIC01's R memory slot\n    LT_LOG_INFO(\"Writing NVM data into R_Mem User slot %d...\", R_MEM_DATA_SLOT_MACANDD);\n    ret = lt_r_mem_data_write(h, R_MEM_DATA_SLOT_MACANDD, (uint8_t *)&amp;nvm, sizeof(nvm));\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to write User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n\n    // final_key is released to the caller\n    lt_hmac_sha256(master_secret, TR01_MAC_AND_DESTROY_MASTER_SECRET_SIZE, (uint8_t *)\"2\", 1, final_key);\n\n// Cleanup all sensitive data from memory\nexit:\n    memset(kdf_input_buff, 0, PIN_size + add_size);\n    memset(u, 0, sizeof(u));\n    memset(v, 0, sizeof(v));\n    memset(w_i, 0, sizeof(w_i));\n    memset(k_i, 0, sizeof(k_i));\n\n    return ret;\n}\n\n/**\n * @brief Example function for checking PIN with Mac And Destroy.\n *\n * @details The Pin Entry Check procedure takes the PIN and additional add data entered by the user as an input, and\n * checks the PIN. If successful, the correct key k is returned.\n *\n * There are more ways how to implement Mac And Destroy 'PIN check' functionality, differences could be in way\n * of handling nvm data, number of tries, algorithm used for decryption, etc. This function is just one of the possible\n * implementations of \"PIN check\".\n *\n * Take it as an inspiration, copy it into your project and adapt it to your specific hw resources.\n *\n * @param h           Device's handle\n * @param PIN         Array of bytes (size between MAC_AND_DESTROY_PIN_SIZE_MIN and MAC_AND_DESTROY_PIN_SIZE_MAX)\n * representing PIN\n * @param PIN_size    Length of the PIN field\n * @param add         Additional data to be used in M&amp;D sequence (size between MAC_AND_DESTROY_ADD_SIZE_MIN and\n * MAC_AND_DESTROY_ADD_SIZE_MAX).\n * @param add_size    Length of additional data\n * @param final_key   Buffer into which final_key will be saved\n * @return lt_ret_t   LT_OK if correct, otherwise LT_FAIL\n */\nstatic lt_ret_t lt_PIN_entry_check(lt_handle_t *h, const uint8_t *PIN, const uint8_t PIN_size, const uint8_t *add,\n                                   const uint8_t add_size, uint8_t *final_key)\n{\n    if (!h || !PIN || (PIN_size &lt; MAC_AND_DESTROY_PIN_SIZE_MIN) || (PIN_size &gt; MAC_AND_DESTROY_PIN_SIZE_MAX)\n        || (add_size &gt; MAC_AND_DESTROY_ADD_SIZE_MAX) || !add || !final_key) {\n        return LT_PARAM_ERR;\n    }\n    if (h-&gt;l3.session_status != LT_SECURE_SESSION_ON) {\n        return LT_HOST_NO_SESSION;\n    }\n\n    // Clear variable for released final_key so there is known data (zeroes) in case this function ended sooner then\n    // final_key was prepared\n    memset(final_key, 0, TR01_MAC_AND_DESTROY_DATA_SIZE);\n\n    // Variable used during a process of getting a decryption key k_i\n    uint8_t v_[LT_HMAC_SHA256_HASH_LEN] = {0};\n    // Variable used during a process of getting a decryption key k_i\n    uint8_t w_i[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n    // Decryption key\n    uint8_t k_i[LT_HMAC_SHA256_HASH_LEN] = {0};\n    // Secret\n    uint8_t s_[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n    // Tag\n    uint8_t t_[LT_HMAC_SHA256_HASH_LEN] = {0};\n    // Value used to initialize Mac And Destroy's slot after a correct PIN try\n    uint8_t u[LT_HMAC_SHA256_HASH_LEN] = {0};\n\n    // This organizes data which will be read from nvm\n    struct lt_macandd_nvm_t nvm = {0};\n\n    // User might pass not only PIN, but also another data(e.g. HW ID, ...) if needed\n    // Both arrays are concatenated and used together as an input for KDF\n    uint8_t kdf_input_buff[MAC_AND_DESTROY_PIN_SIZE_MAX + MAC_AND_DESTROY_ADD_SIZE_MAX];\n    memcpy(kdf_input_buff, PIN, PIN_size);\n    memcpy(kdf_input_buff + PIN_size, add, add_size);\n\n    // Load M&amp;D data from TROPIC01's R memory\n    LT_LOG_INFO(\"Reading M&amp;D data from R_Mem User slot %d...\", R_MEM_DATA_SLOT_MACANDD);\n    uint16_t read_size;\n    lt_ret_t ret = lt_r_mem_data_read(h, R_MEM_DATA_SLOT_MACANDD, (uint8_t *)&amp;nvm, sizeof(nvm), &amp;read_size);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to read User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // if i == 0: FAIL (no attempts remaining)\n    LT_LOG_INFO(\"Checking if nvm.i != 0...\");\n    if (nvm.i == 0) {\n        LT_LOG_ERROR(\"nvm.i == 0\");\n        goto exit;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // Decrement variable which holds number of tries\n    // Let i = i - 1\n    nvm.i--;\n\n    // and store M&amp;D data back to TROPIC01's R memory\n    LT_LOG_INFO(\"Writing back M&amp;D data into R_Mem User slot %d (erase, then write)...\", R_MEM_DATA_SLOT_MACANDD);\n    ret = lt_r_mem_data_erase(h, R_MEM_DATA_SLOT_MACANDD);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to erase User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    ret = lt_r_mem_data_write(h, R_MEM_DATA_SLOT_MACANDD, (uint8_t *)&amp;nvm, sizeof(nvm));\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to write User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // Compute v\u2019 = KDF(0, PIN\u2019||A).\n    const uint8_t zeros[32] = {0};\n    lt_hmac_sha256(zeros, sizeof(zeros), kdf_input_buff, PIN_size + add_size, v_);\n\n    // Execute w\u2019 = MACANDD(i, v\u2019)\n    LT_LOG_INFO(\"Doing M&amp;D sequence...\");\n    ret = lt_mac_and_destroy(h, nvm.i, v_, w_i);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed while doing M&amp;D sequence, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // Compute k\u2019_i = KDF(w\u2019, PIN\u2019||A)\n    lt_hmac_sha256(w_i, sizeof(w_i), kdf_input_buff, PIN_size + add_size, k_i);\n\n    // Read the ciphertext c_i and tag t from NVM,\n    // decrypt c_i with k\u2019_i as the key and obtain s_\n    decrypt(nvm.ci + (nvm.i * TR01_MAC_AND_DESTROY_DATA_SIZE), k_i, s_);\n\n    // Compute tag t = KDF(s_, \"0x00\")\n    lt_hmac_sha256(s_, sizeof(s_), (uint8_t[]){0x00}, 1, t_);\n\n    // If t\u2019 != t: FAIL\n    if (memcmp(nvm.t, t_, sizeof(t_)) != 0) {\n        ret = LT_FAIL;\n        goto exit;\n    }\n\n    // Pin is correct, now initialize macandd slots again:\n    // Compute u = KDF(s\u2019, \"0x01\")\n    lt_hmac_sha256(s_, sizeof(s_), (uint8_t[]){0x01}, 1, u);\n\n    for (int x = nvm.i; x &lt; MACANDD_ROUNDS - 1; x++) {\n        uint8_t ignore[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n\n        LT_LOG_INFO(\"Doing M&amp;D sequence...\");\n        ret = lt_mac_and_destroy(h, x, u, ignore);\n        if (ret != LT_OK) {\n            LT_LOG_ERROR(\"Failed while doing M&amp;D sequence, ret=%s\", lt_ret_verbose(ret));\n            goto exit;\n        }\n        LT_LOG_INFO(\"\\tOK\");\n    }\n\n    // Set variable which holds number of tries back to initial state MACANDD_ROUNDS\n    nvm.i = MACANDD_ROUNDS;\n\n    // Store NVM data for future use\n    LT_LOG_INFO(\"Writing M&amp;D data into R_Mem User slot %d for future use (erase, then write)...\",\n                R_MEM_DATA_SLOT_MACANDD);\n    ret = lt_r_mem_data_erase(h, R_MEM_DATA_SLOT_MACANDD);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to erase User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    ret = lt_r_mem_data_write(h, R_MEM_DATA_SLOT_MACANDD, (uint8_t *)&amp;nvm, sizeof(nvm));\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to write User slot, ret=%s\", lt_ret_verbose(ret));\n        goto exit;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    // Calculate final_key and store it into passed array\n    lt_hmac_sha256(s_, sizeof(s_), (uint8_t *)\"2\", 1, final_key);\n\n// Cleanup all sensitive data from memory\nexit:\n    memset(kdf_input_buff, 0, PIN_size + add_size);\n    memset(w_i, 0, sizeof(w_i));\n    memset(k_i, 0, sizeof(k_i));\n    memset(v_, 0, sizeof(v_));\n\n    return ret;\n}\n\nint lt_ex_macandd(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"==========================================\");\n    LT_LOG_INFO(\"==== TROPIC01 Mac and Destroy Example ====\");\n    LT_LOG_INFO(\"==========================================\");\n\n    lt_ret_t ret;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    ret = lt_init(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to initialize handle, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_verify_chip_and_start_secure_session(h, sh0priv, sh0pub, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to start Secure Session with key %d, ret=%s\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0,\n                     lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    // This variable stores final_key which is released to the user after successful PIN check or PIN set\n    uint8_t final_key_initialized[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n\n    // Additional data passed by user besides PIN - this is optional, but recommended\n    uint8_t additional_data[]\n        = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,\n           0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88};\n    uint8_t additional_data_size = sizeof(additional_data);\n\n    // User's PIN\n    uint8_t pin[] = {1, 2, 3, 4};\n    uint8_t pin_wrong[] = {2, 2, 3, 4};\n\n    LT_LOG_LINE();\n\n    LT_LOG_INFO(\"Initializing Mac And Destroy\");\n    LT_LOG_INFO(\"Generating random master_secret...\");\n    uint8_t master_secret[TR01_MAC_AND_DESTROY_MASTER_SECRET_SIZE] = {0};\n    ret = lt_random_bytes(h, master_secret, TR01_MAC_AND_DESTROY_MASTER_SECRET_SIZE);\n    if (ret != LT_OK) {\n        LT_LOG_ERROR(\"Failed to get random bytes, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n    char print_buff[PRINT_BUFF_SIZE];\n    ret = lt_print_bytes(master_secret, sizeof(master_secret), print_buff, PRINT_BUFF_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_print_bytes failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"Generated master_secret: %s\", print_buff);\n\n    // Set the PIN and log out the final_key\n    LT_LOG(\"Setting the user PIN...\");\n    ret = lt_new_PIN_setup(h, master_secret, pin, sizeof(pin), NULL, additional_data_size, final_key_initialized);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to set the user PIN, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    ret = lt_print_bytes(final_key_initialized, sizeof(final_key_initialized), print_buff, PRINT_BUFF_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_print_bytes failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"Initialized final_key: %s\", print_buff);\n    LT_LOG_LINE();\n\n    uint8_t final_key_exported[TR01_MAC_AND_DESTROY_DATA_SIZE] = {0};\n    LT_LOG_INFO(\"Doing %d PIN check attempts with wrong PIN...\", MACANDD_ROUNDS);\n    for (int i = 1; i &lt; MACANDD_ROUNDS; i++) {\n        LT_LOG_INFO(\"\\tInputting wrong PIN -&gt; slot #%d destroyed\", i);\n        ret = lt_PIN_entry_check(h, pin_wrong, sizeof(pin_wrong), NULL, additional_data_size, final_key_exported);\n        if (LT_FAIL != ret) {\n            LT_LOG_ERROR(\"Return value is not LT_FAIL, ret=%s\", lt_ret_verbose(ret));\n            lt_session_abort(h);\n            lt_deinit(h);\n            return -1;\n        }\n        ret = lt_print_bytes(final_key_exported, sizeof(final_key_exported), print_buff, PRINT_BUFF_SIZE);\n        if (LT_OK != ret) {\n            LT_LOG_ERROR(\"lt_print_bytes failed, ret=%s\", lt_ret_verbose(ret));\n            lt_session_abort(h);\n            lt_deinit(h);\n            return -1;\n        }\n        LT_LOG_INFO(\"\\tSecret: %s\", print_buff);\n    }\n    LT_LOG_INFO(\"\\tOK\");\n\n    LT_LOG_INFO(\"Doing Final PIN attempt with correct PIN, slots are reinitialized again...\");\n    ret = lt_PIN_entry_check(h, pin, sizeof(pin), NULL, additional_data_size, final_key_exported);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Attempt with correct PIN failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    ret = lt_print_bytes(final_key_exported, sizeof(final_key_exported), print_buff, PRINT_BUFF_SIZE);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"lt_print_bytes failed, ret=%s\", lt_ret_verbose(ret));\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    LT_LOG_INFO(\"\\tExported final_key: %s\", print_buff);\n    LT_LOG_INFO(\"\\tOK\");\n    LT_LOG_LINE();\n\n    if (memcmp(final_key_initialized, final_key_exported, sizeof(final_key_initialized))) {\n        LT_LOG_ERROR(\"final_key and final_key_exported DO NOT MATCH\");\n        lt_session_abort(h);\n        lt_deinit(h);\n        return -1;\n    }\n    else {\n        LT_LOG_INFO(\"final_key and final_key_exported MATCH\");\n    }\n\n    LT_LOG_INFO(\"Aborting Secure Session\");\n    ret = lt_session_abort(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to abort Secure Session, ret=%s\", lt_ret_verbose(ret));\n        lt_deinit(h);\n        return -1;\n    }\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to deinitialize handle, ret=%s\", lt_ret_verbose(ret));\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"get_started/integrating_libtropic/","title":"Integrating Libtropic","text":"<p>This section provides guidance on integrating Libtropic into your application.</p> <ul> <li>Integration Examples</li> <li>Adding to an Existing Project</li> <li>Compiling as a Static Library</li> </ul>"},{"location":"get_started/integrating_libtropic/adding_to_project/","title":"Adding to an Existing Project","text":"<p>We recommend adding libtropic to an existing project as a git submodule. Libtropic uses CMake build system, therefore it could be added to compilation of existing CMake projects in a following way:</p> <pre><code># Your CMakeLists.txt file\n\n# Set path to the libtropic submodule. For example:\nset(PATH_LIBTROPIC ${CMAKE_CURRENT_SOURCE_DIR}/../libtropic/)\n\n# It is necessary to set provider of cryptography functions.\n# You can use e.g. trezor_crypto as the cryptography provider.\nset(LT_CRYPTO \"trezor_crypto\")\n\n# Add path to the libtropic's repository root folder.\nadd_subdirectory(${PATH_LIBTROPIC} \"libtropic\")\n\n# Add HAL functions to sources and includes depending on your platform.\n# For example, to include Linux SPI HAL to MY_PROJECTS_SOURCES source list:\nset(MY_PROJECT_SOURCES\n    ${PATH_LIBTROPIC}/hal/port/unix/libtropic_port_unix_spi.c\n)\ninclude_directories(\n    ${PATH_LIBTROPIC}/hal/port/unix\n)\n\n# Link libtropic with your binary.\ntarget_link_libraries(my_binary_name PRIVATE tropic)\n</code></pre> <p>Note</p> <p>The exact CMake calls depend on a configuration of the project into which libtropic is being added. For more inspiration, refer to the Integration Examples section and the CMake Documentation.</p> <p>Note</p> <p>We offer multiple CMake options - to see all of them, go to the beginning of the <code>CMakeLists.txt</code> file in the repository's root directory.</p>"},{"location":"get_started/integrating_libtropic/adding_to_project/#do-you-use-a-makefile-instead-of-cmake","title":"Do You Use a Makefile Instead of CMake?","text":"<p>If you use a Makefile instead of CMake, you need to:</p> <ol> <li>Manually list all <code>*.c</code> and <code>*.h</code> files from libtropic in your Makefile.</li> <li>For each required CMake option <code>&lt;CMAKE_OPTION&gt;</code>, add the <code>-D&lt;CMAKE_OPTION&gt;</code> flag when building with Make.</li> </ol> <p>You must also follow the same steps for the cryptographic provider library, such as the one located in <code>vendor/trezor_crypto/</code>.</p> <p>Note</p> <p>You can find available CMake options in the root <code>CMakeLists.txt</code> of the libtropic.</p> <p>Note</p> <p>You can compile libtropic as a static library using CMake separately and include only the resulting library file in your Makefile. This approach eliminates the need to compile the entire libtropic library and its dependencies in your Makefile. For more details, see Compiling as a Static Library.</p>"},{"location":"get_started/integrating_libtropic/compile_as_static_library/","title":"Compiling as a Static Library","text":"<p>Apart from building the Libtropic during your project's build process, you can build the Libtropic separately as a static library (also known as static archive on Linux) and link it later.</p>"},{"location":"get_started/integrating_libtropic/compile_as_static_library/#compilation","title":"Compilation","text":"<p>When compiling Libtropic as a static library, a cryptography provider must always be defined, either in your <code>CMakeLists.txt</code> file or via the CMake command-line arguments.</p> <p>To compile Libtropic as a static library on a Unix-like system, do:</p> <pre><code>$ mkdir build\n$ cd build\n$ cmake -DLT_CRYPTO=trezor_crypto .. # providing the crypto backend\n$ make\n</code></pre> <p>To cross-compile Libtropic as a static library on a Unix-like system, you need a toolchain configuration file and a linker script. Both should be provided by the vendor of your platform. You can see an example of the toolchain configuration and the linker script in the libtropic-stm32 repository.</p> <p>After acquiring both the toolchain configuration and the linker script, do:</p> <pre><code>$ mkdir build\n$ cd build\n$ cmake -DLT_CRYPTO=trezor_crypto -DCMAKE_TOOLCHAIN_FILE=&lt;ABSOLUTE PATH&gt;/toolchain.cmake -DLINKER_SCRIPT=&lt;ABSOLUTE PATH&gt;/linker_script.ld ..\n$ make\n</code></pre>"},{"location":"get_started/integrating_libtropic/compile_as_static_library/#linking-in-a-cmake-project","title":"Linking in a CMake Project","text":"<p>To link the compiled static library to your application, use <code>target_link_libraries</code>. For example:</p> <pre><code>add_executable(my_app source1.c source2.c etc.c)\ntarget_link_libraries(my_app &lt;absolute path to library file&gt;)\n</code></pre> <p>Note</p> <p>There are other options for linking the library (e.g., imported targets). Refer to the CMake documentation for more information.</p>"},{"location":"get_started/integrating_libtropic/compile_as_static_library/#linking-in-a-make-project","title":"Linking in a Make Project","text":"<p>If you are using <code>make</code> with a Makefile, you can include the static library by adding the following lines to your Makefile:</p> <pre><code>LDFLAGS += -L&lt;directory where the static library file is located&gt;\nLDLIBS  += -ltropic\n</code></pre> <p>Note</p> <p>Refer to the GNU Make documentation for more information about linking external libraries.</p>"},{"location":"get_started/integrating_libtropic/integration_examples/","title":"Integration Examples","text":"<p>We offer so-called platform repositories, where libtropic is utilized as a submodule, possibly showing an example of integrating libtropic into your application:</p> <ul> <li>libtropic-stm32,</li> <li>libtropic-linux.</li> </ul> <p>Tip</p> <p>These repositories include quick start guides to help you get started quickly with one of the supported platforms.</p> <p>Beside these repositories, we offer the libtropic-util repository, which implements a CLI based utility for executing TROPIC01's commands.</p>"},{"location":"other/","title":"Other","text":"<p>This section provides more information about libtropic, which did not fit into the other sections.</p> <ul> <li>TROPIC01 Model</li> <li>Provisioning Data</li> </ul>"},{"location":"other/provisioning_data/","title":"Provisioning Data","text":"<p>The <code>provisioning_data/</code> directory contains so called lab batch packages, which are data used for prsovisioning TROPIC01 chips in the Tropic Square lab for testing purposes. These lab batch packages are used here for configuring the TROPIC01 Model and for providing the tests and examples public and private keys for the TROPIC01's pairing key slot 0 (SH0PUB, SH0PRIV), so they can establish a secure session with the chip. </p> <p>Note</p> <p>Lab batch packages in this directory are stripped - they contain only data needed in libtropic.</p>"},{"location":"other/provisioning_data/#lab-batch-package-contents","title":"Lab Batch Package Contents","text":"<p>For example, the <code>2025-06-27T07-51-29Z__prod_C2S_T200__provisioning__lab_batch_package/</code> lab batch package:</p> <ol> <li><code>cert_chain/</code>: All certificates for the Certificate Store (excluding TROPIC01's eSE device certificate, which is originally not part of the lab batch package - can be found outside the <code>cert_chain/</code> directory).</li> <li><code>i_config/</code>, <code>r_config/</code>: Contains fields which should be written - currently not used.</li> <li><code>sh0_key_pair/</code>: Contains public and private key for the pairing key slot 0 (SH0PUB, SH0PRIV).</li> <li><code>tropic01_ese_certificate.pem</code>: TROPIC01's eSE device certificate.</li> <li><code>tropic01_ese_private_key.pem</code>: TROPIC01's eSE device private key (STPRIV).</li> </ol>"},{"location":"other/tropic01_model/","title":"TROPIC01 Model","text":"<p>Code in the <code>tropic01_model/</code> directory is meant to be compiled under Unix-like OS. This directory offers running libtropic's functional tests and examples against the TROPIC01's Python model, so no chip or external hardware is needed.</p> <ul> <li>Functional testing is managed by CTest - it executes both the test and the model automatically, along with the creation of model configuration.</li> <li>When running examples, you need to start the model manually and then execute the example binary in a separate terminal. This applies also for the tests, if they are not run using CTest.</li> <li>Both of these points are discussed further in this text.</li> </ul> <p>Warning</p> <p>There are some examples which are not compatible with model, as the model does not implement all the chip's functionality. As such, those will always fail against the model. Namely:</p> <ul> <li><code>lt_ex_fw_update</code>,</li> <li><code>lt_ex_show_chip_id_and_fwver</code> (model does not implement Bootloader mode, so you can use <code>tests/functional/lt_test_rev_get_info_req_app.c</code> to get this info from the Application mode atleast).</li> </ul>"},{"location":"other/tropic01_model/#how-it-works","title":"How it Works?","text":"<p>Both processes (tests/examples and model) will talk to each other through TCP socket at 127.0.0.1:28992. The SPI layer between libtropic and model is emulated through this TCP connection. The model responses are exactly the same as from physical TROPIC01 chip. </p> <p>Note</p> <p>This functionality is implemented with the help of the Unix TCP HAL implemented in <code>hal/port/unix/libtropic_port_unix_tcp.c</code>.</p>"},{"location":"other/tropic01_model/#model-setup","title":"Model Setup","text":"<p>First, the model has to be installed. For that, follow the readme in the ts-tvl repository.</p> <p>Next, it is possible to initialize the model with some data, so it can behave like the real provisioned chip. To do that, it is neccesary to pass a YAML configuration file to the model - see sections Model Server and Model Configuration in the ts-tvl repository. To create such a YAML configuration, the script <code>tropic01_model/create_model_cfg.py</code> in libtropic repository is used (example usage follows).</p> <p>Important</p> <p>In the case of running tests using CTest, no manual steps for creating the model configuration or initializing the model are necessary - CTest handles this by itself. In the case of running examples (or tests without CTest), the model has to be started manually by the user and some configuration has to be applied to the model, so atleast the pairing key slot 0 is written to be able to establish a secure session.</p> <p>Data, from which the <code>tropic01_model/create_model_cfg.py</code> script creates the YAML configuration file for the model, can be found in <code>provisioning_data/</code> directory - see Provisioning Data section for more information about the directory structure.</p> <p>To create a model configuration that will initialize the model to the state which is almost identical to the provisioned chip, the <code>tropic01_model/create_model_cfg.py</code> script is run as: <pre><code>cd tropic01_model/\npython3 create_model_cfg.py --pkg-dir &lt;path_to_the_lab_batch_package_directory&gt;\n</code></pre> where <code>&lt;path_to_the_lab_batch_package_directory&gt;</code> is the path to one of the lab batch packages inside the <code>provisioning_data/</code>. As a result of running the script, a file <code>model_cfg.yml</code> is created, which can be passed directly to the model using the <code>-c</code> flag.</p>"},{"location":"other/tropic01_model/#running-the-examples","title":"Running the Examples","text":"<ol> <li>Switch to the <code>tropic01_model/</code> directory: <pre><code>cd tropic01_model/\n</code></pre></li> <li> <p>Compile the examples: <pre><code>mkdir build\ncd build\ncmake -DLT_BUILD_EXAMPLES=1 ..\nmake\n</code></pre> As a result, executables for each example are built in the <code>tropic01_model/build/</code> directory. </p> <p>Tip</p> <p>To enable debugging symbols (e.g. to use GDB), add switch <code>-DCMAKE_BUILD_TYPE=Debug</code> when executing <code>cmake</code>.</p> <p>To use AddressSanitizer (ASan), add switches <code>-DCMAKE_BUILD_TYPE=Debug</code> and <code>-DLT_ASAN=1</code> when executing <code>cmake</code>.</p> </li> <li> <p>Create a YAML configuration for the model from one of the lab batch packages: <pre><code>python3 ../create_model_cfg.py --pkg-dir ../../provisioning_data/2025-06-27T07-51-29Z__prod_C2S_T200__provisioning__lab_batch_package/\n</code></pre> As a result, <code>model_cfg.yml</code> is created.</p> </li> <li> <p>In a separate terminal, start the model server (which was previously installed in a Python virtual environment) and configure it: <pre><code>model_server tcp -c model_cfg.yml\n</code></pre> As a result, the model now listens on TCP port 127.0.0.1:28992.</p> </li> <li> <p>In the original terminal, execute one of the built examples: <pre><code>./lt_ex_hello_world\n</code></pre> As a result, you should see an output from the example in the original terminal and a log from the model in the separate terminal.</p> </li> </ol>"},{"location":"other/tropic01_model/#running-the-tests","title":"Running the Tests","text":"<p>Note</p> <p>It is recommended to run the tests using CTest, but if it's needed to run the tests under GDB, they can be run exactly the same way as the examples.</p> <ol> <li>Switch to the <code>tropic01_model/</code> directory: <pre><code>cd tropic01_model/\n</code></pre></li> <li> <p>Compile the tests in this directory: <pre><code>mkdir build\ncd build\ncmake -DLT_BUILD_TESTS=1 ..\nmake\n</code></pre> As a result, executables for each test are built in the <code>tropic01_model/build/</code> directory. </p> <p>Tip</p> <p>To enable debugging symbols (e.g. to use GDB), add switch <code>-DCMAKE_BUILD_TYPE=Debug</code> when executing <code>cmake</code>.</p> <p>To use AddressSanitizer (ASan), add switches <code>-DCMAKE_BUILD_TYPE=Debug</code> and <code>-DLT_ASAN=1</code> when executing <code>cmake</code>.</p> <p>To execute the tests with Valgrind, add switches <code>-DCMAKE_BUILD_TYPE=Debug</code> and <code>-DLT_VALGRIND=1</code> when executing <code>cmake</code>. Note that Valgrind will be executed automatically only when using CTest!</p> </li> <li> <p>Now, the tests can be run using CTest. To see available tests, run: <pre><code>ctest -N\n</code></pre> To select specific test(s) using regular expression, run: <pre><code>ctest -R &lt;test_regex&gt;\n</code></pre> where <code>&lt;test_regex&gt;</code> is a regular expression for the test names from the list.</p> </li> </ol> <p>To run all tests, simply run: <pre><code>ctest\n</code></pre> </p> <p>Tip</p> <p>To enable verbose output from CTest, run <code>ctest -V</code> or <code>ctest -W</code> switch for even more verbose output.</p> <p>To exclude some tests, run: <pre><code>ctest -E &lt;test_regex&gt;\n</code></pre> where <code>&lt;test_regex&gt;</code> is a regular expression for the test names from the list.</p> <p>After CTest finishes, it informs about the results and saves all output to the <code>tropic01_model/build/run_logs/</code> directory. Output from the tests and responses from the model are saved. </p> <p>Note</p> <p>The model is automatically started for each test separately, so it behaves like a fresh TROPIC01 straight out of factory. All this and other handling is done by the script <code>scripts/model_test_runner.py</code>, which is called by CTest.</p> <p>Important</p> <p>When <code>-DLT_BUILD_EXAMPLES=1</code> or <code>-DLT_BUILD_TESTS=1</code> are passed to CMake, there has to be a way to define the SH0 private key for the TROPIC01's pairing key slot 0, because both the examples and the tests depend on it. For this purpose, the CMake variable <code>LT_SH0_PRIV_PATH</code> is used, which should hold the path to the file with the SH0 private key in PEM or DER format. By default, the path is set to the currently used lab batch package, found in <code>../provisioning_data/&lt;lab_batch_package_directory&gt;/sh0_key_pair/</code>. But it can be overriden by the user either from the command line when executing CMake (switch <code>-DLT_SH0_PRIV_PATH=&lt;path&gt;</code>), or from a child <code>CMakeLists.txt</code>.</p>"}]}