#ifndef TS_HOST_H
#define TS_HOST_H

/**
* @file libtropic.h
* @brief libtropic header file
* @author Tropic Square s.r.o.
*/

#include <stdbool.h>
#include <stddef.h>

#include "libtropic_common.h"

/**
 * @defgroup group_libtropic_API [PUBLIC API]
 * @details Dear users, please use this API. It contains all functions you need to interface with TROPIC01 device.
 * @{
 */

/**
 * @defgroup group_ts_init ts_init
 *
 * @brief Initialize device handle
 * @details No more details available.
 * @{
 */

/**
 * @brief Initialize handle and transport layer
 *
 * @param h           Device's handle
 * @return            TS_OK if success, otherwise returns other error code.
 */
ts_ret_t ts_init(ts_handle_t *h);

/** @} */ // end of group_ts_init

/**
 * @defgroup group_ts_deinit ts_deinit
 *
 * @brief  Deinitialize device handle
 * @details No more details available.
 * @{
 */

/**
 * @brief Deinitialize handle and transport layer
 *
 * @param h           Device's handle
 * @return            TS_OK if success, otherwise returns other error code.
 */
ts_ret_t ts_deinit(ts_handle_t *h);

/** @} */ // end of group_ts_deinit

/**
 * @defgroup group_ts_handshake ts_handshake
 *
 * @brief Establish a secure session
 * @details After succesfull execution, gcm contexts in passed handle will have kcmd and kres keys set.
 *        From this point, device will accept L3 commands.
 * @{
 */

/**
 * @brief Corresponds to $S_{H0Pub}$.
 */
# define TS_L2_HANDSHAKE_REQ_PKEY_INDEX_PAIRING_KEY_SLOT_0 0
/** @brief Corresponds to $S_{H1Pub}$ */
# define TS_L2_HANDSHAKE_REQ_PKEY_INDEX_PAIRING_KEY_SLOT_1 1
/** @brief Corresponds to $S_{H2Pub}$ */
# define TS_L2_HANDSHAKE_REQ_PKEY_INDEX_PAIRING_KEY_SLOT_2 2
/** @brief Corresponds to $S_{H3Pub}$ */
# define TS_L2_HANDSHAKE_REQ_PKEY_INDEX_PAIRING_KEY_SLOT_3 3

/**
 * @brief This function provides secure handshake functionality.
 *
 * @param h           Device's handle
 * @param stpub       STPUB from device's certificate
 * @param pkey_index  Index of pairing public key
 * @param shipriv     Secure host private key
 * @param shipub      Secure host public key
 * @return            TS_OK if success, otherwise returns other error code.
 */
ts_ret_t ts_handshake(ts_handle_t *h, const uint8_t *stpub, const uint8_t pkey_index, const uint8_t *shipriv, const uint8_t *shipub);

/** @} */ // end of group_ts_handshake

/**
 * @defgroup group_ts_ping ts_ping
 *
 * @brief Test secure session
 * @details Message passed to this function will be encrypted with session keys and
 *          sent/received through secure channel.
 * @{
 */

/** @brief Maximal length of Ping command message */
#define PING_LEN_MAX                     L3_CMD_DATA_SIZE_MAX

/**
 * @brief Test secure session by exchanging a message with chip
 *
 *
 * @param h           Device's handle
 * @param msg_out     Ping message going out
 * @param msg_in      Ping message going in
 * @param len         Length of ping message
 * @return            TS_OK if success, otherwise returns other error code.
 */
ts_ret_t ts_ping(ts_handle_t *h, const uint8_t *msg_out, uint8_t *msg_in, const uint16_t len);

/** @} */ // end of group_ts_ping

/**
 * @defgroup group_ts_random_get ts_random_get
 * @brief Get random bytes from TROPIC01
 * @details This function provides access to random bytes generated by TROPIC01's random number generator
 *
 * @{
 */

/** @brief Maximum number of random bytes requested at once */
#define RANDOM_VALUE_GET_LEN_MAX         L2_CHUNK_MAX_DATA_SIZE

/**
 * @brief Get number of random bytes
 *
 * @param h           Device's handle
 * @param buff        Buffer
 * @param len         Number of random bytes
 * @return            TS_OK if success, otherwise returns other error code.
 */
ts_ret_t ts_random_get(ts_handle_t *h, uint8_t *buff, const uint16_t len);

/** @} */ // end of group_ts_random_get

/**
 * @defgroup group_ecc_functions ECC functions
 * @brief Group of ECC commands
 * @details
 *
 * @{
 */

/** @brief ECC key slot 0 */
#define ECC_SLOT_0 0
/** @brief ECC key slot 1 */
#define ECC_SLOT_1 1
/** @brief ECC key slot 2 */
#define ECC_SLOT_2 2
/** @brief ECC key slot 3 */
#define ECC_SLOT_3 3
/** @brief ECC key slot 4 */
#define ECC_SLOT_4 4
/** @brief ECC key slot 5 */
#define ECC_SLOT_5 5
/** @brief ECC key slot 6 */
#define ECC_SLOT_6 6
/** @brief ECC key slot 7 */
#define ECC_SLOT_7 7
/** @brief ECC key slot 8 */
#define ECC_SLOT_8 8
/** @brief ECC key slot 9 */
#define ECC_SLOT_9 9
/** @brief ECC key slot 10 */
#define ECC_SLOT_10 10
/** @brief ECC key slot 11 */
#define ECC_SLOT_11 11
/** @brief ECC key slot 12 */
#define ECC_SLOT_12 12
/** @brief ECC key slot 13 */
#define ECC_SLOT_13 13
/** @brief ECC key slot 14 */
#define ECC_SLOT_14 14
/** @brief ECC key slot 15 */
#define ECC_SLOT_15 15
/** @brief ECC key slot 16 */
#define ECC_SLOT_16 16
/** @brief ECC key slot 17 */
#define ECC_SLOT_17 17
/** @brief ECC key slot 18 */
#define ECC_SLOT_18 18
/** @brief ECC key slot 19 */
#define ECC_SLOT_19 19
/** @brief ECC key slot 20 */
#define ECC_SLOT_20 20
/** @brief ECC key slot 21 */
#define ECC_SLOT_21 21
/** @brief ECC key slot 22 */
#define ECC_SLOT_22 22
/** @brief ECC key slot 23 */
#define ECC_SLOT_23 23
/** @brief ECC key slot 24 */
#define ECC_SLOT_24 24
/** @brief ECC key slot 25 */
#define ECC_SLOT_25 25
/** @brief ECC key slot 26 */
#define ECC_SLOT_26 26
/** @brief ECC key slot 27 */
#define ECC_SLOT_27 27
/** @brief ECC key slot 28 */
#define ECC_SLOT_28 28
/** @brief ECC key slot 29 */
#define ECC_SLOT_29 29
/** @brief ECC key slot 30 */
#define ECC_SLOT_30 30
/** @brief ECC key slot 31 */
#define ECC_SLOT_31 31

/** @brief P256 Curve - 64-byte long public key */
# define TS_L3_ECC_KEY_GENERATE_CURVE_P256 1
/** @brief Ed25519 Curve - 32-byte long public key */
# define TS_L3_ECC_KEY_GENERATE_CURVE_ED25519 2

/** Type of ECC key: P256 Curve - 64-byte long public key. */
# define TS_L3_ECC_KEY_READ_CURVE_P256 1
/** Type of ECC key: Ed25519 Curve - 32-byte long public key */
# define TS_L3_ECC_KEY_READ_CURVE_ED25519 2
/** Origin of the key: The key is from key generation on the device. */
# define TS_L3_ECC_KEY_READ_ORIGIN_ECC_KEY_GENERATE 1
/** Origin of the key: The key is from key storage in the device */
# define TS_L3_ECC_KEY_READ_ORIGIN_ECC_KEY_STORE 2

/**
 * @defgroup group_ts_ecc_key_generate ts_ecc_key_generate
 * @brief Generate ECC key
 * @details Generate ECC private key in internal slots inside of TROPIC01
 * @{
 */

/**
 * @brief Generate ECC key in the device's ECC key slot
 *
 * @param h           Device's handle
 * @param slot        Slot number ECC_SLOT_1 - ECC_SLOT_32
 * @param curve       Type of ECC curve. Use L3_ECC_KEY_GENERATE_CURVE_ED25519 or L3_ECC_KEY_GENERATE_CURVE_P256
 * @return            TS_OK if success, otherwise returns other error code.
 */
ts_ret_t ts_ecc_key_generate(ts_handle_t *h, const uint8_t slot, const uint8_t curve);

/** @} */ // end of group_ts_ecc_key_generate

/**
 * @defgroup group_ts_ecc_key_read ts_ecc_key_read
 * @brief Read ECC public key
 * @details Read ECC public key corresponding to private key in TROPIC01's slot.
 *
 * @{
 */

/**
 * @brief Read ECC public key corresponding to a private key in device's slot
 *
 * @param h           Device's handle
 * @param slot        Slot number ECC_SLOT_1 - ECC_SLOT_32
 * @param key         Buffer for retrieving a key
 * @param keylen      Length of the key's buffer
 * @param curve       Will be filled by curve byte
 * @param origin      Will be filled by origin byte
 * @return            TS_OK if success, otherwise returns other error code.
 */
ts_ret_t ts_ecc_key_read(ts_handle_t *h, const uint8_t slot, uint8_t *key, const int8_t keylen, uint8_t *curve, uint8_t *origin);

/** @} */ // end of group_ts_ecc_key_read

/**
 * @defgroup group_ts_eddsa_sign ts_eddsa_sign
 * @brief Sign with TROPIC01
 * @details Use TROPIC01 to EdDSA sign a message with a private key in its slot
 *
 * @{
 */

/**
 * @brief EdDSA sign message with a private key stored in TROPIC01 device
 *
 * @param h           Device's handle
 * @param slot        Slot containing a private key, ECC_SLOT_1 - ECC_SLOT_32
 * @param msg         Buffer containing a message to sign, max length is 4096B
 * @param msg_len     Length of a message
 * @param rs          Buffer for storing a signature in a form of R and S bytes
 * @param rs_len      Length of rs buffer should be 64B
 * @return            TS_OK if success, otherwise returns other error code.
 *
 */
ts_ret_t ts_eddsa_sign(ts_handle_t *h, const uint8_t slot, const uint8_t *msg, const int16_t msg_len, uint8_t *rs, const int8_t rs_len);

/** @} */ // end of group_ts_eddsa_sign

/**
 * @defgroup group_ts_eddsa_verify ts_eddsa_verify
 * @brief Verify signature
 * @details Prior to this call, public key related to used signing slot must be queried from TROPIC01.
 *          F siunction verifies signature against this public key.
 *
 * @{
 */

/**
 * @brief EdDSA signature verify
 *
 * @param msg         Message
 * @param msg_len     Length of message. Max length is 4095
 * @param pubkey      Public key related to private key which signed the message
 * @param rs          Signature to be verified, in a form of R and S bytes
 * @return            TS_OK if success, otherwise returns other error code.
 *
 */
ts_ret_t ts_eddsa_sig_verify(const uint8_t *msg, const uint16_t msg_len, const uint8_t *pubkey, const uint8_t *rs);

/** @} */ // end of group_ts_eddsa_sign

/**
 * @defgroup group_ts_ecdsa_sign ts_ecdsa_sign
 * @brief Sign with TROPIC01
 * @details Use TROPIC01 to ECDSA sign a message with a private key in its slot
 *
 * @{
 */

/**
 * @brief ECDSA sign message with a private key stored in TROPIC01 device
 *
 * @param h           Device's handle
 * @param slot        Slot containing a private key, ECC_SLOT_1 - ECC_SLOT_32
 * @param msg_hash    Buffer containing hash of a message
 * @param msg_hash_len Length of hash's buffer should be 32B
 * @param rs          Buffer for storing a signature in a form of R and S bytes
 * @param rs_len      Length of rs buffer should be 64B
 * @return            TS_OK if success, otherwise returns other error code.
 */
ts_ret_t ts_ecdsa_sign(ts_handle_t *h, const uint8_t slot, const uint8_t *msg_hash, const int16_t msg_hash_len, uint8_t *rs, const int8_t rs_len);

/** @} */ // end of group_ts_ecdsa_sign

/**
 * @defgroup group_ts_ecc_key_erase ts_ecc_key_erase
 * @brief Erase ECC key
 * @details Erase ECC private key in a corresponding slot inside of TROPIC01
 *
 * @{
 */

/**
 * @brief Erase ECC key from device's slot
 *
 * @param h           Device's handle
 * @param slot        Slot number ECC_SLOT_1 - ECC_SLOT_32
 * @return            TS_OK if success, otherwise returns other error code.
 */
ts_ret_t ts_ecc_key_erase(ts_handle_t *h, const uint8_t slot);

/** @} */ // end of group_ts_ecc_key_erase

/** @} */ // end of group_ecc_functions

/**
 * @defgroup group_ts_get_info_cert ts_get_info_cert
 * @brief Get device's certificate
 * @details Obtain X509 device's certificate from TROPIC01's I-config memory.
 *
 * @{
 */

/** @brief The X.509 device certificate read from I-Memory and signed by Tropic Square (max length of 512B) */
# define TS_L2_GET_INFO_REQ_OBJECT_ID_X509_CERTIFICATE 0
/** @brief The chip ID - the chip silicon revision and unique device ID (max length of 128B) */
# define TS_L2_GET_INFO_REQ_OBJECT_ID_CHIP_ID 1
/** @brief The RISCV current running FW version (4 Bytes) */
# define TS_L2_GET_INFO_REQ_OBJECT_ID_RISCV_FW_VERSION 2
/** @brief The SPECT FW version (4 Bytes) */
# define TS_L2_GET_INFO_REQ_OBJECT_ID_SPECT_FW_VERSION 4
/** @brief The FW header read from the selected bank id (shown as an index). Supported only in Start-up mode */
# define TS_L2_GET_INFO_REQ_OBJECT_ID_FW_BANK 176
/** @brief Request for data bytes 0-127 of the object */
# define TS_L2_GET_INFO_REQ_BLOCK_INDEX_DATA_CHUNK_0_127 0
/** @brief Request for data bytes 128-255 of the object (only needed for the X.509 certificate) */
# define TS_L2_GET_INFO_REQ_BLOCK_INDEX_DATA_CHUNK_128_255 1
/** @brief Request for data bytes 128-383 of object (only needed for the X.509 certificate) */
# define TS_L2_GET_INFO_REQ_BLOCK_INDEX_DATA_CHUNK_256_383 2
/** @brief Request for data bytes 384-511 of object (only needed for the X.509 certificate) */
# define TS_L2_GET_INFO_REQ_BLOCK_INDEX_DATA_CHUNK_384_511 3

/** @brief Maximal size of certificate */
#define TS_L2_GET_INFO_REQ_CERT_SIZE         512

/**
 * @brief Get device's certificate
 *
 * @param h           Device's handle
 * @param cert        Certificate's buffer
 * @param max_len     Length of certificate's buffer
 * @return            TS_OK if success, otherwise returns other error code.
 */
ts_ret_t ts_get_info_cert(ts_handle_t *h, uint8_t *cert, const int16_t max_len);

/**
 * @brief Verify certificate chain and parse STPUB
 *
 * @param cert        Certificate in DER format
 * @param max_len     Len of certificate buffer
 * @param stpub       TROPIC01 STPUB, unique for each device
 * @return            TS_OK if success, otherwise returns other error code.
 */
ts_ret_t ts_cert_verify_and_parse(const uint8_t *cert, const int16_t max_len, uint8_t *stpub);

/** @} */ // end of group_ts_get_info_cert

/** @} */ // end of group_libtropic_API

// TODO
//ts_ret_t ts_get_info_chip_id(ts_handle_t *h, uint8_t chip_id, uint16_t max_len);
//ts_ret_t ts_get_info_riscv_fw_ver(ts_handle_t *h, uint8_t ver, uint16_t max_len);
//ts_ret_t ts_get_info_spect_fw_ver(ts_handle_t *h, uint8_t ver, uint16_t max_len);
//ts_ret_t ts_get_info_fw_bank(ts_handle_t *h, uint8_t fw_bank, uint16_t max_len);

/**
 * @details Helper function for printing out name of returned value
 *
 * @param ret ts_ret_t returned type value
 * @return const char* description of return value.
 */
const char *ts_ret_verbose(ts_ret_t ret);

#endif
